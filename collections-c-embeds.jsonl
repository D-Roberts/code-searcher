"{\"sha\": \"114cf2f165c49df48f7d154dcf8c1e4133d05410\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"examples/hashtable/initialization/custom_key_types.c\", \"func_name\": \"point_compare\", \"original_string\": \"int point_compare(const void *key1, const void *key2)\\n{\\n    struct Point p1 = *((struct Point*) key1);\\n    struct Point p2 = *((struct Point*) key2);\\n    return !(p1.x == p2.x && p1.y == p2.y);\\n}\", \"code_tokens\": [\"int\", \"point_compare\", \"(\", \"const\", \"void\", \"*\", \"key1\", \",\", \"const\", \"void\", \"*\", \"key2\", \")\", \"{\", \"struct\", \"Point\", \"p1\", \"=\", \"*\", \"(\", \"(\", \"struct\", \"Point\", \"*\", \")\", \"key1\", \")\", \";\", \"struct\", \"Point\", \"p2\", \"=\", \"*\", \"(\", \"(\", \"struct\", \"Point\", \"*\", \")\", \"key2\", \")\", \";\", \"return\", \"!\", \"(\", \"p1\", \".\", \"x\", \"==\", \"p2\", \".\", \"x\", \"&&\", \"p1\", \".\", \"y\", \"==\", \"p2\", \".\", \"y\", \")\", \";\", \"}\"], \"docstring\": \"/* We need to create a custom comparator function for our\\n   Point structure. If keys are equal the function should\\n   return 0. */\", \"docstring_tokens\": [\"/\", \"*\", \"We\", \"need\", \"to\", \"create\", \"a\", \"custom\", \"comparator\", \"function\", \"for\", \"our\", \"Point\", \"structure\", \".\", \"If\", \"keys\", \"are\", \"equal\", \"the\", \"function\", \"should\", \"return\", \"0\", \".\", \"*\", \"/\"], \"raw_contents\": \"/* Example of a table using the data behind the pointer as keys.\\n\\n   (check the pointer key example for direct pointer keys) */\\n\\n#include <cc_hashtable.h>\\n#include <stdio.h>\\n\\n\\n/* Structure that we will use as a key. */\\nstruct Point {\\n    int x;\\n    int y;\\n};\\n\\n\\n/* We need to create a custom comparator function for our\\n   Point structure. If keys are equal the function should\\n   return 0. */\\nint point_compare(const void *key1, const void *key2)\\n{\\n    struct Point p1 = *((struct Point*) key1);\\n    struct Point p2 = *((struct Point*) key2);\\n    return !(p1.x == p2.x && p1.y == p2.y);\\n}\\n\\n\\nint main(int argc, char **argv)\\n{\\n    (void)argc;\\n    (void)argv;\\n\\n    /* Define the config structure (for more details check the\\n       configuration example) */\\n    CC_HashTableConf config;\\n\\n    /* While it's not necessary, it's always a good idea to initialize the\\n       config structure to default values and then override whichever\\n       value we need. */\\n    cc_hashtable_conf_init(&config);\\n\\n    /* First we need to set the key length to match the length of\\n       our Point structure. */\\n    config.key_length = sizeof(struct Point);\\n\\n    /* Next, we set the hash function. The library provides a general\\n       hash function we can use. */\\n    config.hash = GENERAL_HASH;\\n\\n    /* Finally we need to set the key comparator function. */\\n    config.key_compare = point_compare;\\n\\n    /* We can define a new table */\\n    CC_HashTable *table;\\n\\n    /* Create a new hashtable that Point structures as keys and assign to\\n       *table*. The return value indicates the success or failure of the\\n       operation. */\\n    enum cc_stat status = cc_hashtable_new_conf(&config, &table);\\n\\n    /* It's always a good idea to check whether the allocation of a new\\n       structure was successful or not. */\\n    if (status != CC_OK) {\\n        /* Do some error handling */\\n        if (status == CC_ERR_ALLOC) {\\n            /* This is the only kind of error cc_hashtable_new can return.\\n               It means that the allocation has failed. */\\n        }\\n    }\\n\\n    /* ************************************************************\\n      Adding keys\\n    ************************************************************/\\n\\n    struct Point point;\\n    point.x = 8;\\n    point.y = 10;\\n\\n    /* Add a new key value pair. */\\n    cc_hashtable_add(table, (void*) &point, \\\"foo\\\");\\n\\n    /* Destroy the table structure */\\n    cc_hashtable_destroy(table);\\n    return 0;\\n}\\n\", \"embeddings\": [-0.022376470267772675, 0.08614083379507065, -0.03380591422319412, 0.044675152748823166, 0.2642609775066376, -0.1340823918581009, 0.08017640560865402, 0.30704209208488464, 0.04835663363337517, -0.17559140920639038, 0.036406420171260834, -0.08939353376626968, -0.0658339187502861, 0.018798276782035828, 0.037387680262327194, -0.0009881481528282166, 0.0010825898498296738, 0.005961626768112183, 0.06831788271665573, -0.16363394260406494, -0.12871700525283813, 0.020822778344154358, 0.16033324599266052, 0.0952024757862091, 0.17575938999652863, -0.03922469541430473, 0.22808462381362915, 0.1239563375711441, 0.21105125546455383, -0.08236102759838104, 0.09366465359926224, 0.011373087763786316, 0.09245681762695312, -0.16991181671619415, 0.04929611459374428, 0.02358754351735115, 0.03834400326013565, 0.1080084815621376, -0.014784451574087143, 0.039255060255527496, -0.22362855076789856, 0.021897953003644943, 0.07209818810224533, 0.17526668310165405, 0.08175580203533173, 0.02639344334602356, -0.021953925490379333, 0.1531076431274414, -0.11014869809150696, 0.015565985813736916, 0.06292814016342163, 0.04546526446938515, -0.015507044270634651, -0.018248852342367172, -0.07367102801799774, 0.017285609617829323, 0.006639659404754639, 0.3672206401824951, 0.0642189309000969, -0.05245959013700485, -0.07437360286712646, 0.018508724868297577, -0.06629132479429245, 0.057621993124485016, 0.03862236440181732, 0.037682607769966125, -0.15122269093990326, -0.13424800336360931, 0.016382690519094467, -0.03473304212093353, 0.13717985153198242, -0.02639581821858883, 0.03996454179286957, -0.13793201744556427, -0.13865430653095245, 0.04280351474881172, 0.09390488266944885, 0.6401004195213318, -0.1469850391149521, 0.1806568056344986, 0.21346347033977509, -0.10961669683456421, 0.06423192471265793, 0.11348679661750793, 0.00674709677696228, 0.04531044885516167, -0.048167191445827484, 0.10001567006111145, 0.09691707789897919, 0.0809030830860138, 0.04906165599822998, 0.11145110428333282, -0.040456511080265045, -0.03134368732571602, 0.045211050659418106, 0.023152703419327736, 0.06652797013521194, -0.3308209180831909, 0.02483886107802391, 0.23492828011512756, -0.021994013339281082, -0.04779146984219551, -0.15856751799583435, 0.0071153417229652405, -0.013846099376678467, 0.004961006343364716, 0.0722074881196022, 0.052219074219465256, 0.06609968841075897, -0.06459362059831619, 0.08282190561294556, 0.057819005101919174, -0.10521633923053741, 0.05150909721851349, 0.03252715989947319, -0.15383780002593994, 0.046933576464653015, -0.07377123087644577, 0.07876016199588776, -0.04494353383779526, 0.1214522123336792, 0.0389191210269928, -0.05231934040784836, -0.0475580170750618, 0.07582524418830872, 0.12872473895549774, -0.00305214524269104, -0.1415891945362091, 0.11279784142971039, 0.10951131582260132, -0.02519838511943817, -0.20025500655174255, 0.049924951046705246, 0.07425309717655182, 0.1668083369731903, -0.014070414006710052, -0.0024328604340553284, -0.002631939947605133, -0.057225026190280914, 0.017902404069900513, -0.022209294140338898, 0.06530106067657471, 0.2895922064781189, -0.05449245497584343, 0.18086710572242737, -0.08374617993831635, 0.10113202035427094, 0.11138144135475159, -0.22115065157413483, -0.17747178673744202, -0.004508167505264282, -0.09123707562685013, 0.018538298085331917, 0.015072956681251526, -0.19210675358772278, 0.7695135474205017, 0.2359796017408371, -0.07460823655128479, -0.0003152713179588318, -0.08695421367883682, 0.015336591750383377, -0.17683415114879608, 0.02703344263136387, 0.03030574321746826, 0.043925873935222626, 0.1476985514163971, -0.013214491307735443, 0.05699611455202103, 0.10602358728647232, 0.0069124698638916016, 0.008439930155873299, 0.030130553990602493, -0.11703138053417206, 0.15325401723384857, -0.031874872744083405, -0.07675143331289291, -0.22212636470794678, 0.0761905163526535, -0.010105582885444164, 0.023965556174516678, -0.06942832469940186, -0.0400141105055809, -0.15702910721302032, -0.05599425733089447, -0.009311847388744354, -0.043073270469903946, 0.07436998188495636, -0.041703663766384125, 0.13503819704055786, 0.09090565145015717, -0.12090134620666504, 0.08618108183145523, 0.07843534648418427, -0.025287240743637085, 0.04476973041892052, 0.12599141895771027, -0.20476755499839783, -0.06262583285570145, 0.11921195685863495, -0.08559584617614746, -0.018222128972411156, -0.09455408155918121, 0.14142322540283203, -0.10182057321071625, 0.21169765293598175, 0.12592756748199463, -0.11146333068609238, 0.05892534181475639, -0.023473989218473434, -0.047621387988328934, -0.030066337436437607, 0.27322787046432495, 0.1771019846200943, -0.032876044511795044, -0.11632348597049713, -0.0835697129368782, -0.005240630358457565, 0.060064978897571564, -0.04778105020523071, -0.15478365123271942, 0.11778856813907623, 0.14791062474250793, -0.01064428873360157, -0.06751298904418945, 0.005291728302836418, 0.27490779757499695, 0.1462121307849884, 0.06897738575935364, -0.018208537250757217, -0.031794145703315735, 0.16412240266799927, 0.059618644416332245, -0.10813809931278229, 0.16262909770011902, 0.049843400716781616, -0.025404874235391617, -0.1250743269920349, 0.058354511857032776, -0.03607375919818878, -0.09777194261550903, 0.02129290997982025, 0.04687190055847168, 0.15132009983062744, 0.2760051488876343, 0.08803844451904297, 0.0492851659655571, -0.14450283348560333, -0.06859061866998672, -0.11338305473327637, 0.006259270012378693, -0.0653596967458725, -0.1591692566871643, 0.05439983680844307, -0.03297687694430351, -0.061600249260663986, -0.10079950094223022, -0.1693682223558426, 0.07552257180213928, 0.022641675546765327, 0.13015976548194885, -0.05267566442489624, -0.1309143304824829, -0.009148038923740387, -0.03739267587661743, -0.07121600210666656, -0.35116463899612427, -0.05653717368841171, -0.021988999098539352, 0.024208223447203636, 0.016926079988479614, 0.15201127529144287, -0.05554746836423874, 0.2057439684867859, 0.14442825317382812, 0.03664378076791763, 0.021922875195741653, 0.07163329422473907, -0.06960293650627136, -0.08971668779850006, -0.003372322767972946, -0.03057212010025978, 0.05645978823304176, -0.1122143417596817, 0.06748970597982407, -0.07592744380235672, 0.11299410462379456, -0.056688159704208374, -0.054586440324783325, 0.07799431681632996, 0.06527475267648697, 0.03423362970352173, -0.017751343548297882, 0.06503836065530777, 0.13569964468479156, 0.020167775452136993, 0.0851668119430542, 0.16471272706985474, -0.06416851282119751, 0.12110932171344757, -0.23702514171600342, -0.03373904526233673, -0.07897336035966873, -0.03693488985300064, -0.10823880136013031, 0.25475215911865234, -0.06081340089440346, 0.05547744035720825, 0.0666022002696991, 0.2843192219734192, -0.0123077891767025, -0.02226920798420906, 0.03508087247610092, -0.05514422059059143, 0.1758420467376709, -0.08692696690559387, -0.02589205652475357, -0.006853891536593437, -0.05766379460692406, 0.047502703964710236, -0.03920309245586395, -0.09660637378692627, 0.10683441162109375, 0.08728417009115219, 0.13539493083953857, -0.004788551479578018, 0.07516627758741379, 0.10404953360557556, -0.0700753927230835, -0.03469816595315933, 0.7259977459907532, -0.5329653024673462, 0.10119455307722092, -0.17643161118030548, 0.24051335453987122, 0.02571149542927742, 0.18864227831363678, -0.05419044941663742, 0.03592166677117348, 0.12643156945705414, 0.14927184581756592, -0.027563124895095825, -0.0391758531332016, -0.0760107934474945, 0.25249767303466797, 0.0215364508330822, 0.12432292848825455, 0.17386381328105927, -0.11297355592250824, 0.12751656770706177, -0.047662146389484406, -0.21476921439170837, 0.104525126516819, -0.05238894373178482, -0.16206012666225433, 0.024343136698007584, 0.33620718121528625, -0.08453129231929779, -0.03320262208580971, -0.023413263261318207, 0.1079268530011177, 0.11613684147596359, -0.05493540316820145, 0.12466812133789062, -0.14977973699569702, 0.24354012310504913, -0.32748842239379883, -0.3379479944705963, 0.02805718407034874, -0.10860656201839447, 0.09897898137569427, 0.11594191193580627, 0.23361900448799133, 0.0770934596657753, -0.11591868847608566, 0.00664868950843811, -0.007660169154405594, -0.12494587898254395, 0.043026842176914215, 0.08164169639348984, 0.21019750833511353, 0.06197591871023178, 0.09720492362976074, 0.04370556399226189, 0.03362289071083069, 0.04068063199520111, -0.1293814778327942, 0.26588550209999084, 0.14820849895477295, 0.22912262380123138, -0.07563100755214691, 0.13985863327980042, -0.14204277098178864, 0.07199135422706604, 0.053780004382133484, 0.01408783346414566, 0.04257606714963913, -0.045028205960989, 0.04207132011651993, -0.07402870804071426, -0.11188672482967377, 0.07222361862659454, 0.14059633016586304, -0.0695687085390091, 0.035680416971445084, 0.1573452353477478, 0.11037212610244751, 0.006992424838244915, -0.13686682283878326, -0.18185748159885406, -0.164332777261734, 0.05054028332233429, 0.0792386457324028, 0.03874700143933296, 0.1098567396402359, 0.10475996136665344, -0.07717333734035492, 0.030345238745212555, -0.1499069184064865, -0.08957842737436295, 0.17597007751464844, 0.09976806491613388, 0.11404368281364441, 0.060521990060806274, -0.05170337110757828, -0.023336537182331085, -0.060963355004787445, 0.0351814404129982, -0.05460376292467117, 0.11301471292972565, -0.09106077253818512, 0.0032545775175094604, 0.2985154986381531, 0.03215698152780533, 0.12976837158203125, 0.03694772347807884, -0.07914813607931137, -0.0940176248550415, 0.03677435964345932, -0.01717332936823368, 0.032740458846092224, -0.002059321850538254, -0.02825162559747696, 0.06872916966676712, 0.05741608142852783, -0.03184005618095398, -0.08211614191532135, 0.3618541657924652, 0.05647267401218414, -0.07635331153869629, 0.056374695152044296, -0.17491407692432404, 0.00680706650018692, -0.08409026265144348, -0.35501623153686523, 0.05287826061248779, 0.13276195526123047, 0.11976809799671173, 0.04292312636971474, 0.07619178295135498, 0.02582463249564171, 0.0059244148433208466, 0.16850650310516357, 0.042997486889362335, -0.09292014688253403, 0.022097118198871613, -0.03858872503042221, 0.12122783809900284, 0.03804640844464302, 0.03709462285041809, 0.016980409622192383, 0.023708954453468323, 0.13490307331085205, -0.0004856400191783905, -0.1401437669992447, 0.02065039426088333, -0.017773441970348358, -0.047396011650562286, -0.1854219287633896, 0.15449951589107513, -0.2025623321533203, -0.01824057474732399, 0.024347655475139618, 0.1610320657491684, 0.03367440402507782, -0.015220073983073235, -0.11170745640993118, 0.17796780169010162, 0.15462665259838104, -0.11884485185146332, -0.01472024992108345, -0.05739176273345947, -0.0065685659646987915, 0.035743534564971924, 0.17089709639549255, 0.2692640423774719, 0.15528425574302673, 0.1250167191028595, 0.08521787077188492, 0.1842951774597168, -0.05159681290388107, -0.014537498354911804, 0.1448674350976944, 0.08657673746347427, -0.05398022010922432, -0.08935734629631042, -0.008724790066480637, 0.032304827123880386, 0.08832885324954987, 0.1443939208984375, -0.15744087100028992, 0.00023296475410461426, -0.02369432896375656, 0.17431838810443878, 0.015546038746833801, 0.04363946616649628, 0.02000683918595314, 0.013628408312797546, 0.08469367027282715, 0.0453927181661129, 0.18320751190185547, -0.08868439495563507, -0.12571091949939728, -0.028287362307310104, 0.05660849064588547, -0.06077386438846588, 0.01540291402488947, 0.10402196645736694, -0.09955347329378128, 0.074531689286232, 0.0034932494163513184, 0.05517933517694473, -0.0028055906295776367, 0.07311901450157166, 0.13104143738746643, -0.005657806992530823, 0.07392796874046326, 0.08008909970521927, -0.12771940231323242, 0.09547384828329086, -0.04487411677837372, -0.17257438600063324, -0.0003069154918193817, 0.1130494698882103, -0.0914880782365799, 0.14320868253707886, -0.03727702051401138, 0.10184083878993988, -0.061029911041259766, 0.014331376180052757, -0.006412819027900696, -0.07967397570610046, -0.8651441335678101, -0.016172081232070923, 0.14220337569713593, -0.006143976002931595, 0.08600837737321854, 0.12234695255756378, 0.1557372510433197, 0.08676128834486008, 0.15092036128044128, 0.06319998949766159, 0.023382285609841347, 0.09298984706401825, 0.15621593594551086, -0.15015901625156403, -0.015085194259881973, 0.08575232326984406, 0.08365590870380402, -0.1598404198884964, 0.21037864685058594, 0.027515755966305733, -0.0875362679362297, -0.008243739604949951, 0.2759559452533722, 0.12558484077453613, 0.03595777601003647, 0.21627819538116455, 0.011310331523418427, 0.16415968537330627, 0.00909353792667389, 0.07012910395860672, 0.21705687046051025, 0.09672333300113678, -0.23698222637176514, 0.05926835909485817, 0.10648152232170105, 0.1035998985171318, 0.15186716616153717, 13.770013809204102, -0.08385070413351059, 0.16575220227241516, 0.05087406933307648, -0.02567647397518158, 0.0183551125228405, -0.061070047318935394, 0.04380829632282257, -0.038602665066719055, 0.029803592711687088, 0.07138361036777496, -0.0034007299691438675, 0.013111679814755917, 0.04989457130432129, -0.007241733372211456, -0.07776893675327301, -0.03806021809577942, -0.045177146792411804, 0.15575425326824188, 0.03297413885593414, -0.1237187385559082, -0.20171566307544708, 0.037169937044382095, -0.3040599226951599, -0.027372566983103752, -0.04223722964525223, 0.1814754605293274, 0.10657983273267746, 0.04084327071905136, 0.05755718797445297, 0.11370304226875305, 0.16661125421524048, 0.05672641843557358, -0.06488141417503357, -0.05703838914632797, -0.1269676387310028, -0.34414583444595337, -0.07373380661010742, 0.10052894800901413, -0.029034674167633057, 0.044915422797203064, 0.06287004053592682, 0.14316073060035706, -0.038524992763996124, 0.1446511447429657, 0.08157725632190704, -0.13703499734401703, 0.17065203189849854, 0.01748262345790863, -0.09835375845432281, 0.14022548496723175, 0.10627582669258118, 0.310702919960022, -0.06343130767345428, -0.12448682636022568, -0.19147756695747375, 0.21158796548843384, 0.042832523584365845, -0.03881937265396118, 0.2764652371406555, -0.08476775884628296, -0.018171198666095734, -0.02538001537322998, -0.056404877454042435, -0.03724769875407219, 0.06334453076124191, 0.17835001647472382, 0.09100937098264694, 0.10482713580131531, 0.10032721608877182, 0.16236796975135803, -0.0528973788022995, 0.10932430624961853, 0.14146697521209717, -0.11992692947387695, 0.07723340392112732, -0.11434469372034073, 0.01429956778883934, 0.0591929592192173, -0.21211692690849304, 0.0048677027225494385, -0.005624320358037949, -0.14597594738006592, -0.08740594238042831, -0.18443086743354797, 0.1888771802186966, -0.19290663301944733, 0.2379147708415985, 0.17579242587089539, 0.021922945976257324, -0.05171361565589905, 0.04232876002788544, 0.0045728422701358795, -0.09385966509580612, 0.1946810781955719, -0.052155688405036926, 0.0049053337424993515, -0.12555761635303497, 0.056598514318466187, 0.12716253101825714, -0.03698181360960007, -0.1436767429113388, 0.014528181403875351, 0.046013057231903076, -0.14867344498634338, 0.06210731342434883, 0.05068774148821831, -0.06906473636627197, -0.028038807213306427, 0.06983092427253723, 0.031363584101200104, 0.14756041765213013, 0.13569402694702148, -0.22383172810077667, -0.09768214821815491, -0.016980011016130447, 0.05109643563628197, -0.05261766538023949, 0.18566656112670898, 0.05866395682096481, 0.1787918210029602, 0.06016070768237114, -0.053148310631513596, -0.10289676487445831, 0.08406727015972137, -0.09731137752532959, 0.11050152778625488, 0.199294775724411, 0.02629443071782589, 0.017102863639593124, 0.09803824126720428, -0.10780204087495804, 0.3381146192550659, 0.09903675317764282, 0.012038685381412506, -0.0013274624943733215, -0.1332196295261383, 0.02822205051779747, 0.12982384860515594, 0.12093877047300339, 0.11643437296152115, 0.07205675542354584, 0.14625169336795807, -0.14072328805923462, -0.03108809143304825, 0.17410437762737274, 0.18770340085029602, 0.027198011055588722, -0.021726135164499283, 0.08301079273223877, 0.09512270987033844, 0.20990781486034393, -0.07577347010374069, -0.10620318353176117, -0.08387219905853271, -0.2016134113073349, -0.0751861184835434, 0.05041489750146866, 0.0027437247335910797, -0.02471671625971794, 0.1585901826620102, -0.4231816828250885, -0.04410199075937271, -0.19937290251255035, -0.12112973630428314, 0.04706225171685219, 0.09507517516613007, 0.025950413197278976, 0.1106746643781662, -0.10852514952421188, 0.17442232370376587, 0.06298936903476715, -0.2257928103208542, -0.029096685349941254, -0.054627519100904465, 0.08598914742469788, 0.1935003399848938, -0.27368518710136414, -0.10264517366886139, 0.01258106529712677]}"
"{\"sha\": \"7b48b82bbc8f145d11cbaa19be107cb42074273e\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/cc_array.c\", \"func_name\": \"cc_array_new\", \"original_string\": \"enum cc_stat cc_array_new(CC_Array **out)\\n{\\n    CC_ArrayConf c;\\n    cc_array_conf_init(&c);\\n    return cc_array_new_conf(&c, out);\\n}\", \"code_tokens\": [\"enum\", \"cc_stat\", \"cc_array_new\", \"(\", \"CC_Array\", \"*\", \"*\", \"out\", \")\", \"{\", \"CC_ArrayConf\", \"c\", \";\", \"cc_array_conf_init\", \"(\", \"&\", \"c\", \")\", \";\", \"return\", \"cc_array_new_conf\", \"(\", \"&\", \"c\", \",\", \"out\", \")\", \";\", \"}\"], \"docstring\": \"/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_Array structure failed.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Creates\", \"a\", \"new\", \"empty\", \"array\", \"and\", \"returns\", \"a\", \"status\", \"code\", \".\", \"*\", \"*\", \"@param\", \"[\", \"out\", \"]\", \"out\", \"pointer\", \"to\", \"where\", \"the\", \"newly\", \"created\", \"CC_Array\", \"is\", \"to\", \"be\", \"stored\", \"*\", \"*\", \"@return\", \"CC_OK\", \"if\", \"the\", \"creation\", \"was\", \"successful\", \"or\", \"CC_ERR_ALLOC\", \"if\", \"the\", \"*\", \"memory\", \"allocation\", \"for\", \"the\", \"new\", \"CC_Array\", \"structure\", \"failed\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2014 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n#include \\\"cc_array.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\nstruct cc_array_s {\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    void   **buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_Array *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new(CC_Array **out)\\n{\\n    CC_ArrayConf c;\\n    cc_array_conf_init(&c);\\n    return cc_array_new_conf(&c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_Array based on the specified CC_ArrayConf struct and\\n * returns a status code.\\n *\\n * The CC_Array is allocated using the allocators specified in the CC_ArrayConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArrayConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new_conf(CC_ArrayConf const * const conf, CC_Array **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_Array *ar = conf->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    void **buff = conf->mem_alloc(conf->capacity * sizeof(void*));\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->buffer     = buff;\\n    ar->exp_factor = ex;\\n    ar->capacity   = conf->capacity;\\n    ar->mem_alloc  = conf->mem_alloc;\\n    ar->mem_calloc = conf->mem_calloc;\\n    ar->mem_free   = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArrayConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArrayConf structure that is being initialized\\n */\\nvoid cc_array_conf_init(CC_ArrayConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_Array structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_destroy(CC_Array *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n/**\\n * Destroys the CC_Array structure along with all the data it holds.\\n *\\n * @note\\n * This function should not be called on a array that has some of its elements\\n * allocated on the stack.\\n *\\n * @param[in] ar the array that is being destroyed\\n */\\nvoid cc_array_destroy_cb(CC_Array *ar, void (*cb) (void*))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        cb(ar->buffer[i]);\\n\\n    cc_array_destroy(ar);\\n}\\n\\n/**\\n * Adds a new element to the CC_Array. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_Array.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add(CC_Array *ar, void *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    ar->buffer[ar->size] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add_at(CC_Array *ar, void *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * sizeof(void*);\\n\\n    memmove(&(ar->buffer[index + 1]),\\n            &(ar->buffer[index]),\\n            shift);\\n\\n    ar->buffer[index] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_Array.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_replace_at(CC_Array *ar, void *element, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    ar->buffer[index] = element;\\n\\n    return CC_OK;\\n}\\n\\nenum cc_stat cc_array_swap_at(CC_Array *ar, size_t index1, size_t index2)\\n{\\n    void *tmp;\\n\\n    if (index1 >= ar->size || index2 >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    tmp = ar->buffer[index1];\\n\\n    ar->buffer[index1] = ar->buffer[index2];\\n    ar->buffer[index2] = tmp;\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_Array if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_remove(CC_Array *ar, void *element, void **out)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    if (out)\\n        *out = element;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_remove_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_remove_last(CC_Array *ar, void **out)\\n{\\n    return cc_array_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all(CC_Array *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Removes and frees all elements from the specified array. This function does\\n * not shrink the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all_free(CC_Array *ar)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        free(ar->buffer[i]);\\n\\n    cc_array_remove_all(ar);\\n}\\n\\n/**\\n * Gets an CC_Array element from the specified index and sets the out parameter to\\n * its value. The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] index the index of the array element\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_get_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    *out = ar->buffer[index];\\n    return CC_OK;\\n}\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_get_last(CC_Array *ar, void **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    return cc_array_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst void * const* cc_array_get_buffer(CC_Array *ar)\\n{\\n    return (const void* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_Array.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_index_of(CC_Array *ar, void *element, size_t *index)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element) {\\n            *index = i;\\n            return CC_OK;\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_Array, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_Array, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_subarray(CC_Array *ar, size_t b, size_t e, CC_Array **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_Array *sub_ar = ar->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * sizeof(void*)))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc  = ar->mem_alloc;\\n    sub_ar->mem_calloc = ar->mem_calloc;\\n    sub_ar->mem_free   = ar->mem_free;\\n    sub_ar->size       = e - b + 1;\\n    sub_ar->capacity   = sub_ar->size;\\n\\n    memcpy(sub_ar->buffer,\\n           &(ar->buffer[b]),\\n           sub_ar->size * sizeof(void*));\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a shallow copy of the specified CC_Array. A shallow copy is a copy of\\n * the CC_Array structure, but not the elements it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_shallow(CC_Array *ar, CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * sizeof(void*));\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a deep copy of the specified CC_Array. A deep copy is a copy of\\n * both the CC_Array structure and the data it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar   array to be copied\\n * @param[in] cp   the copy function that should return a pointer to the copy of\\n *                 the data\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_deep(CC_Array *ar, void *(*cp) (void *), CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    size_t i;\\n    for (i = 0; i < copy->size; i++)\\n        copy->buffer[i] = cp(ar->buffer[i]);\\n\\n    *out = copy;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty.\\n */\\nenum cc_stat cc_array_filter_mut(CC_Array *ar, bool (*pred) (const void*))\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(ar->buffer[i])) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * sizeof(void*);\\n                memmove(&(ar->buffer[i + 1]),\\n                        &(ar->buffer[i + 1 + rm]),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * sizeof(void*);\\n        memmove(&(ar->buffer[0]),\\n                &(ar->buffer[rm]),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by creating a new CC_Array that contains all elements from the\\n * original CC_Array that return true on pred(element) without modifying the original\\n * CC_Array.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_filter(CC_Array *ar, bool (*pred) (const void*), CC_Array **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    CC_Array *filtered = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!filtered)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->exp_factor = ar->exp_factor;\\n    filtered->size       = 0;\\n    filtered->capacity   = ar->capacity;\\n    filtered->mem_alloc  = ar->mem_alloc;\\n    filtered->mem_calloc = ar->mem_calloc;\\n    filtered->mem_free   = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(ar->buffer[i])) {\\n            filtered->buffer[f++] = ar->buffer[i];\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_reverse(CC_Array *ar)\\n{\\n    if (ar->size == 0)\\n        return;\\n\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        void *tmp = ar->buffer[i];\\n        ar->buffer[i] = ar->buffer[j];\\n        ar->buffer[j] = tmp;\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_Array, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_trim_capacity(CC_Array *ar)\\n{\\n    if (ar->size == ar->capacity)\\n        return CC_OK;\\n\\n    void **new_buff = ar->mem_calloc(ar->size, sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * sizeof(void*));\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_contains(CC_Array *ar, void *element)\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the number of occurrences of the value pointed to by <code>e</code>\\n * within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n * @param[in] cmp comparator function which returns 0 if the values passed to it are equal\\n *\\n * @return the number of occurrences of the value.\\n */\\nsize_t cc_array_contains_value(CC_Array *ar, void *element, int (*cmp) (const void*, const void*))\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (cmp(element, ar->buffer[i]) == 0)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_Array. The size of the array is the\\n * number of elements contained within the CC_Array.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_Array.\\n */\\nsize_t cc_array_size(CC_Array *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_Array. The capacity of the CC_Array is\\n * the maximum number of elements an CC_Array can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_Array.\\n */\\nsize_t cc_array_capacity(CC_Array *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sort(CC_Array *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, sizeof(void*), cmp);\\n}\\n\\n/**\\n * Expands the CC_Array capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_Array *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS)\\n        return CC_ERR_MAX_CAPACITY;\\n\\n    size_t new_capacity = (size_t)(ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity)\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    else\\n        ar->capacity = new_capacity;\\n\\n    void **new_buff = ar->mem_alloc(ar->capacity * sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    memcpy(new_buff, ar->buffer, ar->size * sizeof(void*));\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_map(CC_Array *ar, void (*fn) (void *e))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        fn(ar->buffer[i]);\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_reduce(CC_Array *ar, void (*fn) (void*, void*, void*), void *result)\\n{\\n    if (ar->size == 1) {\\n        fn(ar->buffer[0], NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1)\\n        fn(ar->buffer[0], ar->buffer[1], result);\\n\\n    for (size_t i = 2; i < ar->size; i++)\\n        fn(result, ar->buffer[i], result);\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_iter_init(CC_ArrayIter *iter, CC_Array *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the value of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_iter_next(CC_ArrayIter *iter, void **out)\\n{\\n    if (iter->index >= iter->ar->size)\\n        return CC_ITER_END;\\n\\n    *out = iter->ar->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_iter_remove(CC_ArrayIter *iter, void **out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK)\\n            iter->last_removed = true;\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_Array after the last returned element by\\n * <code>cc_array_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_iter_add(CC_ArrayIter *iter, void *element)\\n{\\n    return cc_array_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_iter_replace(CC_ArrayIter *iter, void *element, void **out)\\n{\\n    return cc_array_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_iter_index(CC_ArrayIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_zip_iter_init(CC_ArrayZipIter *iter, CC_Array *ar1, CC_Array *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_zip_iter_next(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size)\\n        return CC_ITER_END;\\n\\n    *out1 = iter->ar1->buffer[iter->index];\\n    *out2 = iter->ar2->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_zip_iter_remove(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (!iter->last_removed) {\\n        cc_array_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_zip_iter_add(CC_ArrayZipIter *iter, void *e1, void *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_Array  *ar1  = iter->ar1;\\n    CC_Array  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n            (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK)))\\n        return CC_ERR_ALLOC;\\n\\n    cc_array_add_at(ar1, e1, index);\\n    cc_array_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_zip_iter_replace(CC_ArrayZipIter *iter, void *e1, void *e2, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    cc_array_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_zip_iter_index(CC_ArrayZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_struct_size()\\n{\\n    return sizeof(CC_Array);\\n}\", \"embeddings\": [-0.01992185413837433, 0.02295297384262085, 0.035464175045490265, 0.05329718440771103, 0.27284735441207886, -0.1812036782503128, 0.11213056743144989, 0.2568737864494324, 0.013239786028862, -0.22534969449043274, 0.006496954709291458, 0.049998342990875244, -0.008892824873328209, 0.0382082536816597, -0.020439162850379944, 0.1195557489991188, 0.022703684866428375, -0.01784677803516388, -0.025580551475286484, -0.23753473162651062, -0.1726909875869751, 0.10302847623825073, 0.16599169373512268, 0.17154887318611145, 0.20105959475040436, 0.05694832652807236, 0.1722414791584015, 0.07874460518360138, 0.2786726951599121, -0.1147928386926651, 0.10848880559206009, -0.042341575026512146, 0.09515592455863953, -0.15794721245765686, 0.02822702005505562, -0.010697230696678162, 0.009729355573654175, 0.07572523504495621, -0.006796767003834248, 0.03502770513296127, -0.17861443758010864, -0.01129943784326315, 0.10342186689376831, 0.17769962549209595, 0.08951766043901443, 0.04437636584043503, 0.05365085229277611, 0.1715279072523117, -0.11431343853473663, 0.05698082596063614, 0.08236582577228546, -0.015266239643096924, -0.0009664185345172882, -0.015074256807565689, -0.053776439279317856, 9.622424840927124e-05, -0.007935822010040283, 0.3409634828567505, 0.06892448663711548, 0.024881355464458466, 0.014709707349538803, -0.052736327052116394, -0.13749442994594574, 0.19506721198558807, 0.10609256476163864, 0.11295189708471298, -0.043999288231134415, -0.199465811252594, 0.0012408867478370667, -0.0532892569899559, 0.1732918620109558, 0.05362376570701599, 0.05603324621915817, -0.19595152139663696, -0.10404497385025024, -0.0679171234369278, 0.11498532444238663, 0.5071347951889038, -0.07074581831693649, 0.2014310210943222, 0.17375943064689636, -0.1151231974363327, -0.010995835065841675, 0.17077118158340454, 0.029313620179891586, 0.06509196013212204, -0.1494463086128235, 0.07125933468341827, 0.009204480797052383, 0.1414463222026825, 0.1062619686126709, 0.08316134661436081, -0.06242422014474869, -0.06651012599468231, 0.00657731294631958, -0.004986967891454697, 0.09202703088521957, -0.23017531633377075, 0.06273175776004791, 0.3645208179950714, -0.12295882403850555, -0.07643410563468933, -0.21223706007003784, -0.019325293600559235, -0.01637272536754608, -0.0006976351141929626, 0.013543199747800827, 0.10053571313619614, 0.10058832168579102, -0.08643107861280441, 0.12740030884742737, 0.0021291375160217285, -0.04118452966213226, 0.08189599215984344, 0.04438944160938263, -0.08503692597150803, 0.022669050842523575, 0.023625686764717102, 0.1573057770729065, -0.11365725845098495, 0.14061103761196136, 0.03977477177977562, 0.029141440987586975, -0.05695915222167969, 0.030644718557596207, 0.1027878075838089, 0.05967351049184799, -0.239050030708313, 0.19732290506362915, 0.0835450142621994, 0.019339576363563538, -0.1074238196015358, -0.017765462398529053, 0.08996845781803131, 0.15358757972717285, 0.05812160670757294, 0.11838533729314804, -0.02503105252981186, 0.0007302090525627136, -0.0016522258520126343, -0.03791871666908264, 0.022227652370929718, 0.28225815296173096, -0.02518034353852272, 0.27468737959861755, -0.15674874186515808, 0.220513254404068, 0.15233518183231354, -0.26497459411621094, -0.15037621557712555, 0.06772616505622864, -0.13881155848503113, 0.06578045338392258, -0.03899861127138138, -0.19719983637332916, 0.6734687089920044, 0.18845009803771973, -0.09954195469617844, -0.020666997879743576, -0.026270568370819092, 0.011828172951936722, -0.2543415129184723, -0.03300309181213379, 0.11291251331567764, 0.02741812914609909, 0.13000237941741943, 0.02326013892889023, 0.08259114623069763, 0.05631843954324722, 0.0703427791595459, 0.07640328258275986, -0.049666985869407654, -0.021976541727781296, 0.2142730951309204, -0.002700395882129669, -0.03095051646232605, -0.19766449928283691, 0.051535770297050476, -0.0011964300647377968, 0.04086662456393242, -0.12026140093803406, 0.016227934509515762, -0.13764776289463043, -0.029228657484054565, -0.06651512533426285, 0.04086967930197716, 0.016741223633289337, -0.08328001946210861, 0.09552905708551407, 0.07148981839418411, -0.010320030152797699, 0.057921625673770905, 0.12777648866176605, -0.07966075837612152, -0.1010638102889061, 0.07489034533500671, -0.09035647660493851, -0.037641145288944244, 0.18076232075691223, -0.051783882081508636, -0.07803471386432648, -0.07234247028827667, 0.1574230194091797, -0.08020487427711487, 0.053652286529541016, 0.11548803001642227, -0.1675722897052765, -0.05096875876188278, -0.030917983502149582, -0.06479610502719879, -0.055495623499155045, 0.16946876049041748, 0.12242582440376282, -0.051674243062734604, -0.14805705845355988, -0.09985531866550446, -0.07503727078437805, 0.03460400551557541, 0.026312828063964844, -0.11961794644594193, 0.08714932948350906, 0.19853657484054565, -0.11397384852170944, -0.13598203659057617, -0.08221086114645004, 0.22194990515708923, 0.18452969193458557, 0.05212020501494408, 0.015201631933450699, 0.09038466960191727, 0.1529112458229065, 0.1791122406721115, -0.2806471884250641, 0.15531758964061737, 0.04098077863454819, -0.10768045485019684, -0.03794150799512863, 0.05263911560177803, 0.005213454365730286, -0.13636629283428192, 0.0007379725575447083, 0.11608143150806427, 0.14640164375305176, 0.24920058250427246, 0.012075964361429214, -0.014282502233982086, -0.0906306654214859, 0.06790539622306824, -0.1139199286699295, 0.07755929976701736, -0.08801817893981934, -0.03295237198472023, 0.07229911535978317, -0.10206343233585358, -0.06762990355491638, -0.04883791133761406, -0.022914042696356773, 0.017657563090324402, 0.08720803260803223, 0.1748424768447876, -0.06249431520700455, -0.07102224230766296, 0.033600542694330215, -0.023659810423851013, -0.10737062990665436, -0.29348883032798767, -0.015530772507190704, 0.06181037798523903, 0.008069504052400589, -0.04019015654921532, 0.05111367255449295, -0.07729628682136536, 0.2375381886959076, 0.13885903358459473, 0.08482617884874344, 0.07198403775691986, 0.010639268904924393, 0.03532995283603668, -0.09133148193359375, 0.01946265995502472, 0.0012069866061210632, 0.10612396895885468, -0.14237451553344727, 0.0555228590965271, 0.03927906975150108, -0.07096938043832779, -0.009127195924520493, 0.02754923701286316, 0.01117251068353653, 0.019860439002513885, -0.005904082208871841, 0.04567857086658478, 0.15204651653766632, 0.11086054146289825, 0.028521722182631493, 0.1561783254146576, 0.1902559995651245, -0.02866491675376892, 0.02184894308447838, -0.20604032278060913, 0.10561203211545944, -0.14792057871818542, -0.035744380205869675, -0.12804491817951202, 0.38001951575279236, -0.04691532626748085, 0.033331841230392456, 0.04781986400485039, 0.22045108675956726, 0.04889404773712158, 0.06602495163679123, 0.06093841418623924, -0.13080072402954102, 0.11276675760746002, -0.11974897980690002, 0.10476455837488174, -0.05071541666984558, -0.037112560123205185, 0.044751837849617004, 0.029372118413448334, -0.006192304193973541, 0.14536835253238678, 0.15529407560825348, 0.1094963550567627, -0.07246512174606323, 0.10244482755661011, 0.21659941971302032, -0.04818468540906906, -0.12390878051519394, 0.6570134162902832, -0.4702550768852234, 0.1526341289281845, -0.24357333779335022, 0.28877532482147217, -0.017805583775043488, 0.2731304168701172, -0.055478617548942566, 0.0621151402592659, 0.08136962354183197, 0.10179835557937622, -0.1169089674949646, -0.06239967420697212, -0.04871170222759247, 0.17989137768745422, 0.04670049622654915, 0.18448352813720703, 0.21104799211025238, -0.02595154568552971, 0.18371176719665527, -0.0909542366862297, -0.13844935595989227, 0.09448674321174622, -0.03739606589078903, -0.09646390378475189, 0.04158364236354828, 0.3890751004219055, -0.1184755340218544, -0.07601357996463776, 0.0022051502019166946, -0.028693102300167084, 0.12816117703914642, -0.1286497712135315, 0.1559399664402008, -0.12277009338140488, 0.29298773407936096, -0.44861623644828796, -0.30360040068626404, -0.05300050973892212, -0.05807853862643242, 0.08016498386859894, 0.06833382695913315, 0.18443363904953003, 0.12719915807247162, -0.14815875887870789, 0.056164223700761795, -0.028865348547697067, -0.09117984771728516, 0.021618753671646118, -0.03131486475467682, 0.183514803647995, 0.08900772780179977, 0.10816844552755356, 0.042245835065841675, 0.001189015805721283, 0.04877457022666931, -0.06796283274888992, 0.27231213450431824, 0.15994670987129211, 0.1860537976026535, -0.055185433477163315, 0.12148356437683105, -0.14054886996746063, 0.08651009202003479, 0.0023756027221679688, 0.04898729920387268, -0.010184530168771744, -0.1044447124004364, 0.026570942252874374, -0.13338778913021088, -0.05307406559586525, 0.1462758481502533, 0.18444156646728516, -0.03262561932206154, 0.1586136519908905, 0.10244636982679367, 0.1928761601448059, 0.056831538677215576, -0.09437322616577148, -0.13746941089630127, -0.12280067801475525, 0.04521897807717323, 0.04785802587866783, 0.047187089920043945, -0.00710412859916687, 0.14890913665294647, -0.056669436395168304, 0.05971676856279373, -0.2656642198562622, -0.04224890470504761, 0.17836469411849976, 0.18882088363170624, 0.11663615703582764, -0.016448497772216797, -0.12214186042547226, -0.03246414661407471, -0.0472528412938118, -0.10110311210155487, -0.09669449180364609, 0.10906665027141571, -0.1057654619216919, 0.060873907059431076, 0.23759454488754272, 0.05173999071121216, 0.05574202537536621, -0.0036237910389900208, -0.052516743540763855, -0.09863527119159698, -0.03235241398215294, -0.0010171551257371902, 0.07088330388069153, -0.052582595497369766, 0.057572804391384125, 0.00534038245677948, 0.059309057891368866, -0.03962799534201622, -0.10733499377965927, 0.3306175470352173, 0.11793074011802673, -0.07652069628238678, 0.038812119513750076, -0.144163116812706, 0.044597845524549484, -0.0063873641192913055, -0.4967525601387024, 0.0961281955242157, 0.1671997457742691, 0.07961635291576385, -0.006845753639936447, 0.12382183969020844, 0.03465301916003227, 0.015772320330142975, 0.0881398543715477, -0.05605533346533775, -0.13517780601978302, 0.04986307770013809, -0.12383205443620682, 0.13833245635032654, -0.026352807879447937, 0.1656719446182251, 0.1052388995885849, 0.067976213991642, 0.1576066017150879, 0.05348251760005951, -0.0540585070848465, -0.05386597663164139, -0.02912561595439911, -0.06917926669120789, -0.22342568635940552, 0.0993880182504654, -0.17149439454078674, -0.013116542249917984, 0.08259381353855133, 0.1287042200565338, -0.059614092111587524, -0.06044682860374451, -0.1403721570968628, 0.227159321308136, 0.08723857253789902, -0.14318716526031494, -0.006313506513834, -0.0401611290872097, 0.14786501228809357, 0.06280280649662018, 0.1260892152786255, 0.27125251293182373, 0.14435964822769165, 0.08670786023139954, 0.17943942546844482, 0.266845166683197, -0.05736038088798523, -0.013714216649532318, 0.10540257394313812, 0.04556261748075485, -0.019124459475278854, -0.13810619711875916, -0.1357404589653015, -0.005414776504039764, 0.06786765903234482, 0.07315206527709961, -0.18320634961128235, -0.014314189553260803, -0.05757034569978714, 0.17705078423023224, -0.03586544096469879, 0.03277873247861862, 0.012375973165035248, 0.010689951479434967, 0.03496072441339493, 0.020134173333644867, 0.27322229743003845, -0.134666308760643, -0.14944404363632202, -0.03113694116473198, -0.01159639097750187, -0.04711324721574783, 0.06445765495300293, 0.13355816900730133, -0.054506391286849976, 0.08415154367685318, 0.05665755271911621, -0.03674276918172836, 0.06885775178670883, 0.06464333832263947, 0.1736714392900467, -0.0770464539527893, 0.05972503125667572, 0.07787784934043884, -0.024272248148918152, 0.15794658660888672, -0.18468627333641052, -0.28239336609840393, -0.14068186283111572, 0.1989523470401764, -0.08041329681873322, 0.09662328660488129, -0.0028647594153881073, 0.1670946478843689, 0.08100073039531708, -0.01227230578660965, -0.06266612559556961, -0.12458474934101105, -0.7616981863975525, -0.006319060921669006, 0.14772653579711914, 0.078269362449646, 0.06385356932878494, 0.0939365103840828, 0.12586140632629395, 0.04415419325232506, 0.0833795815706253, 0.04345601052045822, -0.04373355954885483, 0.16058385372161865, 0.1433965265750885, -0.18671894073486328, -0.12118496000766754, 0.11993987113237381, 0.05066368728876114, -0.1713111847639084, 0.16785147786140442, 0.08596578985452652, -0.13688737154006958, 0.0023768022656440735, 0.30256521701812744, 0.00435531884431839, 0.0999993234872818, 0.1809910535812378, 0.055956363677978516, 0.1806192398071289, -0.03352119028568268, 0.06542783230543137, 0.2125672549009323, 0.1540863960981369, -0.24189260601997375, 0.05768076330423355, 0.15247531235218048, 0.15851759910583496, 0.11181966215372086, 13.489706993103027, -0.05791489779949188, 0.21174752712249756, -0.06469481438398361, -0.11155692487955093, -0.018122218549251556, -0.07482784241437912, 0.008085764944553375, -0.05170716345310211, -0.017930053174495697, 0.07063642144203186, -0.027435829862952232, -0.08880666643381119, 0.03400330990552902, -0.046285852789878845, 0.05519980192184448, 0.037050534039735794, -0.06086257845163345, 0.15771068632602692, -0.010815240442752838, -0.09512563049793243, -0.08350867033004761, 0.007636696100234985, -0.36556708812713623, -0.05185345932841301, -0.07985839992761612, 0.12605972588062286, 0.15010225772857666, 0.054421260952949524, 0.10023516416549683, 0.12484137713909149, 0.19462624192237854, 0.04688536748290062, -0.06539575755596161, -0.043064750730991364, -0.1650487780570984, -0.3142203688621521, -0.1033553034067154, 0.08910772949457169, 0.0003451332449913025, -0.029873140156269073, -0.01178334653377533, 0.15255114436149597, -0.008696503937244415, 0.08876185119152069, 0.1268986463546753, -0.2677837908267975, 0.08797263354063034, -0.05941177159547806, -0.07224716246128082, 0.1798379272222519, 0.11576095223426819, 0.3424721360206604, 0.049015119671821594, -0.1693924367427826, -0.1974155604839325, 0.194086953997612, 0.005588289350271225, -0.05589066445827484, 0.38623499870300293, -0.037604764103889465, -0.03696800768375397, -0.02432948350906372, -0.024135518819093704, -0.030848093330860138, 0.0034807324409484863, 0.0677853375673294, 0.08203291893005371, -0.13676407933235168, 0.07895243167877197, 0.16487672924995422, -0.17621088027954102, 0.10679177939891815, 0.014975269325077534, -0.012044686824083328, 0.08839893341064453, 0.08512309193611145, -0.06781122088432312, 0.06732254475355148, -0.14896409213542938, -0.01673218607902527, 0.06253375113010406, -0.1758648306131363, -0.06812290102243423, -0.2441943734884262, 0.09279260039329529, -0.07849323749542236, 0.22298425436019897, 0.23010072112083435, -0.07223359495401382, -0.12762540578842163, 0.0544317290186882, -0.027679942548274994, -0.15617504715919495, 0.24896201491355896, -0.03320693224668503, -0.03941375017166138, -0.12629841268062592, 0.03485063463449478, 0.1438952386379242, -0.06286396831274033, -0.13249604403972626, -0.004398968070745468, 0.0825631320476532, -0.0919359102845192, -0.05187598615884781, 0.007031559012830257, 0.08980987966060638, -0.06099950522184372, 0.029282227158546448, 0.01920497603714466, 0.16748689115047455, 0.14274948835372925, -0.15950962901115417, -0.16088394820690155, -0.006179884076118469, 0.015342272818088531, 0.007737372070550919, 0.17104119062423706, 0.09986583888530731, 0.134774312376976, 0.11086344718933105, -0.14185626804828644, -0.07006171345710754, 0.10625044256448746, -0.15538561344146729, 0.07264746725559235, 0.1191990077495575, 0.09505650401115417, 0.06027241423726082, 0.11635777354240417, -0.08994551748037338, 0.3878920078277588, 0.10840673744678497, 0.03854695335030556, -0.014727599918842316, -0.04840388149023056, 0.10751873254776001, 0.210877925157547, 0.1792890578508377, 0.05044405534863472, 0.03631668910384178, 0.19934484362602234, -0.16120664775371552, 0.013134926557540894, 0.23623493313789368, 0.2542709410190582, -0.025898821651935577, -0.09596140682697296, 0.15575642883777618, 0.10971088707447052, 0.26887238025665283, -0.11631616950035095, -0.15942059457302094, -0.14058136940002441, -0.12595757842063904, -0.1234762966632843, 0.02647562325000763, -0.06190222501754761, 0.02001943066716194, 0.23795178532600403, -0.31736427545547485, 0.018905483186244965, -0.24388961493968964, -0.13172295689582825, 0.07052337378263474, 0.05280681699514389, 0.14942091703414917, 0.03717268630862236, -0.06863448768854141, 0.088765449821949, 0.08724823594093323, -0.1859060525894165, 0.0006766989827156067, -0.11388806998729706, 0.03297453746199608, 0.31049638986587524, -0.4175831377506256, -0.15133026242256165, 0.04133293032646179]}"
"{\"sha\": \"7b48b82bbc8f145d11cbaa19be107cb42074273e\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/cc_array.c\", \"func_name\": \"cc_array_new_conf\", \"original_string\": \"enum cc_stat cc_array_new_conf(CC_ArrayConf const * const conf, CC_Array **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_Array *ar = conf->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    void **buff = conf->mem_alloc(conf->capacity * sizeof(void*));\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->buffer     = buff;\\n    ar->exp_factor = ex;\\n    ar->capacity   = conf->capacity;\\n    ar->mem_alloc  = conf->mem_alloc;\\n    ar->mem_calloc = conf->mem_calloc;\\n    ar->mem_free   = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\", \"code_tokens\": [\"enum\", \"cc_stat\", \"cc_array_new_conf\", \"(\", \"CC_ArrayConf\", \"const\", \"*\", \"const\", \"conf\", \",\", \"CC_Array\", \"*\", \"*\", \"out\", \")\", \"{\", \"float\", \"ex\", \";\", \"if\", \"(\", \"conf\", \"->\", \"exp_factor\", \"<=\", \"1\", \")\", \"ex\", \"=\", \"DEFAULT_EXPANSION_FACTOR\", \";\", \"else\", \"ex\", \"=\", \"conf\", \"->\", \"exp_factor\", \";\", \"if\", \"(\", \"!\", \"conf\", \"->\", \"capacity\", \"||\", \"ex\", \">=\", \"CC_MAX_ELEMENTS\", \"/\", \"conf\", \"->\", \"capacity\", \")\", \"return\", \"CC_ERR_INVALID_CAPACITY\", \";\", \"CC_Array\", \"*\", \"ar\", \"=\", \"conf\", \"->\", \"mem_calloc\", \"(\", \"1\", \",\", \"sizeof\", \"(\", \"CC_Array\", \")\", \")\", \";\", \"if\", \"(\", \"!\", \"ar\", \")\", \"return\", \"CC_ERR_ALLOC\", \";\", \"void\", \"*\", \"*\", \"buff\", \"=\", \"conf\", \"->\", \"mem_alloc\", \"(\", \"conf\", \"->\", \"capacity\", \"*\", \"sizeof\", \"(\", \"void\", \"*\", \")\", \")\", \";\", \"if\", \"(\", \"!\", \"buff\", \")\", \"{\", \"conf\", \"->\", \"mem_free\", \"(\", \"ar\", \")\", \";\", \"return\", \"CC_ERR_ALLOC\", \";\", \"}\", \"ar\", \"->\", \"buffer\", \"=\", \"buff\", \";\", \"ar\", \"->\", \"exp_factor\", \"=\", \"ex\", \";\", \"ar\", \"->\", \"capacity\", \"=\", \"conf\", \"->\", \"capacity\", \";\", \"ar\", \"->\", \"mem_alloc\", \"=\", \"conf\", \"->\", \"mem_alloc\", \";\", \"ar\", \"->\", \"mem_calloc\", \"=\", \"conf\", \"->\", \"mem_calloc\", \";\", \"ar\", \"->\", \"mem_free\", \"=\", \"conf\", \"->\", \"mem_free\", \";\", \"*\", \"out\", \"=\", \"ar\", \";\", \"return\", \"CC_OK\", \";\", \"}\"], \"docstring\": \"/**\\n * Creates a new empty CC_Array based on the specified CC_ArrayConf struct and\\n * returns a status code.\\n *\\n * The CC_Array is allocated using the allocators specified in the CC_ArrayConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArrayConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_Array structure failed.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Creates\", \"a\", \"new\", \"empty\", \"CC_Array\", \"based\", \"on\", \"the\", \"specified\", \"CC_ArrayConf\", \"struct\", \"and\", \"*\", \"returns\", \"a\", \"status\", \"code\", \".\", \"*\", \"*\", \"The\", \"CC_Array\", \"is\", \"allocated\", \"using\", \"the\", \"allocators\", \"specified\", \"in\", \"the\", \"CC_ArrayConf\", \"*\", \"struct\", \".\", \"The\", \"allocation\", \"may\", \"fail\", \"if\", \"underlying\", \"allocator\", \"fails\", \".\", \"It\", \"may\", \"also\", \"*\", \"fail\", \"if\", \"the\", \"values\", \"of\", \"exp_factor\", \"and\", \"capacity\", \"in\", \"the\", \"CC_ArrayConf\", \"do\", \"not\", \"meet\", \"*\", \"the\", \"following\", \"condition\", \":\", \"<code\", \">\", \"exp_factor\", \"<\", \"(\", \"CC_MAX_ELEMENTS\", \"/\", \"capacity\", \")\", \"<\", \"/\", \"code\", \">\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"conf\", \"array\", \"configuration\", \"structure\", \"*\", \"@param\", \"[\", \"out\", \"]\", \"out\", \"pointer\", \"to\", \"where\", \"the\", \"newly\", \"created\", \"CC_Array\", \"is\", \"to\", \"be\", \"stored\", \"*\", \"*\", \"@return\", \"CC_OK\", \"if\", \"the\", \"creation\", \"was\", \"successful\", \"CC_ERR_INVALID_CAPACITY\", \"if\", \"*\", \"the\", \"above\", \"mentioned\", \"condition\", \"is\", \"not\", \"met\", \"or\", \"CC_ERR_ALLOC\", \"if\", \"the\", \"memory\", \"*\", \"allocation\", \"for\", \"the\", \"new\", \"CC_Array\", \"structure\", \"failed\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2014 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n#include \\\"cc_array.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\nstruct cc_array_s {\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    void   **buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_Array *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new(CC_Array **out)\\n{\\n    CC_ArrayConf c;\\n    cc_array_conf_init(&c);\\n    return cc_array_new_conf(&c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_Array based on the specified CC_ArrayConf struct and\\n * returns a status code.\\n *\\n * The CC_Array is allocated using the allocators specified in the CC_ArrayConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArrayConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new_conf(CC_ArrayConf const * const conf, CC_Array **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_Array *ar = conf->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    void **buff = conf->mem_alloc(conf->capacity * sizeof(void*));\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->buffer     = buff;\\n    ar->exp_factor = ex;\\n    ar->capacity   = conf->capacity;\\n    ar->mem_alloc  = conf->mem_alloc;\\n    ar->mem_calloc = conf->mem_calloc;\\n    ar->mem_free   = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArrayConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArrayConf structure that is being initialized\\n */\\nvoid cc_array_conf_init(CC_ArrayConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_Array structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_destroy(CC_Array *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n/**\\n * Destroys the CC_Array structure along with all the data it holds.\\n *\\n * @note\\n * This function should not be called on a array that has some of its elements\\n * allocated on the stack.\\n *\\n * @param[in] ar the array that is being destroyed\\n */\\nvoid cc_array_destroy_cb(CC_Array *ar, void (*cb) (void*))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        cb(ar->buffer[i]);\\n\\n    cc_array_destroy(ar);\\n}\\n\\n/**\\n * Adds a new element to the CC_Array. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_Array.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add(CC_Array *ar, void *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    ar->buffer[ar->size] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add_at(CC_Array *ar, void *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * sizeof(void*);\\n\\n    memmove(&(ar->buffer[index + 1]),\\n            &(ar->buffer[index]),\\n            shift);\\n\\n    ar->buffer[index] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_Array.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_replace_at(CC_Array *ar, void *element, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    ar->buffer[index] = element;\\n\\n    return CC_OK;\\n}\\n\\nenum cc_stat cc_array_swap_at(CC_Array *ar, size_t index1, size_t index2)\\n{\\n    void *tmp;\\n\\n    if (index1 >= ar->size || index2 >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    tmp = ar->buffer[index1];\\n\\n    ar->buffer[index1] = ar->buffer[index2];\\n    ar->buffer[index2] = tmp;\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_Array if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_remove(CC_Array *ar, void *element, void **out)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    if (out)\\n        *out = element;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_remove_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_remove_last(CC_Array *ar, void **out)\\n{\\n    return cc_array_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all(CC_Array *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Removes and frees all elements from the specified array. This function does\\n * not shrink the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all_free(CC_Array *ar)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        free(ar->buffer[i]);\\n\\n    cc_array_remove_all(ar);\\n}\\n\\n/**\\n * Gets an CC_Array element from the specified index and sets the out parameter to\\n * its value. The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] index the index of the array element\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_get_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    *out = ar->buffer[index];\\n    return CC_OK;\\n}\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_get_last(CC_Array *ar, void **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    return cc_array_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst void * const* cc_array_get_buffer(CC_Array *ar)\\n{\\n    return (const void* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_Array.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_index_of(CC_Array *ar, void *element, size_t *index)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element) {\\n            *index = i;\\n            return CC_OK;\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_Array, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_Array, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_subarray(CC_Array *ar, size_t b, size_t e, CC_Array **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_Array *sub_ar = ar->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * sizeof(void*)))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc  = ar->mem_alloc;\\n    sub_ar->mem_calloc = ar->mem_calloc;\\n    sub_ar->mem_free   = ar->mem_free;\\n    sub_ar->size       = e - b + 1;\\n    sub_ar->capacity   = sub_ar->size;\\n\\n    memcpy(sub_ar->buffer,\\n           &(ar->buffer[b]),\\n           sub_ar->size * sizeof(void*));\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a shallow copy of the specified CC_Array. A shallow copy is a copy of\\n * the CC_Array structure, but not the elements it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_shallow(CC_Array *ar, CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * sizeof(void*));\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a deep copy of the specified CC_Array. A deep copy is a copy of\\n * both the CC_Array structure and the data it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar   array to be copied\\n * @param[in] cp   the copy function that should return a pointer to the copy of\\n *                 the data\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_deep(CC_Array *ar, void *(*cp) (void *), CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    size_t i;\\n    for (i = 0; i < copy->size; i++)\\n        copy->buffer[i] = cp(ar->buffer[i]);\\n\\n    *out = copy;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty.\\n */\\nenum cc_stat cc_array_filter_mut(CC_Array *ar, bool (*pred) (const void*))\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(ar->buffer[i])) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * sizeof(void*);\\n                memmove(&(ar->buffer[i + 1]),\\n                        &(ar->buffer[i + 1 + rm]),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * sizeof(void*);\\n        memmove(&(ar->buffer[0]),\\n                &(ar->buffer[rm]),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by creating a new CC_Array that contains all elements from the\\n * original CC_Array that return true on pred(element) without modifying the original\\n * CC_Array.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_filter(CC_Array *ar, bool (*pred) (const void*), CC_Array **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    CC_Array *filtered = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!filtered)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->exp_factor = ar->exp_factor;\\n    filtered->size       = 0;\\n    filtered->capacity   = ar->capacity;\\n    filtered->mem_alloc  = ar->mem_alloc;\\n    filtered->mem_calloc = ar->mem_calloc;\\n    filtered->mem_free   = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(ar->buffer[i])) {\\n            filtered->buffer[f++] = ar->buffer[i];\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_reverse(CC_Array *ar)\\n{\\n    if (ar->size == 0)\\n        return;\\n\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        void *tmp = ar->buffer[i];\\n        ar->buffer[i] = ar->buffer[j];\\n        ar->buffer[j] = tmp;\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_Array, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_trim_capacity(CC_Array *ar)\\n{\\n    if (ar->size == ar->capacity)\\n        return CC_OK;\\n\\n    void **new_buff = ar->mem_calloc(ar->size, sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * sizeof(void*));\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_contains(CC_Array *ar, void *element)\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the number of occurrences of the value pointed to by <code>e</code>\\n * within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n * @param[in] cmp comparator function which returns 0 if the values passed to it are equal\\n *\\n * @return the number of occurrences of the value.\\n */\\nsize_t cc_array_contains_value(CC_Array *ar, void *element, int (*cmp) (const void*, const void*))\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (cmp(element, ar->buffer[i]) == 0)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_Array. The size of the array is the\\n * number of elements contained within the CC_Array.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_Array.\\n */\\nsize_t cc_array_size(CC_Array *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_Array. The capacity of the CC_Array is\\n * the maximum number of elements an CC_Array can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_Array.\\n */\\nsize_t cc_array_capacity(CC_Array *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sort(CC_Array *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, sizeof(void*), cmp);\\n}\\n\\n/**\\n * Expands the CC_Array capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_Array *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS)\\n        return CC_ERR_MAX_CAPACITY;\\n\\n    size_t new_capacity = (size_t)(ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity)\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    else\\n        ar->capacity = new_capacity;\\n\\n    void **new_buff = ar->mem_alloc(ar->capacity * sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    memcpy(new_buff, ar->buffer, ar->size * sizeof(void*));\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_map(CC_Array *ar, void (*fn) (void *e))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        fn(ar->buffer[i]);\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_reduce(CC_Array *ar, void (*fn) (void*, void*, void*), void *result)\\n{\\n    if (ar->size == 1) {\\n        fn(ar->buffer[0], NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1)\\n        fn(ar->buffer[0], ar->buffer[1], result);\\n\\n    for (size_t i = 2; i < ar->size; i++)\\n        fn(result, ar->buffer[i], result);\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_iter_init(CC_ArrayIter *iter, CC_Array *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the value of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_iter_next(CC_ArrayIter *iter, void **out)\\n{\\n    if (iter->index >= iter->ar->size)\\n        return CC_ITER_END;\\n\\n    *out = iter->ar->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_iter_remove(CC_ArrayIter *iter, void **out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK)\\n            iter->last_removed = true;\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_Array after the last returned element by\\n * <code>cc_array_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_iter_add(CC_ArrayIter *iter, void *element)\\n{\\n    return cc_array_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_iter_replace(CC_ArrayIter *iter, void *element, void **out)\\n{\\n    return cc_array_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_iter_index(CC_ArrayIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_zip_iter_init(CC_ArrayZipIter *iter, CC_Array *ar1, CC_Array *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_zip_iter_next(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size)\\n        return CC_ITER_END;\\n\\n    *out1 = iter->ar1->buffer[iter->index];\\n    *out2 = iter->ar2->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_zip_iter_remove(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (!iter->last_removed) {\\n        cc_array_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_zip_iter_add(CC_ArrayZipIter *iter, void *e1, void *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_Array  *ar1  = iter->ar1;\\n    CC_Array  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n            (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK)))\\n        return CC_ERR_ALLOC;\\n\\n    cc_array_add_at(ar1, e1, index);\\n    cc_array_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_zip_iter_replace(CC_ArrayZipIter *iter, void *e1, void *e2, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    cc_array_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_zip_iter_index(CC_ArrayZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_struct_size()\\n{\\n    return sizeof(CC_Array);\\n}\", \"embeddings\": [-0.0003534257411956787, 0.0395626574754715, 0.026271868497133255, 0.08595810830593109, 0.4082755446434021, -0.21152561902999878, 0.06295974552631378, 0.3031788170337677, 0.06970947980880737, -0.29301273822784424, 0.03939776495099068, -0.07029619067907333, -0.008314443752169609, 0.099785715341568, -0.03835628181695938, -0.06138791888952255, 0.08769633620977402, 0.006805330514907837, 0.013381561264395714, -0.45763099193573, -0.17383572459220886, 0.09603027999401093, 0.13814571499824524, 0.159306138753891, 0.23112080991268158, 0.09590620547533035, 0.1821874976158142, 0.105907142162323, 0.4035373628139496, -0.14827251434326172, 0.08159928023815155, -0.04098833352327347, 0.08279339969158173, -0.200924813747406, 0.0222183708101511, -0.09062456339597702, -0.013800308108329773, 0.07285799086093903, -0.04076046496629715, 0.03226185217499733, -0.19850526750087738, 0.042015403509140015, 0.19836001098155975, 0.11891080439090729, 0.09229233115911484, -0.03755134344100952, 0.08775737881660461, 0.18843896687030792, -0.029557842761278152, 0.052754394710063934, 0.09010186046361923, -0.15045519173145294, 0.034530214965343475, -0.04373171925544739, -0.07444284856319427, -0.11299938708543777, -0.022906683385372162, 0.40872907638549805, -0.049177318811416626, 0.04441850632429123, -0.11644509434700012, -0.10910274088382721, -0.13645930588245392, 0.15476948022842407, 0.08282484114170074, 0.06665804982185364, -0.10927146673202515, -0.21951517462730408, -0.048401761800050735, -0.03266660124063492, 0.08288216590881348, 0.10635370761156082, 0.1749359518289566, -0.18412230908870697, -0.15087783336639404, -0.06766192615032196, 0.0032676979899406433, 0.5280855894088745, -0.03002711571753025, 0.1845291703939438, 0.16997501254081726, -0.027855247259140015, 0.14079886674880981, 0.126862034201622, 0.12955497205257416, 0.12700384855270386, -0.14145228266716003, 0.15120086073875427, -0.04498394578695297, 0.1951303631067276, 0.10301455855369568, 0.10549098253250122, -0.0038966983556747437, -0.07057423889636993, 0.008702823892235756, -0.05991527810692787, 0.08099932223558426, -0.17756760120391846, 0.07818170636892319, 0.46465611457824707, -0.10570916533470154, -0.11072459816932678, -0.36636319756507874, -0.08851228654384613, -0.07854520529508591, 0.013294637203216553, -0.030215129256248474, 0.07006057351827621, 0.06943070143461227, -0.0031314492225646973, 0.17874860763549805, 0.05155566334724426, -0.013186873868107796, 0.06502026319503784, -0.031606122851371765, -0.07413094490766525, 0.10128922015428543, -0.0373755618929863, 0.23581025004386902, -0.13149932026863098, 0.16218777000904083, -0.008669160306453705, 0.0014761611819267273, -0.033555835485458374, -0.10508477687835693, 0.0806892067193985, 0.035412099212408066, -0.26842910051345825, 0.2161043882369995, 0.0792209804058075, -0.04720637947320938, -0.18098290264606476, -0.003816939890384674, 0.07128699868917465, 0.10047870874404907, 0.05838726460933685, 0.1108345314860344, -0.07179687172174454, 0.016721993684768677, -0.025415979325771332, -0.03940340876579285, -0.030779309570789337, 0.28695589303970337, -0.04288950935006142, 0.21869608759880066, -0.1427544802427292, 0.26967549324035645, 0.1563573181629181, -0.35608384013175964, -0.20650462806224823, 0.12166215479373932, -0.08629673719406128, 0.06937097012996674, 0.03205390274524689, -0.1730370819568634, 0.7465358376502991, 0.175039142370224, -0.13750919699668884, -0.030119530856609344, -0.08536305278539658, 0.027008559554815292, -0.26457223296165466, -0.07777819037437439, 0.23994597792625427, 0.12547296285629272, 0.12859676778316498, 0.020312953740358353, 0.09424874931573868, 0.17013153433799744, 0.04759925603866577, 0.09480041265487671, -0.15017886459827423, -0.03053516149520874, 0.1577780544757843, 0.04467242956161499, -0.15568703413009644, -0.11304411292076111, 0.1223006621003151, -0.035984646528959274, 0.029796384274959564, -0.1021275520324707, 0.006112072616815567, -0.17732223868370056, 0.06208866462111473, -0.06322377175092697, -0.019373342394828796, 0.04969710484147072, -0.09261558949947357, 0.10798875242471695, 0.006550278514623642, 0.1328129768371582, 0.03054531291127205, 0.12709283828735352, -0.15571720898151398, -0.11040445417165756, 0.11403980851173401, -0.10098309069871902, -0.08915665745735168, 0.20955991744995117, -0.02586827427148819, -0.02760951779782772, -0.2348971664905548, 0.1881614476442337, -0.12872785329818726, -0.06424906849861145, 0.11226195842027664, -0.24310605227947235, -0.07660002261400223, -0.042918022722005844, -0.05917908996343613, 0.00886249914765358, 0.24960824847221375, 0.15082065761089325, 0.02927040308713913, 0.0483846552670002, -0.16645218431949615, 0.043777890503406525, 0.07219960540533066, 0.09972350299358368, -0.11837484687566757, 0.09184329211711884, 0.2377588450908661, -0.07042323052883148, -0.07338061928749084, -0.12778496742248535, 0.21195638179779053, 0.18120048940181732, 0.10191798210144043, 0.01318381354212761, 0.017368406057357788, 0.17868874967098236, 0.229983389377594, -0.2844744026660919, 0.11481724679470062, 0.07691775262355804, -0.07380247116088867, -0.04959803819656372, 0.0749751627445221, 0.059629589319229126, -0.14618360996246338, 0.00992746651172638, 0.16290593147277832, 0.15007062256336212, 0.34107813239097595, -0.03364787623286247, 0.11860895156860352, -0.14125661551952362, -0.07275427877902985, -0.1331319659948349, 0.08058830350637436, -0.06654806435108185, -0.08929737657308578, -0.017938219010829926, -0.1051596850156784, -0.09835249185562134, -0.020050860941410065, -0.09835177659988403, -0.028876233845949173, 0.1240987479686737, 0.3074789047241211, -0.039467401802539825, -0.02155895344913006, 0.07597415149211884, -0.012225016951560974, -0.18413084745407104, -0.46281740069389343, -0.06691133230924606, 0.0791093111038208, -0.031190596520900726, -0.010260429233312607, 0.0826616883277893, -0.0913473442196846, 0.2834421694278717, 0.15161335468292236, 0.05177172273397446, -0.04798218607902527, 0.007344068959355354, -0.0407274104654789, -0.11724245548248291, -0.028806611895561218, -0.0022101067006587982, 0.13442817330360413, -0.19999288022518158, 0.058259524405002594, 0.09491946548223495, 0.04984961450099945, 0.0882241502404213, 0.006451195105910301, 0.020501546561717987, -0.02574004977941513, 0.034823425114154816, 0.08751729875802994, 0.12333142012357712, 0.11123456060886383, 0.052355699241161346, 0.10417494177818298, 0.23571769893169403, -0.036679089069366455, 0.0594615563750267, -0.26322951912879944, 0.10826286673545837, -0.30684399604797363, 0.09865909814834595, -0.08494298905134201, 0.4015071988105774, -0.042973946779966354, 0.05830550938844681, 0.04796477034687996, 0.22357310354709625, -0.005423799157142639, 0.08949190378189087, 0.07132033258676529, -0.1371513307094574, 0.12184520065784454, -0.1203455924987793, 0.08437541127204895, -0.07109177112579346, -0.07642240822315216, 0.044916070997714996, 0.021882854402065277, -0.004604663699865341, 0.15890909731388092, 0.29063236713409424, 0.14158080518245697, 0.01018361747264862, 0.049968600273132324, 0.04742418974637985, 0.020525090396404266, -0.2127332091331482, 0.6073562502861023, -0.5177306532859802, 0.23153892159461975, -0.23344334959983826, 0.3187195658683777, -0.04706324636936188, 0.28216686844825745, -0.014576047658920288, 0.12407377362251282, 0.08413729071617126, 0.12122305482625961, -0.09522181749343872, -0.13457345962524414, -0.11097501218318939, 0.27917420864105225, 0.11817491799592972, 0.1718171238899231, 0.23935465514659882, -0.02088233083486557, 0.1780034750699997, -0.10155423730611801, -0.09995363652706146, 0.2002546638250351, -0.010109584778547287, -0.07424599677324295, 0.03375406935811043, 0.41593536734580994, -0.18364253640174866, -0.0667383223772049, -0.030297957360744476, 0.021371953189373016, 0.13825348019599915, -0.2672364115715027, 0.09028305858373642, -0.14279356598854065, 0.3149348497390747, -0.5011301636695862, -0.42474350333213806, 0.03609120473265648, -0.13191229104995728, 0.0662689357995987, 0.1525372862815857, 0.13708698749542236, 0.1538545936346054, -0.17275863885879517, 0.10813473165035248, -0.019501548260450363, -0.0805695578455925, -0.045935578644275665, -0.1021106094121933, 0.09629340469837189, 0.06659860908985138, 0.11689728498458862, 0.010303355753421783, 0.008550338447093964, 0.047966621816158295, -0.1557902693748474, 0.25717344880104065, 0.18410632014274597, 0.20457109808921814, -0.06190725043416023, 0.11435037851333618, -0.17102693021297455, 0.0810428038239479, -0.07384689152240753, 0.051162540912628174, 0.025495760142803192, -0.08469920605421066, 0.08641266822814941, -0.09343554824590683, -0.13239412009716034, 0.13528935611248016, 0.14183823764324188, 0.02899472415447235, 0.21992160379886627, 0.14946067333221436, 0.1024738997220993, 0.10050175338983536, -0.16212058067321777, -0.12123924493789673, -0.18046769499778748, 0.05953346565365791, 0.07019935548305511, 0.10104726999998093, 0.051820844411849976, 0.16122110188007355, -0.09595102071762085, 0.011544261127710342, -0.2941119074821472, -0.10321465879678726, 0.16653026640415192, 0.25363248586654663, 0.13416141271591187, 0.07694490253925323, -0.19348469376564026, -0.055752985179424286, 0.05689769238233566, -0.08054356276988983, -0.11067810654640198, 0.1249384954571724, -0.18694844841957092, 0.07883578538894653, 0.3058820366859436, 0.10667397826910019, 0.0707523301243782, 0.05004199594259262, -0.055348411202430725, -0.08258001506328583, -0.034233223646879196, 0.014968795701861382, 0.0975683182477951, -0.06795737147331238, 0.04420551285147667, 0.05640611797571182, 0.10606112331151962, 0.0065828366205096245, -0.08352217823266983, 0.40985339879989624, 0.13579457998275757, -0.0645657330751419, 0.15873673558235168, -0.1547204852104187, 0.05596408247947693, 0.012248389422893524, -0.3756789267063141, 0.1554454118013382, 0.17698916792869568, 0.061208609491586685, -0.006484899669885635, 0.07878263294696808, 0.06608869135379791, -0.001236841082572937, 0.09102277457714081, -0.05559397116303444, -0.20074908435344696, 0.02157650887966156, -0.08464797586202621, 0.19044014811515808, -0.014617323875427246, 0.20608462393283844, 0.08510895818471909, 0.135486900806427, 0.15942713618278503, 0.016001079231500626, -0.015325143933296204, -0.0033043399453163147, -0.041460245847702026, -0.09279683232307434, -0.271956205368042, -0.01379397138953209, -0.12439057976007462, 0.0030441489070653915, 0.039164911955595016, 0.14613114297389984, 0.005910500884056091, 0.048451878130435944, -0.18635544180870056, 0.24321401119232178, 0.11670669913291931, -0.16976453363895416, 0.02559172734618187, -0.14123092591762543, 0.1835215985774994, 0.08823457360267639, 0.11315371841192245, 0.2641054391860962, 0.15518304705619812, 0.09719395637512207, 0.14149348437786102, 0.3836957812309265, -0.11415255069732666, -0.01095002144575119, 0.08481139689683914, -0.004069991409778595, -0.08895792067050934, -0.11965993046760559, -0.12262525409460068, 0.011809533461928368, 0.1038423404097557, 0.1123432070016861, -0.17995455861091614, -0.041992805898189545, -0.18724030256271362, 0.13596437871456146, 0.015985582023859024, 0.01726994290947914, 0.07668929547071457, -0.0067710280418396, -0.004485156387090683, -0.06436776369810104, 0.28201791644096375, -0.15774022042751312, -0.21281903982162476, -0.07791770994663239, -0.012096194550395012, -0.09778813272714615, 0.043436117470264435, 0.14970612525939941, -0.032507672905921936, 0.058986712247133255, 0.02454173006117344, 0.03733231872320175, 0.004816632717847824, 0.1015998125076294, 0.23406387865543365, -0.15280365943908691, 0.07558155804872513, 0.08058754354715347, -0.010665399953722954, 0.23405498266220093, -0.16369040310382843, -0.2946566939353943, -0.08693227916955948, 0.14349238574504852, -0.0833660364151001, 0.08517035841941833, 0.0012177899479866028, 0.14149709045886993, 0.08729999512434006, -0.03038761019706726, 0.007021211087703705, -0.04947515204548836, -0.7415224313735962, -0.02637520805001259, 0.20718896389007568, 0.016033999621868134, 0.1100572943687439, 0.1272008866071701, 0.07433100044727325, 0.02829928882420063, 0.1821463704109192, 0.07816191017627716, 0.08230685442686081, 0.16780826449394226, 0.22918978333473206, -0.05977633222937584, -0.18282265961170197, 0.10464735329151154, 0.10370539873838425, -0.2610622048377991, 0.2504231631755829, 0.02348271757364273, -0.18403616547584534, 0.0536133274435997, 0.3207482695579529, 0.023807503283023834, 0.08831939846277237, 0.19494850933551788, 0.06401914358139038, 0.2820450961589813, -0.10082362592220306, 0.09150725603103638, 0.3672778308391571, 0.13802924752235413, -0.3096606731414795, 0.018755238503217697, 0.11950014531612396, 0.1279778778553009, 0.08476895838975906, 13.667998313903809, 0.008048218674957752, 0.27468717098236084, -0.19633543491363525, -0.11609882861375809, 0.005281522870063782, -0.06293373554944992, -0.013308607041835785, -0.03517794609069824, -0.011700272560119629, 0.07773637771606445, -0.12447571754455566, -0.028684644028544426, 0.01757005602121353, -0.07980205118656158, -0.005727849900722504, 0.01714964397251606, -0.07219722867012024, 0.16215915977954865, 0.008413262665271759, -0.15702056884765625, -0.11007831990718842, -0.07533751428127289, -0.4186052680015564, -0.018070096150040627, 0.03330119699239731, 0.14733055233955383, 0.052996084094047546, -0.0026542730629444122, 0.08712033927440643, 0.1771792769432068, 0.15576764941215515, 0.07484064996242523, -0.05124072730541229, 0.06710819154977798, -0.07842513173818588, -0.3957001566886902, -0.13768994808197021, 0.1547374427318573, -0.05086034536361694, -0.0018639862537384033, 0.028235893696546555, 0.16134877502918243, -0.02321086823940277, 0.0786970928311348, 0.1163271963596344, -0.2612300217151642, 0.16295552253723145, -0.12831196188926697, -0.12078779935836792, 0.2363893985748291, 0.18917632102966309, 0.36312031745910645, -0.016924098134040833, -0.19627130031585693, -0.20161427557468414, 0.2832290530204773, -0.04071969538927078, -0.0514945387840271, 0.43798473477363586, 0.03300991281867027, -0.10002035647630692, -0.060449179261922836, 0.07842639088630676, 0.010393751785159111, -0.006411023437976837, 0.061073269695043564, 0.1164831817150116, -0.25487184524536133, 0.10195641219615936, 0.20832258462905884, -0.1980132907629013, 0.2490479052066803, 0.009215706959366798, 0.013086210936307907, 0.0898347795009613, -0.04642162472009659, -0.00822056457400322, 0.006652846932411194, -0.16708382964134216, 0.01407383382320404, 0.06986361742019653, -0.1909428834915161, -0.12131296843290329, -0.28559696674346924, 0.033875804394483566, -0.03920534625649452, 0.2506664991378784, 0.3397692143917084, -0.12154608219861984, -0.07252584397792816, 0.03321016952395439, -0.0009226799011230469, -0.23347264528274536, 0.2601836621761322, 0.0005209296941757202, -0.06725206971168518, -0.16918450593948364, 0.05579909682273865, 0.16584095358848572, -0.03584910184144974, -0.05367374047636986, -0.013702653348445892, 0.004944995045661926, -0.09145764261484146, -0.012129858136177063, -0.056642547249794006, -0.03096555918455124, -0.013464022427797318, 0.05733613669872284, 0.04842790216207504, 0.149617999792099, 0.15813681483268738, -0.2431447058916092, -0.13676302134990692, -0.0021022185683250427, 0.021171938627958298, 0.027979053556919098, 0.1963423788547516, 0.10569801926612854, 0.16847597062587738, 0.08404401689767838, -0.19072769582271576, -0.026022370904684067, 0.07904253900051117, -0.22202913463115692, -0.002730410546064377, 0.11364592611789703, 0.0647096335887909, -0.002839036285877228, 0.024888642132282257, -0.07390817254781723, 0.5159728527069092, 0.0925501361489296, 0.07143223285675049, -0.06722746789455414, 0.015915602445602417, 0.09470000118017197, 0.15321321785449982, 0.266623854637146, 0.06416431814432144, -0.0023016780614852905, 0.20955197513103485, -0.09337734431028366, -0.10228055715560913, 0.3253752887248993, 0.14208164811134338, -0.04647689312696457, -0.19954821467399597, 0.14851099252700806, 0.0986458957195282, 0.2180519700050354, -0.22183161973953247, -0.15813753008842468, -0.15574248135089874, -0.2082093209028244, -0.16268759965896606, 0.07617427408695221, -0.05814088135957718, -0.018164999783039093, 0.09776205569505692, -0.3877401649951935, 0.06221998855471611, -0.39823415875434875, -0.08382651954889297, 0.08821097016334534, 0.06884810328483582, 0.14668843150138855, 0.19334664940834045, -0.08578919619321823, 0.09523774683475494, 0.07788054645061493, -0.08392532169818878, -0.0073513612151145935, -0.07993243634700775, 0.05333712697029114, 0.3855663537979126, -0.49261224269866943, -0.20251066982746124, 0.06447502225637436]}"
"{\"sha\": \"7b48b82bbc8f145d11cbaa19be107cb42074273e\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/cc_array.c\", \"func_name\": \"cc_array_conf_init\", \"original_string\": \"void cc_array_conf_init(CC_ArrayConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\", \"code_tokens\": [\"void\", \"cc_array_conf_init\", \"(\", \"CC_ArrayConf\", \"*\", \"conf\", \")\", \"{\", \"conf\", \"->\", \"exp_factor\", \"=\", \"DEFAULT_EXPANSION_FACTOR\", \";\", \"conf\", \"->\", \"capacity\", \"=\", \"DEFAULT_CAPACITY\", \";\", \"conf\", \"->\", \"mem_alloc\", \"=\", \"malloc\", \";\", \"conf\", \"->\", \"mem_calloc\", \"=\", \"calloc\", \";\", \"conf\", \"->\", \"mem_free\", \"=\", \"free\", \";\", \"}\"], \"docstring\": \"/**\\n * Initializes the fields of the CC_ArrayConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArrayConf structure that is being initialized\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Initializes\", \"the\", \"fields\", \"of\", \"the\", \"CC_ArrayConf\", \"struct\", \"to\", \"default\", \"values\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"out\", \"]\", \"conf\", \"CC_ArrayConf\", \"structure\", \"that\", \"is\", \"being\", \"initialized\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2014 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n#include \\\"cc_array.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\nstruct cc_array_s {\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    void   **buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_Array *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new(CC_Array **out)\\n{\\n    CC_ArrayConf c;\\n    cc_array_conf_init(&c);\\n    return cc_array_new_conf(&c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_Array based on the specified CC_ArrayConf struct and\\n * returns a status code.\\n *\\n * The CC_Array is allocated using the allocators specified in the CC_ArrayConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArrayConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new_conf(CC_ArrayConf const * const conf, CC_Array **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_Array *ar = conf->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    void **buff = conf->mem_alloc(conf->capacity * sizeof(void*));\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->buffer     = buff;\\n    ar->exp_factor = ex;\\n    ar->capacity   = conf->capacity;\\n    ar->mem_alloc  = conf->mem_alloc;\\n    ar->mem_calloc = conf->mem_calloc;\\n    ar->mem_free   = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArrayConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArrayConf structure that is being initialized\\n */\\nvoid cc_array_conf_init(CC_ArrayConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_Array structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_destroy(CC_Array *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n/**\\n * Destroys the CC_Array structure along with all the data it holds.\\n *\\n * @note\\n * This function should not be called on a array that has some of its elements\\n * allocated on the stack.\\n *\\n * @param[in] ar the array that is being destroyed\\n */\\nvoid cc_array_destroy_cb(CC_Array *ar, void (*cb) (void*))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        cb(ar->buffer[i]);\\n\\n    cc_array_destroy(ar);\\n}\\n\\n/**\\n * Adds a new element to the CC_Array. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_Array.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add(CC_Array *ar, void *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    ar->buffer[ar->size] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add_at(CC_Array *ar, void *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * sizeof(void*);\\n\\n    memmove(&(ar->buffer[index + 1]),\\n            &(ar->buffer[index]),\\n            shift);\\n\\n    ar->buffer[index] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_Array.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_replace_at(CC_Array *ar, void *element, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    ar->buffer[index] = element;\\n\\n    return CC_OK;\\n}\\n\\nenum cc_stat cc_array_swap_at(CC_Array *ar, size_t index1, size_t index2)\\n{\\n    void *tmp;\\n\\n    if (index1 >= ar->size || index2 >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    tmp = ar->buffer[index1];\\n\\n    ar->buffer[index1] = ar->buffer[index2];\\n    ar->buffer[index2] = tmp;\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_Array if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_remove(CC_Array *ar, void *element, void **out)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    if (out)\\n        *out = element;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_remove_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_remove_last(CC_Array *ar, void **out)\\n{\\n    return cc_array_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all(CC_Array *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Removes and frees all elements from the specified array. This function does\\n * not shrink the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all_free(CC_Array *ar)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        free(ar->buffer[i]);\\n\\n    cc_array_remove_all(ar);\\n}\\n\\n/**\\n * Gets an CC_Array element from the specified index and sets the out parameter to\\n * its value. The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] index the index of the array element\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_get_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    *out = ar->buffer[index];\\n    return CC_OK;\\n}\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_get_last(CC_Array *ar, void **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    return cc_array_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst void * const* cc_array_get_buffer(CC_Array *ar)\\n{\\n    return (const void* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_Array.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_index_of(CC_Array *ar, void *element, size_t *index)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element) {\\n            *index = i;\\n            return CC_OK;\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_Array, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_Array, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_subarray(CC_Array *ar, size_t b, size_t e, CC_Array **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_Array *sub_ar = ar->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * sizeof(void*)))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc  = ar->mem_alloc;\\n    sub_ar->mem_calloc = ar->mem_calloc;\\n    sub_ar->mem_free   = ar->mem_free;\\n    sub_ar->size       = e - b + 1;\\n    sub_ar->capacity   = sub_ar->size;\\n\\n    memcpy(sub_ar->buffer,\\n           &(ar->buffer[b]),\\n           sub_ar->size * sizeof(void*));\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a shallow copy of the specified CC_Array. A shallow copy is a copy of\\n * the CC_Array structure, but not the elements it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_shallow(CC_Array *ar, CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * sizeof(void*));\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a deep copy of the specified CC_Array. A deep copy is a copy of\\n * both the CC_Array structure and the data it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar   array to be copied\\n * @param[in] cp   the copy function that should return a pointer to the copy of\\n *                 the data\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_deep(CC_Array *ar, void *(*cp) (void *), CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    size_t i;\\n    for (i = 0; i < copy->size; i++)\\n        copy->buffer[i] = cp(ar->buffer[i]);\\n\\n    *out = copy;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty.\\n */\\nenum cc_stat cc_array_filter_mut(CC_Array *ar, bool (*pred) (const void*))\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(ar->buffer[i])) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * sizeof(void*);\\n                memmove(&(ar->buffer[i + 1]),\\n                        &(ar->buffer[i + 1 + rm]),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * sizeof(void*);\\n        memmove(&(ar->buffer[0]),\\n                &(ar->buffer[rm]),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by creating a new CC_Array that contains all elements from the\\n * original CC_Array that return true on pred(element) without modifying the original\\n * CC_Array.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_filter(CC_Array *ar, bool (*pred) (const void*), CC_Array **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    CC_Array *filtered = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!filtered)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->exp_factor = ar->exp_factor;\\n    filtered->size       = 0;\\n    filtered->capacity   = ar->capacity;\\n    filtered->mem_alloc  = ar->mem_alloc;\\n    filtered->mem_calloc = ar->mem_calloc;\\n    filtered->mem_free   = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(ar->buffer[i])) {\\n            filtered->buffer[f++] = ar->buffer[i];\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_reverse(CC_Array *ar)\\n{\\n    if (ar->size == 0)\\n        return;\\n\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        void *tmp = ar->buffer[i];\\n        ar->buffer[i] = ar->buffer[j];\\n        ar->buffer[j] = tmp;\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_Array, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_trim_capacity(CC_Array *ar)\\n{\\n    if (ar->size == ar->capacity)\\n        return CC_OK;\\n\\n    void **new_buff = ar->mem_calloc(ar->size, sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * sizeof(void*));\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_contains(CC_Array *ar, void *element)\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the number of occurrences of the value pointed to by <code>e</code>\\n * within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n * @param[in] cmp comparator function which returns 0 if the values passed to it are equal\\n *\\n * @return the number of occurrences of the value.\\n */\\nsize_t cc_array_contains_value(CC_Array *ar, void *element, int (*cmp) (const void*, const void*))\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (cmp(element, ar->buffer[i]) == 0)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_Array. The size of the array is the\\n * number of elements contained within the CC_Array.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_Array.\\n */\\nsize_t cc_array_size(CC_Array *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_Array. The capacity of the CC_Array is\\n * the maximum number of elements an CC_Array can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_Array.\\n */\\nsize_t cc_array_capacity(CC_Array *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sort(CC_Array *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, sizeof(void*), cmp);\\n}\\n\\n/**\\n * Expands the CC_Array capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_Array *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS)\\n        return CC_ERR_MAX_CAPACITY;\\n\\n    size_t new_capacity = (size_t)(ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity)\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    else\\n        ar->capacity = new_capacity;\\n\\n    void **new_buff = ar->mem_alloc(ar->capacity * sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    memcpy(new_buff, ar->buffer, ar->size * sizeof(void*));\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_map(CC_Array *ar, void (*fn) (void *e))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        fn(ar->buffer[i]);\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_reduce(CC_Array *ar, void (*fn) (void*, void*, void*), void *result)\\n{\\n    if (ar->size == 1) {\\n        fn(ar->buffer[0], NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1)\\n        fn(ar->buffer[0], ar->buffer[1], result);\\n\\n    for (size_t i = 2; i < ar->size; i++)\\n        fn(result, ar->buffer[i], result);\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_iter_init(CC_ArrayIter *iter, CC_Array *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the value of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_iter_next(CC_ArrayIter *iter, void **out)\\n{\\n    if (iter->index >= iter->ar->size)\\n        return CC_ITER_END;\\n\\n    *out = iter->ar->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_iter_remove(CC_ArrayIter *iter, void **out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK)\\n            iter->last_removed = true;\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_Array after the last returned element by\\n * <code>cc_array_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_iter_add(CC_ArrayIter *iter, void *element)\\n{\\n    return cc_array_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_iter_replace(CC_ArrayIter *iter, void *element, void **out)\\n{\\n    return cc_array_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_iter_index(CC_ArrayIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_zip_iter_init(CC_ArrayZipIter *iter, CC_Array *ar1, CC_Array *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_zip_iter_next(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size)\\n        return CC_ITER_END;\\n\\n    *out1 = iter->ar1->buffer[iter->index];\\n    *out2 = iter->ar2->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_zip_iter_remove(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (!iter->last_removed) {\\n        cc_array_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_zip_iter_add(CC_ArrayZipIter *iter, void *e1, void *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_Array  *ar1  = iter->ar1;\\n    CC_Array  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n            (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK)))\\n        return CC_ERR_ALLOC;\\n\\n    cc_array_add_at(ar1, e1, index);\\n    cc_array_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_zip_iter_replace(CC_ArrayZipIter *iter, void *e1, void *e2, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    cc_array_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_zip_iter_index(CC_ArrayZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_struct_size()\\n{\\n    return sizeof(CC_Array);\\n}\", \"embeddings\": [-0.00418650358915329, 0.0779915452003479, 0.06357467174530029, 0.05130298435688019, 0.2469196915626526, -0.2130831778049469, 0.029610522091388702, 0.20129314064979553, 0.11173341423273087, -0.16856813430786133, 0.003685601055622101, -0.02015480399131775, -0.02806026302278042, 0.08618994057178497, 0.03494000807404518, 0.07596682757139206, 0.0156647190451622, 0.060257259756326675, 0.021731488406658173, -0.11899257451295853, -0.16981996595859528, 0.09124748408794403, 0.14567941427230835, 0.1105676144361496, 0.17568892240524292, -0.02171296253800392, 0.1555175483226776, 0.0971265509724617, 0.22104835510253906, -0.08684343099594116, 0.0012262612581253052, 0.016802020370960236, 0.07226617634296417, -0.12319013476371765, 0.006522618234157562, -0.03687914460897446, 0.03720884770154953, 0.06034265458583832, 0.0026920409873127937, 0.014489268884062767, -0.13234581053256989, -0.001203641528263688, 0.18726179003715515, 0.14995177090168, 0.042721040546894073, -0.01627189666032791, 0.08260595053434372, 0.1290322244167328, -0.06464383006095886, -0.03871787711977959, 0.07870826125144958, -0.050349023193120956, -0.024372952058911324, -0.008498210459947586, -0.07620461285114288, -0.01915089413523674, 0.02173130214214325, 0.30950212478637695, -0.012697167694568634, 0.03557765483856201, 0.005300097167491913, 0.040885698050260544, -0.07970656454563141, 0.0735967606306076, 0.10345043987035751, 0.045467063784599304, -0.04002605751156807, -0.13043726980686188, -0.09555420279502869, -0.0010909922420978546, 0.1167166531085968, 0.045814912766218185, 0.11656232178211212, -0.177266925573349, -0.10118061304092407, -0.05447520315647125, 0.10318543016910553, 0.5743849277496338, -0.05355176329612732, 0.13411013782024384, 0.19027742743492126, 0.003755897283554077, 0.03629887104034424, 0.06873876601457596, 0.06858064979314804, 0.0852014422416687, -0.0628294125199318, 0.06154845654964447, 0.05794189125299454, 0.16173824667930603, 0.12103001773357391, 0.04771716147661209, -0.04012994468212128, -0.008687470108270645, 0.06675694137811661, -0.03623441979289055, 0.07024343311786652, -0.3539661467075348, 0.08063065260648727, 0.28837883472442627, -0.033842045813798904, -0.03567041829228401, -0.14864873886108398, -0.017355911433696747, -0.0016063675284385681, 0.008109364658594131, 0.010860800743103027, 0.12481382489204407, 0.04922952502965927, -0.039410218596458435, 0.04797639325261116, 0.054503828287124634, -0.03839974105358124, 0.025694169104099274, 0.06893216818571091, -0.08034218847751617, 0.04191313683986664, -0.0518648698925972, 0.09442644566297531, -0.020367510616779327, 0.14411765336990356, 9.194016456604004e-06, -0.09449776262044907, 0.04214602708816528, 0.10198014229536057, 0.09404236078262329, 0.05279698222875595, -0.0745588093996048, 0.1452808380126953, 0.10712418705224991, -0.01885072886943817, -0.14679735898971558, 0.028132054954767227, 0.14334383606910706, 0.10347256064414978, -0.014201033860445023, 0.004532210528850555, 0.036466799676418304, 0.008993342518806458, 0.027507826685905457, -0.03768860548734665, 0.0189858078956604, 0.31846126914024353, -0.022594477981328964, 0.23310500383377075, -0.08576203882694244, 0.0861198753118515, 0.10566800832748413, -0.2132500261068344, -0.17015545070171356, 0.13481131196022034, -0.03178787976503372, 0.05881587788462639, -0.008261207491159439, -0.15032954514026642, 0.7192255258560181, 0.13178636133670807, -0.0808798298239708, -0.03662271052598953, -0.04501130431890488, 0.03349911794066429, -0.191657155752182, 0.00844293087720871, 0.14376500248908997, 0.09694389998912811, 0.10526997596025467, -0.04717612266540527, 0.10616956651210785, 0.11027433723211288, 0.0015014857053756714, 0.029143817722797394, -0.10355244576931, -0.08819462358951569, 0.13452473282814026, 0.055705633014440536, -0.10867675393819809, -0.17148056626319885, 0.10496373474597931, -0.05812340974807739, 0.060547374188899994, -0.04986152797937393, 0.02968262881040573, -0.1392393410205841, -0.004436329007148743, -0.004432544112205505, 0.027196163311600685, 0.05006437003612518, -0.13378626108169556, 0.11256664246320724, 0.016420666128396988, -0.0078386589884758, 0.07024141401052475, 0.0921621024608612, -0.07236321270465851, -0.07571110874414444, 0.17434708774089813, -0.051043055951595306, -0.04298263043165207, 0.11793894320726395, -0.06039173901081085, -0.014040177688002586, -0.05264753848314285, 0.168670654296875, -0.05310172215104103, 0.06802303344011307, 0.07327719032764435, -0.13753162324428558, 0.011426642537117004, -0.04009804502129555, -0.007799360901117325, 0.024012770503759384, 0.09758153557777405, 0.06640701740980148, -0.05705184116959572, -0.04901948943734169, -0.07473127543926239, -0.017563458532094955, 0.024543166160583496, -0.054457247257232666, -0.11203642934560776, 0.11782610416412354, 0.1665639877319336, -0.059501901268959045, -0.08665551245212555, -0.08483260124921799, 0.2294791340827942, 0.13530264794826508, 0.00900430977344513, 0.03300780430436134, 0.03660375997424126, 0.12529298663139343, 0.0741814598441124, -0.14062517881393433, 0.053500398993492126, 0.03399549052119255, -0.13654999434947968, -0.04667869210243225, 0.061152152717113495, -0.02372228354215622, -0.12143996357917786, -0.06200267747044563, 0.06994935125112534, 0.1176026463508606, 0.2700139284133911, 0.012159869074821472, 0.09375136345624924, -0.13075979053974152, -0.029779456555843353, -0.08263932168483734, 0.04090086370706558, -0.07324770838022232, -0.08015666157007217, 0.07672503590583801, -0.014218218624591827, -0.08007009327411652, -0.06956943869590759, -0.07717859745025635, 0.07943297922611237, 0.06570711731910706, 0.14479678869247437, -0.10232507437467575, -0.06040942668914795, 0.02254985272884369, -0.027374960482120514, -0.03276610001921654, -0.3749336004257202, -0.05760852247476578, 0.0901537835597992, -0.020106248557567596, 0.03198544308543205, 0.054103169590234756, -0.04921738803386688, 0.255186527967453, 0.17425699532032013, 0.02864026464521885, 0.006707698106765747, 0.12758322060108185, 0.08415395766496658, -0.05069015175104141, -0.105562724173069, -0.04101099446415901, 0.04999620467424393, -0.12621808052062988, 0.04927857965230942, 0.0034670070745050907, -0.052606821060180664, -0.017688095569610596, -0.032988712191581726, 0.08306153118610382, 0.10744565725326538, -0.006927888840436935, 0.01833263784646988, 0.08659180253744125, 0.13682763278484344, 0.0002313554286956787, 0.11568628996610641, 0.20844173431396484, -0.040064334869384766, 0.06058799847960472, -0.16626235842704773, 0.05771389603614807, -0.14539837837219238, -0.012879517860710621, -0.1559228003025055, 0.38450148701667786, -0.08697240054607391, 0.11649299412965775, 0.015507370233535767, 0.23532634973526, -0.05445151403546333, 0.04215586930513382, 0.0717669203877449, -0.14726154506206512, 0.20654357969760895, -0.11657494306564331, -0.03678257018327713, -0.04911958426237106, -0.06544022262096405, 0.026193782687187195, 0.034929774701595306, 0.008350402116775513, 0.12387125194072723, 0.1890631765127182, 0.09793582558631897, -0.03774253651499748, 0.15782755613327026, 0.14476065337657928, 0.04824264347553253, -0.11589960008859634, 0.5970724821090698, -0.4577232599258423, 0.1014360636472702, -0.15267647802829742, 0.16670042276382446, 0.09093441069126129, 0.12018582969903946, -0.051701419055461884, 0.05604563653469086, 0.10718375444412231, 0.09454041719436646, -0.021893911063671112, -0.06358824670314789, 0.01874905824661255, 0.15616710484027863, -0.00988469272851944, 0.099341481924057, 0.15277928113937378, -0.025085508823394775, 0.08780103176832199, -0.12250205874443054, -0.09490002691745758, 0.15605959296226501, 0.017809420824050903, -0.13736474514007568, 0.0013030469417572021, 0.26009809970855713, -0.07220227271318436, -0.09078730642795563, 0.025409236550331116, 0.09248936176300049, 0.05896687135100365, -0.09595701843500137, 0.05834396556019783, -0.0546572282910347, 0.2234002649784088, -0.35798823833465576, -0.19035986065864563, 0.028994159772992134, -0.009132830426096916, 0.10976112633943558, 0.03766794130206108, 0.181671142578125, 0.10925215482711792, -0.10733889788389206, 0.0449933260679245, 0.009402584284543991, -0.09871673583984375, 0.04267124831676483, -0.07750093936920166, 0.17278587818145752, 0.0469682477414608, 0.1619611382484436, 0.08070126175880432, 0.003938358277082443, 0.046520523726940155, -0.11484120041131973, 0.16186389327049255, 0.06527106463909149, 0.18779852986335754, -0.03431295230984688, 0.06084498018026352, -0.062450699508190155, 0.07247571647167206, 0.029197975993156433, 0.04440537840127945, 0.03431473299860954, -0.05704987421631813, 0.11736106872558594, -0.10958254337310791, -0.08474516868591309, 0.11192718893289566, 0.0014087632298469543, 0.07817290723323822, 0.08833259344100952, 0.12720519304275513, 0.12334650754928589, 0.003179698484018445, -0.10134537518024445, -0.085182785987854, -0.13910356163978577, 0.018969422206282616, 0.013723090291023254, 0.06517588347196579, 0.006597783416509628, 0.050825029611587524, -0.05001495033502579, -0.07654073089361191, -0.16904981434345245, -0.06253443658351898, 0.15368524193763733, 0.10745745152235031, 0.11905428022146225, -0.0020194798707962036, 0.02045159786939621, -0.07244182378053665, -0.02207314223051071, -0.06261017918586731, -0.1217261552810669, 0.16544127464294434, -0.07875733077526093, 0.06653278321027756, 0.21629029512405396, 0.05630689486861229, 0.06601008772850037, 0.09633518755435944, -0.09926342964172363, -0.07786837220191956, -0.050664421170949936, -0.06496206670999527, 0.09466339647769928, -0.08168900012969971, 0.01938018575310707, -0.013669833540916443, 0.10963129997253418, -3.7632882595062256e-05, -0.10633692890405655, 0.333608478307724, 0.08830825984477997, -0.13925616443157196, 0.1241651102900505, -0.15183018147945404, 0.08303285390138626, -0.03594173118472099, -0.4355233311653137, 0.06452462077140808, 0.1859106421470642, 0.094513900578022, -0.046592503786087036, 0.08585581183433533, 0.014710068702697754, 0.046061430126428604, 0.10866568982601166, 0.0176093727350235, -0.14611934125423431, 0.05673016980290413, -0.06216733902692795, 0.2368326187133789, 0.008032761514186859, 0.061410851776599884, 0.1063782349228859, 0.08120647072792053, 0.13803699612617493, 0.021401003003120422, -0.10354936122894287, -0.0018578022718429565, -0.007838137447834015, -0.054230697453022, -0.15537549555301666, 0.06597545742988586, -0.1659584939479828, -0.04488527402281761, 0.0520893819630146, 0.12502792477607727, -0.024636417627334595, -0.07400928437709808, -0.08800437301397324, 0.1798071265220642, 0.06561011075973511, -0.111879363656044, -0.0018053650856018066, -0.1046142429113388, 0.10221609473228455, 0.049496427178382874, 0.1153271496295929, 0.2743375897407532, 0.15742823481559753, 0.1604924499988556, 0.08392258733510971, 0.24239307641983032, -0.09638193249702454, 0.017431866377592087, 0.07827597856521606, 0.09461014717817307, -0.044135358184576035, -0.04088548198342323, -0.10549259930849075, -0.007150769233703613, 0.11577492207288742, 0.0838390365242958, -0.15585821866989136, 0.0269717238843441, -0.09952927380800247, 0.07102653384208679, 0.015393324196338654, 0.009479686617851257, -0.001026064157485962, 0.044532619416713715, 0.021055568009614944, 0.004959141369909048, 0.14100942015647888, -0.10712337493896484, -0.17671123147010803, -0.005855496972799301, 0.00263131782412529, -0.06013129651546478, 0.06456315517425537, 0.1500457227230072, -0.12182670086622238, 0.007268022745847702, 0.015106363222002983, 0.04090442880988121, 0.01999061182141304, 0.05000954866409302, 0.10631631314754486, -0.07621797919273376, 0.10248938202857971, 0.06048021465539932, -0.09154077619314194, 0.18416307866573334, -0.19473719596862793, -0.16493943333625793, -0.03656422346830368, 0.15887321531772614, -0.014496680349111557, 0.06362699717283249, -0.06882620602846146, 0.1495532989501953, 0.04150494560599327, 0.04344199225306511, -0.00944642722606659, -0.11118568480014801, -0.789738655090332, -0.04657403752207756, 0.1824449598789215, -0.024479221552610397, 0.0844992846250534, 0.029363486915826797, 0.09770454466342926, 0.044981569051742554, 0.12004483491182327, -0.014990728348493576, -0.025611139833927155, 0.17231518030166626, 0.17636018991470337, -0.1548285186290741, -0.0466623418033123, 0.09244062006473541, 0.024585768580436707, -0.13748085498809814, 0.17827081680297852, 0.05659560114145279, -0.12969166040420532, 0.04659821838140488, 0.17314785718917847, 0.06796789914369583, 0.08531667292118073, 0.21158167719841003, -0.030462589114904404, 0.1921095848083496, -0.012863442301750183, 0.009128469973802567, 0.20086663961410522, 0.09567892551422119, -0.20910151302814484, 0.06018931046128273, 0.08264122903347015, 0.1851896494626999, 0.14717265963554382, 13.482792854309082, -0.029798895120620728, 0.17478562891483307, -0.04986395686864853, -0.09348998218774796, -0.0602615624666214, -0.016496896743774414, 0.06898975372314453, -0.05461969971656799, -0.0018868669867515564, 0.12045851349830627, -0.04396919906139374, -0.01832886040210724, 0.0785507783293724, 0.010968044400215149, 0.028846830129623413, 0.08657391369342804, 0.04599030315876007, 0.11108606308698654, 0.03405600041151047, -0.08514286577701569, -0.08799532055854797, 0.04765445739030838, -0.27604928612709045, -0.004432348534464836, -0.01792827993631363, 0.07796445488929749, 0.08760780841112137, 0.07175558805465698, 0.0623156763613224, 0.1350874900817871, 0.1393861174583435, 0.010041642934083939, -0.05672800540924072, -0.050975359976291656, -0.17142131924629211, -0.33684778213500977, -0.08128470182418823, 0.03842778876423836, -0.04242463409900665, 0.033025797456502914, -0.015281692147254944, 0.17095717787742615, 0.03416312113404274, -0.016209382563829422, 0.06877424567937851, -0.182944193482399, 0.11630118638277054, -0.021106429398059845, -0.10841678082942963, 0.15039703249931335, 0.16236084699630737, 0.2684459686279297, -0.03397996723651886, -0.0989256277680397, -0.17167802155017853, 0.2184394747018814, 0.06614161282777786, -0.03284493088722229, 0.22129377722740173, -0.018807128071784973, -0.017949916422367096, -0.027259763330221176, -0.040662314742803574, 0.007413100451231003, 0.08866830915212631, 0.11403680592775345, 0.07907438278198242, 0.038140539079904556, 0.031419236212968826, 0.09849320352077484, -0.09252069145441055, 0.08382238447666168, 0.08396469801664352, -0.06726697832345963, 0.07937030494213104, -0.06513100117444992, -0.0060562677681446075, -0.0019364729523658752, -0.12599584460258484, 0.03009772300720215, 0.019741617143154144, -0.09500321745872498, -0.09039872884750366, -0.012546636164188385, 0.09449426084756851, -0.18487673997879028, 0.1670532524585724, 0.16383373737335205, -0.005571406334638596, -0.07843859493732452, -0.015011094510555267, -0.040343694388866425, -0.04048200696706772, 0.23610803484916687, -0.08138162642717361, 0.006248382851481438, -0.14224202930927277, 0.11125869303941727, 0.11685127764940262, -0.06687627732753754, -0.12306834757328033, -0.030262701213359833, 0.13935989141464233, -0.10208097100257874, -0.02192993462085724, 0.0283264871686697, 0.05451191961765289, -0.051502496004104614, 0.09256531298160553, 0.041303087025880814, 0.15507066249847412, 0.06842975318431854, -0.23895274102687836, -0.03338979184627533, 0.022747404873371124, 0.016347527503967285, -0.00036017224192619324, 0.14694879949092865, -0.02154574915766716, 0.10212107747793198, 0.05102485418319702, -0.12708252668380737, -0.09986171126365662, 0.07683601975440979, -0.10680042952299118, 0.021521111950278282, 0.13809210062026978, 0.07617966830730438, 0.0733647346496582, 0.12080155313014984, -0.06947778910398483, 0.3024684488773346, 0.18830524384975433, -0.004652246832847595, 0.03537643700838089, -0.0564279779791832, 0.09605631977319717, 0.13012798130512238, 0.15197810530662537, 0.07274563610553741, 0.0274309441447258, 0.18493814766407013, -0.11470179259777069, -0.0934569388628006, 0.2341763973236084, 0.17224588990211487, -0.033395037055015564, 0.016087152063846588, 0.1479194611310959, 0.12050716578960419, 0.09508584439754486, -0.03416358679533005, -0.15255947411060333, -0.12513306736946106, -0.17792145907878876, -0.05777638033032417, 0.08251875638961792, -0.014820195734500885, -0.08360324800014496, 0.2053144872188568, -0.38309305906295776, 0.006708488799631596, -0.29022708535194397, -0.17994894087314606, 0.07055085152387619, 0.0099171819165349, 0.0733632817864418, 0.16164056956768036, -0.0754714235663414, 0.07496004551649094, 0.0491684265434742, -0.0972532406449318, 0.01142917014658451, -0.023481175303459167, 0.0311557836830616, 0.25356391072273254, -0.38783323764801025, -0.17644017934799194, 0.0339883454144001]}"
"{\"sha\": \"7b48b82bbc8f145d11cbaa19be107cb42074273e\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/cc_array.c\", \"func_name\": \"cc_array_destroy\", \"original_string\": \"void cc_array_destroy(CC_Array *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\", \"code_tokens\": [\"void\", \"cc_array_destroy\", \"(\", \"CC_Array\", \"*\", \"ar\", \")\", \"{\", \"ar\", \"->\", \"mem_free\", \"(\", \"ar\", \"->\", \"buffer\", \")\", \";\", \"ar\", \"->\", \"mem_free\", \"(\", \"ar\", \")\", \";\", \"}\"], \"docstring\": \"/**\\n * Destroys the CC_Array structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Destroys\", \"the\", \"CC_Array\", \"structure\", \"but\", \"leaves\", \"the\", \"data\", \"it\", \"used\", \"to\", \"hold\", \"intact\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"ar\", \"the\", \"array\", \"that\", \"is\", \"to\", \"be\", \"destroyed\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2014 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n#include \\\"cc_array.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\nstruct cc_array_s {\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    void   **buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_Array *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new(CC_Array **out)\\n{\\n    CC_ArrayConf c;\\n    cc_array_conf_init(&c);\\n    return cc_array_new_conf(&c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_Array based on the specified CC_ArrayConf struct and\\n * returns a status code.\\n *\\n * The CC_Array is allocated using the allocators specified in the CC_ArrayConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArrayConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new_conf(CC_ArrayConf const * const conf, CC_Array **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_Array *ar = conf->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    void **buff = conf->mem_alloc(conf->capacity * sizeof(void*));\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->buffer     = buff;\\n    ar->exp_factor = ex;\\n    ar->capacity   = conf->capacity;\\n    ar->mem_alloc  = conf->mem_alloc;\\n    ar->mem_calloc = conf->mem_calloc;\\n    ar->mem_free   = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArrayConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArrayConf structure that is being initialized\\n */\\nvoid cc_array_conf_init(CC_ArrayConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_Array structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_destroy(CC_Array *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n/**\\n * Destroys the CC_Array structure along with all the data it holds.\\n *\\n * @note\\n * This function should not be called on a array that has some of its elements\\n * allocated on the stack.\\n *\\n * @param[in] ar the array that is being destroyed\\n */\\nvoid cc_array_destroy_cb(CC_Array *ar, void (*cb) (void*))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        cb(ar->buffer[i]);\\n\\n    cc_array_destroy(ar);\\n}\\n\\n/**\\n * Adds a new element to the CC_Array. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_Array.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add(CC_Array *ar, void *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    ar->buffer[ar->size] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add_at(CC_Array *ar, void *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * sizeof(void*);\\n\\n    memmove(&(ar->buffer[index + 1]),\\n            &(ar->buffer[index]),\\n            shift);\\n\\n    ar->buffer[index] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_Array.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_replace_at(CC_Array *ar, void *element, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    ar->buffer[index] = element;\\n\\n    return CC_OK;\\n}\\n\\nenum cc_stat cc_array_swap_at(CC_Array *ar, size_t index1, size_t index2)\\n{\\n    void *tmp;\\n\\n    if (index1 >= ar->size || index2 >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    tmp = ar->buffer[index1];\\n\\n    ar->buffer[index1] = ar->buffer[index2];\\n    ar->buffer[index2] = tmp;\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_Array if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_remove(CC_Array *ar, void *element, void **out)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    if (out)\\n        *out = element;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_remove_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_remove_last(CC_Array *ar, void **out)\\n{\\n    return cc_array_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all(CC_Array *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Removes and frees all elements from the specified array. This function does\\n * not shrink the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all_free(CC_Array *ar)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        free(ar->buffer[i]);\\n\\n    cc_array_remove_all(ar);\\n}\\n\\n/**\\n * Gets an CC_Array element from the specified index and sets the out parameter to\\n * its value. The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] index the index of the array element\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_get_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    *out = ar->buffer[index];\\n    return CC_OK;\\n}\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_get_last(CC_Array *ar, void **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    return cc_array_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst void * const* cc_array_get_buffer(CC_Array *ar)\\n{\\n    return (const void* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_Array.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_index_of(CC_Array *ar, void *element, size_t *index)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element) {\\n            *index = i;\\n            return CC_OK;\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_Array, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_Array, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_subarray(CC_Array *ar, size_t b, size_t e, CC_Array **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_Array *sub_ar = ar->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * sizeof(void*)))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc  = ar->mem_alloc;\\n    sub_ar->mem_calloc = ar->mem_calloc;\\n    sub_ar->mem_free   = ar->mem_free;\\n    sub_ar->size       = e - b + 1;\\n    sub_ar->capacity   = sub_ar->size;\\n\\n    memcpy(sub_ar->buffer,\\n           &(ar->buffer[b]),\\n           sub_ar->size * sizeof(void*));\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a shallow copy of the specified CC_Array. A shallow copy is a copy of\\n * the CC_Array structure, but not the elements it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_shallow(CC_Array *ar, CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * sizeof(void*));\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a deep copy of the specified CC_Array. A deep copy is a copy of\\n * both the CC_Array structure and the data it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar   array to be copied\\n * @param[in] cp   the copy function that should return a pointer to the copy of\\n *                 the data\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_deep(CC_Array *ar, void *(*cp) (void *), CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    size_t i;\\n    for (i = 0; i < copy->size; i++)\\n        copy->buffer[i] = cp(ar->buffer[i]);\\n\\n    *out = copy;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty.\\n */\\nenum cc_stat cc_array_filter_mut(CC_Array *ar, bool (*pred) (const void*))\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(ar->buffer[i])) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * sizeof(void*);\\n                memmove(&(ar->buffer[i + 1]),\\n                        &(ar->buffer[i + 1 + rm]),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * sizeof(void*);\\n        memmove(&(ar->buffer[0]),\\n                &(ar->buffer[rm]),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by creating a new CC_Array that contains all elements from the\\n * original CC_Array that return true on pred(element) without modifying the original\\n * CC_Array.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_filter(CC_Array *ar, bool (*pred) (const void*), CC_Array **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    CC_Array *filtered = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!filtered)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->exp_factor = ar->exp_factor;\\n    filtered->size       = 0;\\n    filtered->capacity   = ar->capacity;\\n    filtered->mem_alloc  = ar->mem_alloc;\\n    filtered->mem_calloc = ar->mem_calloc;\\n    filtered->mem_free   = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(ar->buffer[i])) {\\n            filtered->buffer[f++] = ar->buffer[i];\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_reverse(CC_Array *ar)\\n{\\n    if (ar->size == 0)\\n        return;\\n\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        void *tmp = ar->buffer[i];\\n        ar->buffer[i] = ar->buffer[j];\\n        ar->buffer[j] = tmp;\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_Array, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_trim_capacity(CC_Array *ar)\\n{\\n    if (ar->size == ar->capacity)\\n        return CC_OK;\\n\\n    void **new_buff = ar->mem_calloc(ar->size, sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * sizeof(void*));\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_contains(CC_Array *ar, void *element)\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the number of occurrences of the value pointed to by <code>e</code>\\n * within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n * @param[in] cmp comparator function which returns 0 if the values passed to it are equal\\n *\\n * @return the number of occurrences of the value.\\n */\\nsize_t cc_array_contains_value(CC_Array *ar, void *element, int (*cmp) (const void*, const void*))\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (cmp(element, ar->buffer[i]) == 0)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_Array. The size of the array is the\\n * number of elements contained within the CC_Array.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_Array.\\n */\\nsize_t cc_array_size(CC_Array *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_Array. The capacity of the CC_Array is\\n * the maximum number of elements an CC_Array can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_Array.\\n */\\nsize_t cc_array_capacity(CC_Array *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sort(CC_Array *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, sizeof(void*), cmp);\\n}\\n\\n/**\\n * Expands the CC_Array capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_Array *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS)\\n        return CC_ERR_MAX_CAPACITY;\\n\\n    size_t new_capacity = (size_t)(ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity)\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    else\\n        ar->capacity = new_capacity;\\n\\n    void **new_buff = ar->mem_alloc(ar->capacity * sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    memcpy(new_buff, ar->buffer, ar->size * sizeof(void*));\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_map(CC_Array *ar, void (*fn) (void *e))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        fn(ar->buffer[i]);\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_reduce(CC_Array *ar, void (*fn) (void*, void*, void*), void *result)\\n{\\n    if (ar->size == 1) {\\n        fn(ar->buffer[0], NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1)\\n        fn(ar->buffer[0], ar->buffer[1], result);\\n\\n    for (size_t i = 2; i < ar->size; i++)\\n        fn(result, ar->buffer[i], result);\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_iter_init(CC_ArrayIter *iter, CC_Array *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the value of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_iter_next(CC_ArrayIter *iter, void **out)\\n{\\n    if (iter->index >= iter->ar->size)\\n        return CC_ITER_END;\\n\\n    *out = iter->ar->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_iter_remove(CC_ArrayIter *iter, void **out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK)\\n            iter->last_removed = true;\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_Array after the last returned element by\\n * <code>cc_array_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_iter_add(CC_ArrayIter *iter, void *element)\\n{\\n    return cc_array_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_iter_replace(CC_ArrayIter *iter, void *element, void **out)\\n{\\n    return cc_array_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_iter_index(CC_ArrayIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_zip_iter_init(CC_ArrayZipIter *iter, CC_Array *ar1, CC_Array *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_zip_iter_next(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size)\\n        return CC_ITER_END;\\n\\n    *out1 = iter->ar1->buffer[iter->index];\\n    *out2 = iter->ar2->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_zip_iter_remove(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (!iter->last_removed) {\\n        cc_array_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_zip_iter_add(CC_ArrayZipIter *iter, void *e1, void *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_Array  *ar1  = iter->ar1;\\n    CC_Array  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n            (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK)))\\n        return CC_ERR_ALLOC;\\n\\n    cc_array_add_at(ar1, e1, index);\\n    cc_array_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_zip_iter_replace(CC_ArrayZipIter *iter, void *e1, void *e2, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    cc_array_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_zip_iter_index(CC_ArrayZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_struct_size()\\n{\\n    return sizeof(CC_Array);\\n}\", \"embeddings\": [-0.01861739158630371, 0.04863547906279564, -0.003540974110364914, 0.07124368846416473, 0.18255434930324554, -0.16720905900001526, 0.04011134058237076, 0.34508761763572693, 0.011789310723543167, -0.20509645342826843, -0.013339918106794357, -0.04786588251590729, 0.002766944468021393, 0.08275741338729858, 0.002253882586956024, 0.14451339840888977, 0.03437308222055435, -0.014125227928161621, 0.03255757689476013, -0.20220813155174255, -0.15484575927257538, 0.05146185681223869, 0.20971199870109558, 0.10011078417301178, 0.18981832265853882, 0.021954845637083054, 0.22876803576946259, 0.1325453221797943, 0.26838991045951843, -0.1419682800769806, 0.039423637092113495, -0.031032510101795197, 0.07151488959789276, -0.153162881731987, -0.02038024738430977, -0.008416548371315002, 0.022962123155593872, 0.05399389564990997, -0.01722690463066101, 0.03928295895457268, -0.18188278377056122, -0.022499898448586464, 0.1515215039253235, 0.19959646463394165, 0.050372716039419174, 0.011245135217905045, -0.028187476098537445, 0.12565827369689941, -0.07976201176643372, 0.05960249528288841, 0.05817697197198868, 0.04270666465163231, -0.08723597228527069, 0.017352551221847534, -0.0947953313589096, 0.04774266853928566, -0.004895536229014397, 0.3448857069015503, 0.06906505674123764, -0.0053106024861335754, -0.041697047650814056, 0.04223895072937012, -0.17456385493278503, 0.14847725629806519, 0.13924920558929443, 0.07463785260915756, 0.006940437480807304, -0.14773960411548615, 0.001101866364479065, -0.014463018625974655, 0.13490037620067596, 0.06272789090871811, 0.09340709447860718, -0.1990519016981125, -0.06851623207330704, 0.00021206587553024292, 0.10433917492628098, 0.5468915700912476, -0.0720490887761116, 0.1471213698387146, 0.20811881124973297, -0.08347873389720917, -0.014661986380815506, 0.11130297183990479, 0.02056884765625, 0.011904610320925713, -0.08807843178510666, 0.07805220782756805, 0.048087961971759796, 0.1603904366493225, 0.08750791847705841, 0.10457096248865128, -0.08641227334737778, -0.003036804497241974, 0.056532375514507294, -0.013665486127138138, 0.03935641050338745, -0.3205694556236267, 0.07299531251192093, 0.29539671540260315, -0.0337858609855175, -0.07054433226585388, -0.20170363783836365, -0.06773211061954498, 0.023435961455106735, 0.05382346734404564, 0.10330995172262192, 0.07299910485744476, 0.028368500992655754, -0.05389375239610672, 0.06507965922355652, 0.04409409314393997, 0.010236995294690132, 0.062327317893505096, 0.06952463090419769, -0.09081648290157318, 0.04121816158294678, -0.024121321737766266, 0.16093873977661133, -0.04472861438989639, 0.11010027676820755, 0.048154618591070175, -0.018817268311977386, -0.009358152747154236, 0.03259872645139694, 0.07124580442905426, -0.004944406449794769, -0.15995284914970398, 0.166558176279068, 0.09767656028270721, 0.01178768277168274, -0.13842599093914032, -0.008968152105808258, 0.14131483435630798, 0.13736732304096222, -0.04181012883782387, 0.0687386766076088, 0.038347020745277405, -0.005081057548522949, -0.01591303199529648, -0.0381767675280571, 0.0754353404045105, 0.2920318841934204, -0.046152446419000626, 0.2633626461029053, -0.11381924152374268, 0.13527213037014008, 0.09730677306652069, -0.3131401538848877, -0.1101064682006836, 0.07591619342565536, -0.0835186243057251, 0.03457667678594589, 0.029772303998470306, -0.12421394884586334, 0.7780081033706665, 0.12998640537261963, -0.07685856521129608, -0.08926284313201904, -0.041427887976169586, 0.047204770147800446, -0.24119284749031067, -0.026701033115386963, 0.08783937990665436, 0.05112330988049507, 0.1333165317773819, 0.008246742188930511, 0.10796801745891571, 0.13782908022403717, 0.013166286051273346, 0.02645740658044815, -0.09369523823261261, -0.09642133861780167, 0.1875004917383194, 0.041394054889678955, -0.05277744680643082, -0.14674727618694305, 0.09903362393379211, -0.04880591109395027, 0.03642286732792854, -0.09694069623947144, 0.01753220707178116, -0.17870768904685974, -0.03620915114879608, 0.009245909750461578, 0.07445752620697021, 0.03179161250591278, -0.1455407291650772, 0.1338711977005005, 0.032719530165195465, -0.08305460214614868, 0.0434749573469162, 0.17498624324798584, -0.03874945640563965, -0.0689159408211708, 0.08646128326654434, -0.12419972568750381, -0.06171247363090515, 0.1893370896577835, -0.057083576917648315, -0.031605787575244904, -0.11726871132850647, 0.1441042423248291, -0.021519679576158524, 0.10467933118343353, 0.09768818318843842, -0.13859513401985168, 0.010695800185203552, -0.057851728051900864, -0.08866561204195023, -0.02324112132191658, 0.11800684034824371, 0.07836472988128662, -0.054721783846616745, -0.14362166821956635, -0.05484047159552574, -0.027582231909036636, 0.08534552156925201, 0.04220842942595482, -0.1018746867775917, 0.06867799162864685, 0.16851304471492767, -0.1051185205578804, -0.1463455706834793, -0.0845818743109703, 0.1958070695400238, 0.2044430524110794, 0.029298949986696243, 0.045608095824718475, 0.05384809523820877, 0.14439965784549713, 0.17413291335105896, -0.20934946835041046, 0.1603332757949829, 0.045576609671115875, -0.1446399688720703, -0.06212225556373596, 0.022889211773872375, -0.03955301642417908, -0.11698205769062042, -0.10706771910190582, 0.15219637751579285, 0.13079530000686646, 0.2696126401424408, 0.03399693965911865, -0.019486263394355774, -0.12443298101425171, 0.04674513265490532, -0.1249271035194397, 0.04813021421432495, -0.09923304617404938, -0.07937131822109222, 0.12067829817533493, -0.08953417837619781, -0.010411396622657776, -0.052060317248106, -0.07434753328561783, 0.08476400375366211, 0.06576059013605118, 0.1661360263824463, -0.05621565133333206, -0.1262539029121399, 0.06436264514923096, -0.05296739935874939, -0.057945042848587036, -0.33480560779571533, -0.021205104887485504, 0.09957923740148544, 0.030523531138896942, -0.04998176544904709, 0.03471103310585022, -0.058780863881111145, 0.21319669485092163, 0.1436166912317276, 0.10467040538787842, 0.05071597173810005, 0.03589683026075363, 0.08103550225496292, -0.08072131872177124, -0.06919250637292862, -0.03205213323235512, 0.06920478492975235, -0.06732718646526337, 0.03877811133861542, -0.02904423326253891, 0.010435773059725761, -0.02765071392059326, -0.008710367605090141, 0.05770692229270935, 0.09767946600914001, -0.007979430258274078, 0.02527901902794838, 0.13030904531478882, 0.12803007662296295, 0.014399677515029907, 0.11003603786230087, 0.18915076553821564, -0.07620072364807129, 0.034061774611473083, -0.2521657645702362, 0.1424354612827301, -0.1376427710056305, -0.022076860070228577, -0.13100026547908783, 0.40171852707862854, -0.08959773182868958, 0.09109143912792206, 0.01782391592860222, 0.27645236253738403, 0.05407211557030678, 0.06200359761714935, 0.050254058092832565, -0.13811500370502472, 0.13379977643489838, -0.11803947389125824, 0.06047338247299194, -0.09852569550275803, -0.09072849154472351, 0.10719814896583557, -0.019985035061836243, -0.05513106659054756, 0.11030074954032898, 0.14083331823349, 0.09318049252033234, -0.016427744179964066, 0.15428581833839417, 0.1968311220407486, -0.05415330082178116, -0.11858267337083817, 0.6448151469230652, -0.5526979565620422, 0.111129991710186, -0.20358437299728394, 0.215980663895607, 0.01608704775571823, 0.2104220688343048, -0.06674877554178238, 0.06016208231449127, 0.09443504363298416, 0.0774260014295578, -0.12336818873882294, -0.03643514961004257, -0.07009711861610413, 0.21882110834121704, 0.0420563630759716, 0.1292940378189087, 0.18777289986610413, -0.03983679041266441, 0.15256653726100922, -0.06133987754583359, -0.1306612342596054, 0.0743594542145729, 0.0329958014190197, -0.11693034321069717, 0.036767229437828064, 0.34746164083480835, -0.0612238273024559, -0.09870986640453339, 0.027687974274158478, 0.03507941961288452, 0.13111141324043274, -0.10680364817380905, 0.12088567763566971, -0.12138379365205765, 0.21613052487373352, -0.3691398799419403, -0.2533937394618988, -0.0272444486618042, -0.05965220555663109, 0.10724227130413055, 0.059020381420850754, 0.1931905597448349, 0.12600384652614594, -0.11629991978406906, -0.01764773204922676, -0.060130272060632706, -0.197218120098114, -0.011952929198741913, -0.052467942237854004, 0.12758657336235046, 0.07726362347602844, 0.09355804324150085, 0.03562840074300766, 0.00650588795542717, 0.07314565777778625, -0.08645083755254745, 0.23774121701717377, 0.13232392072677612, 0.21389588713645935, -0.0546439029276371, 0.12559279799461365, -0.0797971859574318, 0.0728527382016182, 0.012023933231830597, 0.023311756551265717, -0.01341155543923378, -0.050549838691949844, 0.1253390610218048, -0.05846834555268288, -0.06644490361213684, 0.08450701832771301, 0.13596674799919128, -0.028752248734235764, 0.1284087747335434, 0.1542770117521286, 0.1253904402256012, -0.006915806792676449, -0.050141796469688416, -0.18467378616333008, -0.16017208993434906, 0.08911756426095963, 0.033054471015930176, 0.04601684957742691, 0.03736286982893944, 0.08844154328107834, -0.10819360613822937, 0.0683651864528656, -0.18281152844429016, -0.05357103794813156, 0.2018871307373047, 0.16249442100524902, 0.12148328125476837, -0.050999291241168976, -0.08037365227937698, -0.06205335259437561, -0.010863716714084148, -0.09331099689006805, -0.11101245880126953, 0.14507251977920532, -0.07906445860862732, 0.05573116987943649, 0.2287062108516693, 0.004166998900473118, 0.0949937105178833, 0.09449481219053268, -0.09000052511692047, -0.10694673657417297, -0.03206929191946983, -0.06315412372350693, 0.09313934296369553, -0.01934908702969551, 0.059693675488233566, -0.01414661854505539, 0.10500214993953705, -0.031246744096279144, -0.12179910391569138, 0.30401021242141724, 0.13110019266605377, -0.13489723205566406, 0.033045779913663864, -0.20572695136070251, 0.08125761151313782, -0.038864146918058395, -0.5048184990882874, 0.13675403594970703, 0.20390769839286804, 0.08869950473308563, 0.02483539655804634, 0.09319113194942474, 0.03512921929359436, 0.014660954475402832, 0.07731400430202484, 0.027476180344820023, -0.09045295417308807, 0.02564626932144165, -0.057058073580265045, 0.2197929322719574, 0.03749619424343109, 0.11958673596382141, 0.10418163239955902, 0.062757208943367, 0.1871901899576187, 0.012092255987226963, -0.062113940715789795, 0.020241882652044296, 0.0314808115363121, -0.038895219564437866, -0.18117092549800873, 0.07791439443826675, -0.1120108887553215, -0.06789606809616089, 0.06990138441324234, 0.16464915871620178, -0.06076612323522568, -0.0569542795419693, -0.07459566742181778, 0.21076825261116028, 0.061295367777347565, -0.17677047848701477, 0.04216534271836281, -0.09951652586460114, 0.07907203584909439, 0.05001986399292946, 0.10907374322414398, 0.27065491676330566, 0.1372915804386139, 0.11173170804977417, 0.08646535128355026, 0.22713235020637512, -0.05478759855031967, 0.08279399573802948, 0.09313595294952393, 0.06599997729063034, -0.04767371341586113, -0.09247469902038574, -0.11971262842416763, 0.00491010956466198, 0.11017422378063202, 0.08547660708427429, -0.15738603472709656, -0.03868918865919113, -0.08385636657476425, 0.08691312372684479, -0.028924979269504547, 0.05630528926849365, 0.012776173651218414, 0.007014364004135132, 0.028282929211854935, -0.005378796719014645, 0.18669064342975616, -0.1400081068277359, -0.16284503042697906, 0.001028452068567276, 0.028452642261981964, -0.06076991558074951, 0.0677257776260376, 0.11793708801269531, -0.050132595002651215, 0.064720518887043, 0.040310125797986984, 0.06364326924085617, 0.07474229484796524, 0.04794227331876755, 0.1229887306690216, -0.11949710547924042, 0.05472378805279732, 0.12996600568294525, -0.050033748149871826, 0.17423322796821594, -0.16085471212863922, -0.20589788258075714, -0.1260281801223755, 0.18709301948547363, -0.0067834071815013885, 0.1767774224281311, 0.0002070218324661255, 0.20148083567619324, 0.039335742592811584, 0.007900619879364967, 0.020322661846876144, -0.12172460556030273, -0.8123228549957275, 0.010760828852653503, 0.12186644226312637, -0.029783133417367935, 0.0700446292757988, 0.0936647355556488, 0.05477779358625412, 0.05382244661450386, 0.057300664484500885, -0.013208620250225067, -0.017743386328220367, 0.16205516457557678, 0.14349329471588135, -0.14663520455360413, -0.09144312143325806, 0.1345733404159546, 0.06750965863466263, -0.16349489986896515, 0.16484740376472473, 0.0032072949688881636, -0.14764836430549622, -0.0035494938492774963, 0.21563571691513062, -0.02359863370656967, 0.10909050703048706, 0.18450433015823364, 0.02623777836561203, 0.15275351703166962, 0.0015794634819030762, 0.0633479580283165, 0.2113770842552185, 0.14548584818840027, -0.20203740894794464, 0.08000822365283966, 0.20228177309036255, 0.16807547211647034, 0.1224006861448288, 13.636789321899414, -0.06606446206569672, 0.1874728947877884, -0.04834391921758652, -0.030230700969696045, -0.057199105620384216, -0.03655198961496353, 0.03799834102392197, 0.02389100193977356, -0.019934020936489105, 0.04046005383133888, 0.007149651646614075, -0.008018100634217262, 0.04741755872964859, -0.02454429864883423, -0.0213552787899971, -0.0580005943775177, -0.03754625469446182, 0.13020850718021393, 0.0021751299500465393, -0.0975075215101242, -0.04291197657585144, 0.011099301278591156, -0.360529363155365, 0.0235702246427536, -0.014791198074817657, 0.11190371215343475, 0.0976351946592331, 0.05717562511563301, 0.04639727994799614, 0.17628136277198792, 0.11948856711387634, 0.07443229109048843, -0.05626474320888519, -0.031447768211364746, -0.17432205379009247, -0.37107646465301514, -0.14430785179138184, 0.0865001529455185, -0.04535970836877823, -0.02947498857975006, 0.026255618780851364, 0.18684399127960205, -0.03986946493387222, 0.04601258039474487, 0.08404654264450073, -0.2191298007965088, 0.13772420585155487, -0.07417159527540207, -0.05976218730211258, 0.12226899713277817, 0.07283236086368561, 0.22122374176979065, 0.001453697681427002, -0.1680515706539154, -0.19592437148094177, 0.17178601026535034, 0.05681652948260307, -0.0631360113620758, 0.26680421829223633, 0.005096886307001114, -0.07192779332399368, 0.037931207567453384, -0.03523166850209236, -0.03829864040017128, 0.046195920556783676, 0.14192625880241394, 0.04755609482526779, -0.06576362252235413, 0.06751713156700134, 0.1140706017613411, -0.13244035840034485, 0.06940513849258423, -0.010593370534479618, -0.0026550516486167908, 0.05836686119437218, -0.0018334686756134033, -0.021885499358177185, 0.05159382522106171, -0.12119156122207642, -0.035233817994594574, 0.07227855175733566, -0.0808534175157547, -0.09153035283088684, -0.1631571352481842, 0.09611064195632935, -0.08434294164180756, 0.18491053581237793, 0.15845222771167755, 0.0037061236798763275, -0.0495009645819664, 0.062433358281850815, -0.06892573833465576, -0.11792794615030289, 0.18023964762687683, -0.031489454209804535, 0.021454887464642525, -0.13674548268318176, 0.06391894817352295, 0.07191284000873566, -0.07071969658136368, -0.13163766264915466, -0.03147991746664047, 0.10628904402256012, -0.09022606909275055, -0.03157619386911392, 0.018534449860453606, 0.08673378080129623, -0.072469063103199, 0.04779024422168732, 0.05162012577056885, 0.21843582391738892, 0.1268600970506668, -0.20924200117588043, -0.11970312893390656, -0.004017908126115799, 0.05576595664024353, -0.009651299566030502, 0.19176386296749115, 0.07065965980291367, 0.15073451399803162, 0.0717606320977211, -0.1373792588710785, -0.09640799462795258, 0.11908332258462906, -0.15990756452083588, -0.0006408430635929108, 0.1405337005853653, 0.07786288112401962, 0.012125324457883835, 0.0897890254855156, -0.034476637840270996, 0.35965120792388916, 0.11762356758117676, 0.010042399168014526, -0.017758861184120178, -0.001968666911125183, 0.1113700419664383, 0.17285718023777008, 0.15597249567508698, 0.054544951766729355, 0.03510339558124542, 0.20596164464950562, -0.1571357250213623, -0.024157807230949402, 0.24797770380973816, 0.17764456570148468, -0.05123663693666458, 0.002847544848918915, 0.20395424962043762, 0.15203650295734406, 0.13929739594459534, -0.05824028700590134, -0.1603822410106659, -0.04468443617224693, -0.1470191478729248, -0.12926752865314484, 0.030946705490350723, -0.01862010359764099, 0.004636893980205059, 0.2074103057384491, -0.33524662256240845, 0.006937664933502674, -0.26207083463668823, -0.08320732414722443, 0.08668570965528488, 0.04192797839641571, 0.09794055670499802, 0.08167945593595505, -0.11251794546842575, 0.12173590064048767, 0.031216148287057877, -0.20408950746059418, -0.04459865391254425, -0.020121123641729355, 0.022791173309087753, 0.28526008129119873, -0.43126779794692993, -0.15136876702308655, 0.020612072199583054]}"
"{\"sha\": \"7b48b82bbc8f145d11cbaa19be107cb42074273e\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/cc_array.c\", \"func_name\": \"cc_array_destroy_cb\", \"original_string\": \"void cc_array_destroy_cb(CC_Array *ar, void (*cb) (void*))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        cb(ar->buffer[i]);\\n\\n    cc_array_destroy(ar);\\n}\", \"code_tokens\": [\"void\", \"cc_array_destroy_cb\", \"(\", \"CC_Array\", \"*\", \"ar\", \",\", \"void\", \"(\", \"*\", \"cb\", \")\", \"(\", \"void\", \"*\", \")\", \")\", \"{\", \"size_t\", \"i\", \";\", \"for\", \"(\", \"i\", \"=\", \"0\", \";\", \"i\", \"<\", \"ar\", \"->\", \"size\", \";\", \"i\", \"++\", \")\", \"cb\", \"(\", \"ar\", \"->\", \"buffer\", \"[\", \"i\", \"]\", \")\", \";\", \"cc_array_destroy\", \"(\", \"ar\", \")\", \";\", \"}\"], \"docstring\": \"/**\\n * Destroys the CC_Array structure along with all the data it holds.\\n *\\n * @note\\n * This function should not be called on a array that has some of its elements\\n * allocated on the stack.\\n *\\n * @param[in] ar the array that is being destroyed\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Destroys\", \"the\", \"CC_Array\", \"structure\", \"along\", \"with\", \"all\", \"the\", \"data\", \"it\", \"holds\", \".\", \"*\", \"*\", \"@note\", \"*\", \"This\", \"function\", \"should\", \"not\", \"be\", \"called\", \"on\", \"a\", \"array\", \"that\", \"has\", \"some\", \"of\", \"its\", \"elements\", \"*\", \"allocated\", \"on\", \"the\", \"stack\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"ar\", \"the\", \"array\", \"that\", \"is\", \"being\", \"destroyed\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2014 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n#include \\\"cc_array.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\nstruct cc_array_s {\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    void   **buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_Array *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new(CC_Array **out)\\n{\\n    CC_ArrayConf c;\\n    cc_array_conf_init(&c);\\n    return cc_array_new_conf(&c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_Array based on the specified CC_ArrayConf struct and\\n * returns a status code.\\n *\\n * The CC_Array is allocated using the allocators specified in the CC_ArrayConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArrayConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new_conf(CC_ArrayConf const * const conf, CC_Array **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_Array *ar = conf->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    void **buff = conf->mem_alloc(conf->capacity * sizeof(void*));\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->buffer     = buff;\\n    ar->exp_factor = ex;\\n    ar->capacity   = conf->capacity;\\n    ar->mem_alloc  = conf->mem_alloc;\\n    ar->mem_calloc = conf->mem_calloc;\\n    ar->mem_free   = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArrayConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArrayConf structure that is being initialized\\n */\\nvoid cc_array_conf_init(CC_ArrayConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_Array structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_destroy(CC_Array *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n/**\\n * Destroys the CC_Array structure along with all the data it holds.\\n *\\n * @note\\n * This function should not be called on a array that has some of its elements\\n * allocated on the stack.\\n *\\n * @param[in] ar the array that is being destroyed\\n */\\nvoid cc_array_destroy_cb(CC_Array *ar, void (*cb) (void*))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        cb(ar->buffer[i]);\\n\\n    cc_array_destroy(ar);\\n}\\n\\n/**\\n * Adds a new element to the CC_Array. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_Array.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add(CC_Array *ar, void *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    ar->buffer[ar->size] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add_at(CC_Array *ar, void *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * sizeof(void*);\\n\\n    memmove(&(ar->buffer[index + 1]),\\n            &(ar->buffer[index]),\\n            shift);\\n\\n    ar->buffer[index] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_Array.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_replace_at(CC_Array *ar, void *element, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    ar->buffer[index] = element;\\n\\n    return CC_OK;\\n}\\n\\nenum cc_stat cc_array_swap_at(CC_Array *ar, size_t index1, size_t index2)\\n{\\n    void *tmp;\\n\\n    if (index1 >= ar->size || index2 >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    tmp = ar->buffer[index1];\\n\\n    ar->buffer[index1] = ar->buffer[index2];\\n    ar->buffer[index2] = tmp;\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_Array if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_remove(CC_Array *ar, void *element, void **out)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    if (out)\\n        *out = element;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_remove_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_remove_last(CC_Array *ar, void **out)\\n{\\n    return cc_array_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all(CC_Array *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Removes and frees all elements from the specified array. This function does\\n * not shrink the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all_free(CC_Array *ar)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        free(ar->buffer[i]);\\n\\n    cc_array_remove_all(ar);\\n}\\n\\n/**\\n * Gets an CC_Array element from the specified index and sets the out parameter to\\n * its value. The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] index the index of the array element\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_get_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    *out = ar->buffer[index];\\n    return CC_OK;\\n}\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_get_last(CC_Array *ar, void **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    return cc_array_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst void * const* cc_array_get_buffer(CC_Array *ar)\\n{\\n    return (const void* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_Array.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_index_of(CC_Array *ar, void *element, size_t *index)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element) {\\n            *index = i;\\n            return CC_OK;\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_Array, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_Array, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_subarray(CC_Array *ar, size_t b, size_t e, CC_Array **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_Array *sub_ar = ar->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * sizeof(void*)))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc  = ar->mem_alloc;\\n    sub_ar->mem_calloc = ar->mem_calloc;\\n    sub_ar->mem_free   = ar->mem_free;\\n    sub_ar->size       = e - b + 1;\\n    sub_ar->capacity   = sub_ar->size;\\n\\n    memcpy(sub_ar->buffer,\\n           &(ar->buffer[b]),\\n           sub_ar->size * sizeof(void*));\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a shallow copy of the specified CC_Array. A shallow copy is a copy of\\n * the CC_Array structure, but not the elements it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_shallow(CC_Array *ar, CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * sizeof(void*));\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a deep copy of the specified CC_Array. A deep copy is a copy of\\n * both the CC_Array structure and the data it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar   array to be copied\\n * @param[in] cp   the copy function that should return a pointer to the copy of\\n *                 the data\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_deep(CC_Array *ar, void *(*cp) (void *), CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    size_t i;\\n    for (i = 0; i < copy->size; i++)\\n        copy->buffer[i] = cp(ar->buffer[i]);\\n\\n    *out = copy;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty.\\n */\\nenum cc_stat cc_array_filter_mut(CC_Array *ar, bool (*pred) (const void*))\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(ar->buffer[i])) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * sizeof(void*);\\n                memmove(&(ar->buffer[i + 1]),\\n                        &(ar->buffer[i + 1 + rm]),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * sizeof(void*);\\n        memmove(&(ar->buffer[0]),\\n                &(ar->buffer[rm]),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by creating a new CC_Array that contains all elements from the\\n * original CC_Array that return true on pred(element) without modifying the original\\n * CC_Array.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_filter(CC_Array *ar, bool (*pred) (const void*), CC_Array **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    CC_Array *filtered = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!filtered)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->exp_factor = ar->exp_factor;\\n    filtered->size       = 0;\\n    filtered->capacity   = ar->capacity;\\n    filtered->mem_alloc  = ar->mem_alloc;\\n    filtered->mem_calloc = ar->mem_calloc;\\n    filtered->mem_free   = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(ar->buffer[i])) {\\n            filtered->buffer[f++] = ar->buffer[i];\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_reverse(CC_Array *ar)\\n{\\n    if (ar->size == 0)\\n        return;\\n\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        void *tmp = ar->buffer[i];\\n        ar->buffer[i] = ar->buffer[j];\\n        ar->buffer[j] = tmp;\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_Array, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_trim_capacity(CC_Array *ar)\\n{\\n    if (ar->size == ar->capacity)\\n        return CC_OK;\\n\\n    void **new_buff = ar->mem_calloc(ar->size, sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * sizeof(void*));\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_contains(CC_Array *ar, void *element)\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the number of occurrences of the value pointed to by <code>e</code>\\n * within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n * @param[in] cmp comparator function which returns 0 if the values passed to it are equal\\n *\\n * @return the number of occurrences of the value.\\n */\\nsize_t cc_array_contains_value(CC_Array *ar, void *element, int (*cmp) (const void*, const void*))\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (cmp(element, ar->buffer[i]) == 0)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_Array. The size of the array is the\\n * number of elements contained within the CC_Array.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_Array.\\n */\\nsize_t cc_array_size(CC_Array *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_Array. The capacity of the CC_Array is\\n * the maximum number of elements an CC_Array can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_Array.\\n */\\nsize_t cc_array_capacity(CC_Array *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sort(CC_Array *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, sizeof(void*), cmp);\\n}\\n\\n/**\\n * Expands the CC_Array capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_Array *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS)\\n        return CC_ERR_MAX_CAPACITY;\\n\\n    size_t new_capacity = (size_t)(ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity)\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    else\\n        ar->capacity = new_capacity;\\n\\n    void **new_buff = ar->mem_alloc(ar->capacity * sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    memcpy(new_buff, ar->buffer, ar->size * sizeof(void*));\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_map(CC_Array *ar, void (*fn) (void *e))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        fn(ar->buffer[i]);\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_reduce(CC_Array *ar, void (*fn) (void*, void*, void*), void *result)\\n{\\n    if (ar->size == 1) {\\n        fn(ar->buffer[0], NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1)\\n        fn(ar->buffer[0], ar->buffer[1], result);\\n\\n    for (size_t i = 2; i < ar->size; i++)\\n        fn(result, ar->buffer[i], result);\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_iter_init(CC_ArrayIter *iter, CC_Array *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the value of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_iter_next(CC_ArrayIter *iter, void **out)\\n{\\n    if (iter->index >= iter->ar->size)\\n        return CC_ITER_END;\\n\\n    *out = iter->ar->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_iter_remove(CC_ArrayIter *iter, void **out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK)\\n            iter->last_removed = true;\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_Array after the last returned element by\\n * <code>cc_array_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_iter_add(CC_ArrayIter *iter, void *element)\\n{\\n    return cc_array_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_iter_replace(CC_ArrayIter *iter, void *element, void **out)\\n{\\n    return cc_array_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_iter_index(CC_ArrayIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_zip_iter_init(CC_ArrayZipIter *iter, CC_Array *ar1, CC_Array *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_zip_iter_next(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size)\\n        return CC_ITER_END;\\n\\n    *out1 = iter->ar1->buffer[iter->index];\\n    *out2 = iter->ar2->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_zip_iter_remove(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (!iter->last_removed) {\\n        cc_array_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_zip_iter_add(CC_ArrayZipIter *iter, void *e1, void *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_Array  *ar1  = iter->ar1;\\n    CC_Array  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n            (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK)))\\n        return CC_ERR_ALLOC;\\n\\n    cc_array_add_at(ar1, e1, index);\\n    cc_array_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_zip_iter_replace(CC_ArrayZipIter *iter, void *e1, void *e2, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    cc_array_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_zip_iter_index(CC_ArrayZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_struct_size()\\n{\\n    return sizeof(CC_Array);\\n}\", \"embeddings\": [-0.007116623222827911, 0.0035788491368293762, -0.0012116283178329468, 0.09185317158699036, 0.3627986013889313, -0.1418718695640564, 0.1471104621887207, 0.4746416509151459, -0.026255112141370773, -0.24590080976486206, 0.03490813449025154, -0.021729983389377594, 0.00397237204015255, 0.08334284275770187, -0.009761177003383636, 0.10579153895378113, 0.07079222798347473, -0.04314463585615158, 0.033781081438064575, -0.2416118085384369, -0.17376580834388733, 0.03718774393200874, 0.22218714654445648, 0.13459432125091553, 0.15854817628860474, 0.046484578400850296, 0.3326495885848999, 0.20296350121498108, 0.2967628240585327, -0.12140238285064697, 0.06949090957641602, -0.023228168487548828, 0.10570411384105682, -0.1382521539926529, -0.012813962996006012, 0.03372693061828613, 0.007699325680732727, 0.08469600230455399, 0.012649190612137318, 0.005535848438739777, -0.238231360912323, -0.06659894436597824, 0.1152290403842926, 0.22811450064182281, 0.13318657875061035, -0.025607116520404816, -0.001489982008934021, 0.16753961145877838, -0.09670908749103546, 0.06848489493131638, 0.10610619187355042, 0.11511486768722534, -0.07864297181367874, -0.022894088178873062, -0.10882748663425446, 0.02519683912396431, 0.0369562953710556, 0.3391460180282593, 0.09223897755146027, 0.019442379474639893, -0.04918982833623886, -0.03751912713050842, -0.18965980410575867, 0.20310764014720917, 0.22109633684158325, 0.053975947201251984, -0.0749005526304245, -0.18085289001464844, 0.011923947371542454, -0.040847212076187134, 0.08373633772134781, 0.0400458499789238, 0.03924306482076645, -0.24880948662757874, -0.19020861387252808, -0.01930873841047287, 0.12702199816703796, 0.5634922385215759, -0.08546023815870285, 0.13666115701198578, 0.20543061196804047, -0.07598665356636047, 0.006548099219799042, 0.19236746430397034, 0.15903806686401367, -0.08555271476507187, -0.06675557047128677, 0.15315955877304077, 0.012167282402515411, 0.1339586228132248, 0.11713187396526337, 0.12595541775226593, -0.04332714527845383, -0.021567009389400482, -0.025902867317199707, -0.03833085671067238, 0.07550103217363358, -0.3512451648712158, 0.07401122152805328, 0.32426607608795166, -0.1771182417869568, -0.09636017680168152, -0.32727503776550293, -0.18303409218788147, 0.004308752715587616, 0.055846408009529114, 0.07316044718027115, 0.05044669657945633, 0.05963068827986717, -0.007616907358169556, 0.10652719438076019, 0.04523984342813492, 0.021217189729213715, 0.018491283059120178, 0.0746050775051117, -0.1646934151649475, 0.08396981656551361, -0.012489162385463715, 0.1671035885810852, -0.03404591232538223, 0.10616691410541534, -0.06317896395921707, -0.04387220740318298, -0.04752533137798309, -0.0730004608631134, 0.09528805315494537, 0.02447938174009323, -0.28073471784591675, 0.09446477890014648, 0.09387125819921494, 0.039715476334095, -0.1672799438238144, -0.06718483567237854, 0.05214852839708328, 0.15925468504428864, -0.05441414192318916, 0.08996504545211792, 0.03231044486165047, -0.002339780330657959, -0.021320782601833344, -0.12480104714632034, 0.14605572819709778, 0.3513910174369812, -0.03441021218895912, 0.19471779465675354, -0.17557968199253082, 0.16276082396507263, 0.133732408285141, -0.4086531400680542, -0.1851365715265274, 0.04124360531568527, -0.07280628383159637, 0.03927389159798622, 0.021855996921658516, -0.1362943798303604, 0.8619596362113953, 0.10783420503139496, -0.2434178590774536, -0.06235058605670929, -0.02471921592950821, 0.05554841831326485, -0.2706715762615204, -0.05209272354841232, 0.12436561286449432, 0.08223546296358109, 0.14089937508106232, -0.0032197460532188416, 0.12052813172340393, 0.15495124459266663, 0.007055364549160004, 0.047581955790519714, -0.12938354909420013, -0.1317790001630783, 0.19276830554008484, 0.08113129436969757, -0.030413120985031128, -0.1425936371088028, 0.08134224265813828, -0.002110004425048828, 0.13148637115955353, -0.13947993516921997, -0.011905290186405182, -0.157993346452713, -0.05600902438163757, -0.05389753729104996, 0.10605482757091522, 0.08073139935731888, -0.12505726516246796, 0.13770633935928345, 0.01623222976922989, -0.010197598487138748, 0.05771304666996002, 0.1754375845193863, -0.11197389662265778, -0.10323690623044968, 0.06010301038622856, -0.2147524356842041, -0.016267964616417885, 0.29659783840179443, -0.08803901076316833, -0.024895740672945976, -0.19350042939186096, 0.2083212286233902, -0.005416665226221085, 0.07911176979541779, 0.15258751809597015, -0.20582643151283264, -0.027591153979301453, -0.10092316567897797, -0.1472923755645752, -0.05028929188847542, 0.134468212723732, 0.03843555971980095, -0.03984891250729561, -0.10443392395973206, -0.07674337923526764, 0.017031870782375336, 0.1096968948841095, 0.062488265335559845, -0.06039280444383621, 0.12688817083835602, 0.209421306848526, -0.10578691214323044, -0.09964221715927124, -0.19120892882347107, 0.19798855483531952, 0.21844364702701569, 0.06568970531225204, 0.020532410591840744, 0.05719725415110588, 0.1603277623653412, 0.222080260515213, -0.18024887144565582, 0.17026950418949127, -0.022766277194023132, -0.08660664409399033, -0.10921195149421692, 0.02667888253927231, -0.039064861834049225, -0.15859004855155945, -0.04081306979060173, 0.13820840418338776, 0.15236201882362366, 0.24607184529304504, 0.0223652683198452, -0.09262455254793167, -0.17774008214473724, 0.054530929774045944, -0.15118584036827087, 0.10469656437635422, -0.06633862853050232, -0.07534663379192352, 0.12460638582706451, -0.10548479855060577, -0.16374076902866364, -0.043543923646211624, -0.14612895250320435, -0.009952019900083542, 0.11327119171619415, 0.12479454278945923, -0.1084543988108635, -0.10968722403049469, 0.09679991751909256, -0.10081188380718231, -0.043168019503355026, -0.45282652974128723, -0.04914920777082443, 0.08820575475692749, 0.11104042828083038, 0.027469897642731667, 0.107071653008461, -0.0793050155043602, 0.24319985508918762, 0.11399127542972565, 0.13471290469169617, 0.019745711237192154, 0.02257700264453888, 0.03599424660205841, -0.05378970503807068, -0.048497214913368225, -0.030132029205560684, 0.12223988771438599, -0.07060914486646652, 0.08457302302122116, -0.05852975323796272, 0.0818648412823677, 0.07239124178886414, 0.03854484483599663, 0.025340920314192772, 0.06389695405960083, 0.04111946374177933, 0.01668180525302887, 0.13911499083042145, 0.11614121496677399, 0.04299796000123024, 0.08212339878082275, 0.264413982629776, -0.15679824352264404, 0.07190148532390594, -0.2803246080875397, 0.18326401710510254, -0.17930631339550018, 0.0518588088452816, -0.10663436353206635, 0.3763158917427063, -0.0952974408864975, 0.004267804324626923, 0.0887124240398407, 0.24961374700069427, -0.008348491042852402, 0.07169565558433533, 0.1349163055419922, -0.09467363357543945, 0.17762857675552368, -0.1392851173877716, 0.06388053297996521, -0.08684692531824112, -0.044477928429841995, 0.1345897763967514, -0.02001180499792099, -0.11248943209648132, 0.14362964034080505, 0.11872683465480804, 0.17087984085083008, -0.012773588299751282, 0.11910107731819153, 0.1701325625181198, -0.0771481916308403, -0.13994568586349487, 0.6070743799209595, -0.5967931151390076, 0.19755560159683228, -0.23367828130722046, 0.3859299421310425, -0.0434718057513237, 0.3283538222312927, -0.06266330182552338, 0.08989480137825012, 0.11616270244121552, 0.11428004503250122, -0.12193383276462555, -0.07670088112354279, -0.09930601716041565, 0.29167625308036804, 0.09765352308750153, 0.2181490659713745, 0.1418350338935852, -0.027637142688035965, 0.15651634335517883, 0.007868078537285328, -0.16259390115737915, 0.11015429347753525, -0.017866220325231552, -0.12734004855155945, 0.09355916827917099, 0.36166253685951233, -0.20302698016166687, -0.014715526252985, -0.0235787071287632, -0.002638431265950203, 0.25103867053985596, -0.13842278718948364, 0.171052947640419, -0.07414812594652176, 0.30396896600723267, -0.37683233618736267, -0.37562814354896545, 0.02243625372648239, -0.09194427728652954, -0.004839465022087097, 0.14877358078956604, 0.1664244830608368, 0.145980566740036, -0.22726333141326904, 0.01961231604218483, -0.05759512260556221, -0.18396803736686707, -0.07521986216306686, 0.12324859201908112, 0.15637192130088806, 0.013536997139453888, 0.06856171786785126, 0.0959366112947464, 0.03179488331079483, 0.079893097281456, -0.20473790168762207, 0.24829621613025665, 0.18370884656906128, 0.23233932256698608, -0.08148995041847229, 0.125706285238266, -0.1577974110841751, 0.07520794868469238, 0.018124746158719063, 0.005437858402729034, -0.0415600948035717, -0.057273197919130325, 0.14441965520381927, -0.11878248304128647, -0.14968527853488922, 0.07308794558048248, 0.27423620223999023, -0.071281298995018, 0.2030259221792221, 0.18618115782737732, 0.09986288845539093, 0.15133395791053772, -0.08694468438625336, -0.1007157564163208, -0.1570039987564087, 0.07807517051696777, 0.07114195823669434, 0.05208772420883179, 0.04124331846833229, 0.1280817985534668, -0.09795984625816345, 0.06721147149801254, -0.2859256863594055, -0.13683587312698364, 0.23606707155704498, 0.2438252717256546, 0.15888711810112, -0.08321058005094528, -0.14410120248794556, -0.09602144360542297, -0.025947805494070053, -0.07372763752937317, -0.11246566474437714, 0.144683837890625, -0.11850899457931519, 0.016017194837331772, 0.3040858805179596, 0.13218997418880463, 0.1224304586648941, 0.08757197856903076, -0.1429539918899536, -0.08160744607448578, -0.04716793820261955, 0.0844302624464035, 0.1391036957502365, 0.008192453533411026, 0.07327442616224289, 0.05238399654626846, 0.048199646174907684, -0.040540605783462524, -0.16851279139518738, 0.4486020505428314, 0.1153944581747055, -0.16371101140975952, 0.07738029956817627, -0.2311868965625763, 0.07041235268115997, -0.078211709856987, -0.5699717998504639, 0.12878699600696564, 0.22163495421409607, 0.0480465292930603, 0.06574863940477371, 0.0884205549955368, 0.0395880788564682, 0.08225240558385849, 0.05380113422870636, -0.015870574861764908, -0.10823235660791397, -0.03125908225774765, -0.0771879330277443, 0.1667184680700302, 0.08155035972595215, 0.1669992357492447, 0.05988900363445282, 0.06881868839263916, 0.24885591864585876, 0.005774861201643944, -0.19074681401252747, 0.017302589491009712, 0.0337645597755909, -0.0670580267906189, -0.2526387870311737, 0.11771499365568161, -0.14723514020442963, -0.05812247470021248, 0.05653977766633034, 0.1772829294204712, -0.014551997184753418, -0.011167528107762337, -0.09825410693883896, 0.3219474256038666, 0.10292097181081772, -0.2143045961856842, -0.05488462373614311, -0.10709156095981598, 0.11433930695056915, 0.04124128073453903, 0.09183479845523834, 0.2642228603363037, 0.14459049701690674, 0.06772524118423462, 0.12520037591457367, 0.2856181263923645, -0.035116832703351974, 0.061022356152534485, 0.16074548661708832, 0.07741233706474304, -0.06400136649608612, -0.1712297648191452, -0.15441420674324036, -0.012806206941604614, 0.13195356726646423, 0.16061140596866608, -0.23358222842216492, -0.08019190281629562, -0.04560206085443497, 0.07792745530605316, -0.01021026074886322, 0.003947116434574127, 0.027743324637413025, -0.005843132734298706, 0.0610518641769886, 0.02524556592106819, 0.2520005404949188, -0.10290177166461945, -0.18367794156074524, -0.031170468777418137, 0.020737621933221817, -0.02113029547035694, 0.08373215794563293, 0.08101852238178253, 0.0003705918788909912, 0.1452176868915558, 0.06676238030195236, 0.03228623420000076, 0.05521860346198082, 0.059989433735609055, 0.1921335905790329, -0.12542319297790527, 0.0829605907201767, 0.12746025621891022, -0.06440293788909912, 0.16341060400009155, -0.1109495460987091, -0.271200031042099, -0.0865822359919548, 0.16322331130504608, -0.06393986940383911, 0.17562012374401093, 0.0314696840941906, 0.26418811082839966, 0.02349134162068367, -0.028294436633586884, 0.00020156055688858032, -0.14044512808322906, -0.8567516803741455, 0.029278485104441643, 0.11917103826999664, -0.08284853398799896, 0.03136910870671272, 0.12753160297870636, 0.07014617323875427, 0.06361176073551178, 0.09591551870107651, 0.03990521654486656, -0.11668848246335983, 0.15368950366973877, 0.15388312935829163, -0.13604636490345, -0.045328084379434586, 0.06067145988345146, 0.12414207309484482, -0.1878676414489746, 0.1732703596353531, -0.05758620798587799, -0.19142279028892517, -0.009427577257156372, 0.28493019938468933, 0.020353227853775024, 0.038372404873371124, 0.2065267562866211, 0.08400629460811615, 0.23998752236366272, -0.026017025113105774, 0.02408461831510067, 0.25190308690071106, 0.11506937444210052, -0.19741924107074738, 0.06790750473737717, 0.1302502304315567, 0.16528883576393127, -0.018059439957141876, 13.726119041442871, -0.10426931828260422, 0.21132105588912964, -0.08440632373094559, -0.03209902346134186, 0.01343545876443386, -0.07377549260854721, 0.04791959747672081, 0.010596804320812225, -0.01647172123193741, 0.06212340667843819, -0.0010547060519456863, -0.003963526338338852, 0.05344340205192566, 0.012745074927806854, -0.12178242206573486, -0.028610318899154663, -0.07750049233436584, 0.20075911283493042, -0.031488530337810516, -0.11047406494617462, -0.13216710090637207, 0.0043337345123291016, -0.4336177408695221, -0.05943716689944267, -0.012330479919910431, 0.17923873662948608, 0.11203139275312424, 0.05848545581102371, 0.09213841706514359, 0.15226826071739197, 0.10794787108898163, 0.11728048324584961, -0.061843082308769226, -0.046958036720752716, -0.13535012304782867, -0.46235060691833496, -0.21535205841064453, 0.13630777597427368, -0.03603162616491318, -0.04192860424518585, -0.019595392048358917, 0.2261524349451065, -0.12118839472532272, 0.08197031915187836, 0.10394837707281113, -0.3057536482810974, 0.1323205828666687, -0.07038145512342453, -0.06314025819301605, 0.12669402360916138, 0.1033463105559349, 0.32169824838638306, 0.063376285135746, -0.14041852951049805, -0.26602280139923096, 0.22366544604301453, 0.04704351723194122, -0.04909038543701172, 0.4031009376049042, -0.01813359558582306, -0.18418040871620178, 0.037591274827718735, -0.08546513319015503, -0.07901923358440399, 0.019676633179187775, 0.1541159600019455, 0.07269297540187836, -0.020136050879955292, 0.12428956478834152, 0.21326512098312378, -0.16988791525363922, 0.18804050981998444, -0.04075447469949722, 0.004230905324220657, 0.00226781377568841, -0.053810544312000275, -0.01597435027360916, 0.029956519603729248, -0.10007372498512268, -0.019116848707199097, 0.08309932798147202, -0.1712106168270111, -0.12284690886735916, -0.24171791970729828, 0.1218847781419754, -0.042975444346666336, 0.20324784517288208, 0.2368837296962738, -0.04409090429544449, -0.07629530131816864, 0.08201801776885986, -0.020180195569992065, -0.14825555682182312, 0.20578089356422424, -0.04415664076805115, 0.0020124390721321106, -0.16901449859142303, 0.02169767953455448, 0.041896555572748184, -0.10200909525156021, -0.0991256982088089, -0.026086978614330292, 0.04377559572458267, -0.10846361517906189, -0.0016592815518379211, 0.05233658850193024, 0.06468559801578522, -0.039216794073581696, 0.011960774660110474, 0.09979438781738281, 0.17228220403194427, 0.1684369146823883, -0.19989337027072906, -0.16345317661762238, -0.035639647394418716, 0.02029251679778099, 0.033016908913850784, 0.22479814291000366, 0.05234795808792114, 0.1711990237236023, 0.09663499146699905, -0.12831011414527893, -0.07028768956661224, 0.1370764821767807, -0.19713494181632996, 0.05253675580024719, 0.1758926659822464, 0.11497455090284348, -0.010116193443536758, 0.13295558094978333, -0.12418431788682938, 0.3533896505832672, 0.1803710162639618, 0.006932199001312256, -0.060408174991607666, -0.030583620071411133, 0.10085773468017578, 0.22121316194534302, 0.27805295586586, 0.08113782107830048, -0.018044978380203247, 0.19240477681159973, -0.18984533846378326, -0.0032581016421318054, 0.2621612250804901, 0.20867103338241577, -0.0711422711610794, -0.13126711547374725, 0.1868942826986313, 0.11247249692678452, 0.21652933955192566, -0.1809099018573761, -0.18884268403053284, -0.08436405658721924, -0.13976715505123138, -0.14744868874549866, -0.028549138456583023, -0.08332601934671402, 0.009197041392326355, 0.1758420169353485, -0.47440019249916077, 0.10714091360569, -0.3239513337612152, -0.045090463012456894, 0.05561461299657822, 0.16605815291404724, 0.08682268112897873, 0.06416580826044083, -0.1055547371506691, 0.11366528272628784, 0.11717934906482697, -0.24825507402420044, -0.05710552632808685, -0.04796478524804115, 0.05470982939004898, 0.3377858102321625, -0.4417523145675659, -0.17587965726852417, 0.015009038150310516]}"
"{\"sha\": \"7b48b82bbc8f145d11cbaa19be107cb42074273e\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/cc_array.c\", \"func_name\": \"cc_array_add\", \"original_string\": \"enum cc_stat cc_array_add(CC_Array *ar, void *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    ar->buffer[ar->size] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\", \"code_tokens\": [\"enum\", \"cc_stat\", \"cc_array_add\", \"(\", \"CC_Array\", \"*\", \"ar\", \",\", \"void\", \"*\", \"element\", \")\", \"{\", \"if\", \"(\", \"ar\", \"->\", \"size\", \">=\", \"ar\", \"->\", \"capacity\", \")\", \"{\", \"enum\", \"cc_stat\", \"status\", \"=\", \"expand_capacity\", \"(\", \"ar\", \")\", \";\", \"if\", \"(\", \"status\", \"!=\", \"CC_OK\", \")\", \"return\", \"status\", \";\", \"}\", \"ar\", \"->\", \"buffer\", \"[\", \"ar\", \"->\", \"size\", \"]\", \"=\", \"element\", \";\", \"ar\", \"->\", \"size\", \"++\", \";\", \"return\", \"CC_OK\", \";\", \"}\"], \"docstring\": \"/**\\n * Adds a new element to the CC_Array. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_Array.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Adds\", \"a\", \"new\", \"element\", \"to\", \"the\", \"CC_Array\", \".\", \"The\", \"element\", \"is\", \"appended\", \"to\", \"the\", \"array\", \"making\", \"*\", \"it\", \"the\", \"last\", \"element\", \"(\", \"the\", \"one\", \"with\", \"the\", \"highest\", \"index\", \")\", \"of\", \"the\", \"CC_Array\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"ar\", \"the\", \"array\", \"to\", \"which\", \"the\", \"element\", \"is\", \"being\", \"added\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"element\", \"the\", \"element\", \"that\", \"is\", \"being\", \"added\", \"*\", \"*\", \"@return\", \"CC_OK\", \"if\", \"the\", \"element\", \"was\", \"successfully\", \"added\", \"CC_ERR_ALLOC\", \"if\", \"the\", \"*\", \"memory\", \"allocation\", \"for\", \"the\", \"new\", \"element\", \"failed\", \"or\", \"CC_ERR_MAX_CAPACITY\", \"if\", \"the\", \"*\", \"array\", \"is\", \"already\", \"at\", \"maximum\", \"capacity\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2014 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n#include \\\"cc_array.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\nstruct cc_array_s {\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    void   **buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_Array *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new(CC_Array **out)\\n{\\n    CC_ArrayConf c;\\n    cc_array_conf_init(&c);\\n    return cc_array_new_conf(&c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_Array based on the specified CC_ArrayConf struct and\\n * returns a status code.\\n *\\n * The CC_Array is allocated using the allocators specified in the CC_ArrayConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArrayConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new_conf(CC_ArrayConf const * const conf, CC_Array **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_Array *ar = conf->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    void **buff = conf->mem_alloc(conf->capacity * sizeof(void*));\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->buffer     = buff;\\n    ar->exp_factor = ex;\\n    ar->capacity   = conf->capacity;\\n    ar->mem_alloc  = conf->mem_alloc;\\n    ar->mem_calloc = conf->mem_calloc;\\n    ar->mem_free   = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArrayConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArrayConf structure that is being initialized\\n */\\nvoid cc_array_conf_init(CC_ArrayConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_Array structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_destroy(CC_Array *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n/**\\n * Destroys the CC_Array structure along with all the data it holds.\\n *\\n * @note\\n * This function should not be called on a array that has some of its elements\\n * allocated on the stack.\\n *\\n * @param[in] ar the array that is being destroyed\\n */\\nvoid cc_array_destroy_cb(CC_Array *ar, void (*cb) (void*))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        cb(ar->buffer[i]);\\n\\n    cc_array_destroy(ar);\\n}\\n\\n/**\\n * Adds a new element to the CC_Array. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_Array.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add(CC_Array *ar, void *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    ar->buffer[ar->size] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add_at(CC_Array *ar, void *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * sizeof(void*);\\n\\n    memmove(&(ar->buffer[index + 1]),\\n            &(ar->buffer[index]),\\n            shift);\\n\\n    ar->buffer[index] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_Array.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_replace_at(CC_Array *ar, void *element, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    ar->buffer[index] = element;\\n\\n    return CC_OK;\\n}\\n\\nenum cc_stat cc_array_swap_at(CC_Array *ar, size_t index1, size_t index2)\\n{\\n    void *tmp;\\n\\n    if (index1 >= ar->size || index2 >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    tmp = ar->buffer[index1];\\n\\n    ar->buffer[index1] = ar->buffer[index2];\\n    ar->buffer[index2] = tmp;\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_Array if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_remove(CC_Array *ar, void *element, void **out)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    if (out)\\n        *out = element;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_remove_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_remove_last(CC_Array *ar, void **out)\\n{\\n    return cc_array_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all(CC_Array *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Removes and frees all elements from the specified array. This function does\\n * not shrink the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all_free(CC_Array *ar)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        free(ar->buffer[i]);\\n\\n    cc_array_remove_all(ar);\\n}\\n\\n/**\\n * Gets an CC_Array element from the specified index and sets the out parameter to\\n * its value. The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] index the index of the array element\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_get_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    *out = ar->buffer[index];\\n    return CC_OK;\\n}\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_get_last(CC_Array *ar, void **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    return cc_array_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst void * const* cc_array_get_buffer(CC_Array *ar)\\n{\\n    return (const void* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_Array.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_index_of(CC_Array *ar, void *element, size_t *index)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element) {\\n            *index = i;\\n            return CC_OK;\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_Array, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_Array, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_subarray(CC_Array *ar, size_t b, size_t e, CC_Array **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_Array *sub_ar = ar->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * sizeof(void*)))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc  = ar->mem_alloc;\\n    sub_ar->mem_calloc = ar->mem_calloc;\\n    sub_ar->mem_free   = ar->mem_free;\\n    sub_ar->size       = e - b + 1;\\n    sub_ar->capacity   = sub_ar->size;\\n\\n    memcpy(sub_ar->buffer,\\n           &(ar->buffer[b]),\\n           sub_ar->size * sizeof(void*));\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a shallow copy of the specified CC_Array. A shallow copy is a copy of\\n * the CC_Array structure, but not the elements it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_shallow(CC_Array *ar, CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * sizeof(void*));\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a deep copy of the specified CC_Array. A deep copy is a copy of\\n * both the CC_Array structure and the data it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar   array to be copied\\n * @param[in] cp   the copy function that should return a pointer to the copy of\\n *                 the data\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_deep(CC_Array *ar, void *(*cp) (void *), CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    size_t i;\\n    for (i = 0; i < copy->size; i++)\\n        copy->buffer[i] = cp(ar->buffer[i]);\\n\\n    *out = copy;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty.\\n */\\nenum cc_stat cc_array_filter_mut(CC_Array *ar, bool (*pred) (const void*))\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(ar->buffer[i])) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * sizeof(void*);\\n                memmove(&(ar->buffer[i + 1]),\\n                        &(ar->buffer[i + 1 + rm]),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * sizeof(void*);\\n        memmove(&(ar->buffer[0]),\\n                &(ar->buffer[rm]),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by creating a new CC_Array that contains all elements from the\\n * original CC_Array that return true on pred(element) without modifying the original\\n * CC_Array.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_filter(CC_Array *ar, bool (*pred) (const void*), CC_Array **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    CC_Array *filtered = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!filtered)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->exp_factor = ar->exp_factor;\\n    filtered->size       = 0;\\n    filtered->capacity   = ar->capacity;\\n    filtered->mem_alloc  = ar->mem_alloc;\\n    filtered->mem_calloc = ar->mem_calloc;\\n    filtered->mem_free   = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(ar->buffer[i])) {\\n            filtered->buffer[f++] = ar->buffer[i];\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_reverse(CC_Array *ar)\\n{\\n    if (ar->size == 0)\\n        return;\\n\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        void *tmp = ar->buffer[i];\\n        ar->buffer[i] = ar->buffer[j];\\n        ar->buffer[j] = tmp;\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_Array, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_trim_capacity(CC_Array *ar)\\n{\\n    if (ar->size == ar->capacity)\\n        return CC_OK;\\n\\n    void **new_buff = ar->mem_calloc(ar->size, sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * sizeof(void*));\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_contains(CC_Array *ar, void *element)\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the number of occurrences of the value pointed to by <code>e</code>\\n * within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n * @param[in] cmp comparator function which returns 0 if the values passed to it are equal\\n *\\n * @return the number of occurrences of the value.\\n */\\nsize_t cc_array_contains_value(CC_Array *ar, void *element, int (*cmp) (const void*, const void*))\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (cmp(element, ar->buffer[i]) == 0)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_Array. The size of the array is the\\n * number of elements contained within the CC_Array.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_Array.\\n */\\nsize_t cc_array_size(CC_Array *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_Array. The capacity of the CC_Array is\\n * the maximum number of elements an CC_Array can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_Array.\\n */\\nsize_t cc_array_capacity(CC_Array *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sort(CC_Array *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, sizeof(void*), cmp);\\n}\\n\\n/**\\n * Expands the CC_Array capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_Array *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS)\\n        return CC_ERR_MAX_CAPACITY;\\n\\n    size_t new_capacity = (size_t)(ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity)\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    else\\n        ar->capacity = new_capacity;\\n\\n    void **new_buff = ar->mem_alloc(ar->capacity * sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    memcpy(new_buff, ar->buffer, ar->size * sizeof(void*));\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_map(CC_Array *ar, void (*fn) (void *e))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        fn(ar->buffer[i]);\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_reduce(CC_Array *ar, void (*fn) (void*, void*, void*), void *result)\\n{\\n    if (ar->size == 1) {\\n        fn(ar->buffer[0], NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1)\\n        fn(ar->buffer[0], ar->buffer[1], result);\\n\\n    for (size_t i = 2; i < ar->size; i++)\\n        fn(result, ar->buffer[i], result);\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_iter_init(CC_ArrayIter *iter, CC_Array *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the value of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_iter_next(CC_ArrayIter *iter, void **out)\\n{\\n    if (iter->index >= iter->ar->size)\\n        return CC_ITER_END;\\n\\n    *out = iter->ar->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_iter_remove(CC_ArrayIter *iter, void **out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK)\\n            iter->last_removed = true;\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_Array after the last returned element by\\n * <code>cc_array_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_iter_add(CC_ArrayIter *iter, void *element)\\n{\\n    return cc_array_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_iter_replace(CC_ArrayIter *iter, void *element, void **out)\\n{\\n    return cc_array_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_iter_index(CC_ArrayIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_zip_iter_init(CC_ArrayZipIter *iter, CC_Array *ar1, CC_Array *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_zip_iter_next(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size)\\n        return CC_ITER_END;\\n\\n    *out1 = iter->ar1->buffer[iter->index];\\n    *out2 = iter->ar2->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_zip_iter_remove(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (!iter->last_removed) {\\n        cc_array_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_zip_iter_add(CC_ArrayZipIter *iter, void *e1, void *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_Array  *ar1  = iter->ar1;\\n    CC_Array  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n            (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK)))\\n        return CC_ERR_ALLOC;\\n\\n    cc_array_add_at(ar1, e1, index);\\n    cc_array_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_zip_iter_replace(CC_ArrayZipIter *iter, void *e1, void *e2, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    cc_array_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_zip_iter_index(CC_ArrayZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_struct_size()\\n{\\n    return sizeof(CC_Array);\\n}\", \"embeddings\": [0.0088273324072361, -0.011856049299240112, -0.014558177441358566, 0.07139332592487335, 0.4054029583930969, -0.14551806449890137, 0.13835367560386658, 0.39473584294319153, -0.12978319823741913, -0.30108892917633057, 0.036202218383550644, -0.07248144596815109, 0.06749443709850311, 0.1106937825679779, 0.04485905170440674, 0.09721598774194717, 0.09394832700490952, -0.116356261074543, 0.00364101305603981, -0.415894478559494, -0.17116816341876984, 0.09333285689353943, 0.15651831030845642, 0.16916370391845703, 0.22208650410175323, 0.11240790784358978, 0.2953876256942749, 0.1182287186384201, 0.4362572431564331, -0.12747280299663544, 0.0608392171561718, -0.13077878952026367, 0.11296007037162781, -0.13432392477989197, 0.07384374737739563, -0.029851339757442474, 0.02841292694211006, 0.1349755823612213, 0.05952003225684166, -0.00805589184165001, -0.18022742867469788, 0.07344755530357361, 0.05791474133729935, 0.169840469956398, 0.16675713658332825, -0.08197225630283356, 0.0601787269115448, 0.24161002039909363, -0.06808826327323914, 0.06946008652448654, 0.09917610883712769, -0.12084975838661194, 0.023792851716279984, -0.12185303121805191, -0.06527940928936005, 0.0007421225309371948, -0.036616381257772446, 0.35908982157707214, 0.08183002471923828, -0.01845552772283554, -0.08644267916679382, -0.1392156034708023, -0.19653531908988953, 0.19977232813835144, 0.14285600185394287, 0.059493400156497955, -0.05564296618103981, -0.20042428374290466, 0.05986589565873146, -0.02248849719762802, 0.09913268685340881, 0.18085289001464844, 0.14607515931129456, -0.18759147822856903, -0.17181913554668427, -0.05550432205200195, 0.035513363778591156, 0.47893989086151123, -0.13148808479309082, 0.2100706696510315, 0.21381600201129913, -0.05180051550269127, 0.17207413911819458, 0.24495795369148254, 0.18538478016853333, -0.06622052937746048, -0.1720711886882782, 0.10258383303880692, -0.08623144775629044, 0.1871623992919922, 0.0817558690905571, 0.15039651095867157, -0.0684293732047081, -0.1357247680425644, -0.049305260181427, -0.009609375149011612, 0.05108167976140976, -0.13860303163528442, 0.09383752942085266, 0.445616215467453, -0.07170361280441284, -0.1286647915840149, -0.3709075152873993, -0.2603129744529724, -0.04741454869508743, 0.052018437534570694, -0.0654388815164566, 0.017029646784067154, 0.06215250492095947, -0.009675592184066772, 0.14615529775619507, 0.04140752553939819, 0.010506236925721169, 0.010609790682792664, -0.02497732639312744, -0.1252463161945343, 0.07563725113868713, -0.030333541333675385, 0.22269520163536072, -0.14310312271118164, 0.15867926180362701, -0.02133713662624359, -0.010257214307785034, -0.04071026295423508, -0.05787748843431473, -0.06576794385910034, 0.05805716663599014, -0.32057130336761475, 0.1425294578075409, 0.02864006906747818, 0.030513852834701538, -0.06159869581460953, 0.0014583095908164978, 0.015993893146514893, 0.155223548412323, -0.032894063740968704, 0.17178353667259216, -0.010447241365909576, 0.10977616161108017, -0.009757257997989655, -0.138519287109375, 0.07265853881835938, 0.24421632289886475, -0.026541154831647873, 0.1975564956665039, -0.21294356882572174, 0.22884994745254517, 0.08837331831455231, -0.4103826582431793, -0.2553890645503998, 0.024277329444885254, -0.14852288365364075, -0.03903181478381157, 0.04466608911752701, -0.17493711411952972, 0.796845555305481, 0.009963825345039368, -0.250379741191864, -0.06349451094865799, 0.05009522661566734, 0.006813861429691315, -0.34332355856895447, -0.12451933324337006, 0.22495177388191223, 0.04825150594115257, 0.12061957269906998, 0.053277015686035156, 0.11705006659030914, 0.23277857899665833, 0.06522618234157562, 0.1398846060037613, -0.16730619966983795, -0.06367752701044083, 0.12602373957633972, 0.07510463893413544, -0.09538627415895462, -0.11115874350070953, 0.09794729202985764, 0.029106877744197845, 0.058163199573755264, -0.1386738121509552, 0.0076741911470890045, -0.19976307451725006, -0.02972552180290222, -0.1655917763710022, 0.011654671281576157, -0.010803785175085068, -0.05869424343109131, 0.11917877942323685, -0.05587450787425041, 0.015179067850112915, 0.0016051940619945526, 0.19463898241519928, -0.09727039933204651, -0.05894922465085983, 0.03892692178487778, -0.1594271957874298, -0.0334479957818985, 0.35382312536239624, -0.08093518018722534, -0.04048197716474533, -0.2270371913909912, 0.25553417205810547, -0.02384394034743309, 0.058264754712581635, 0.16389289498329163, -0.22389690577983856, -0.05442952364683151, -0.060560744255781174, -0.159956157207489, -0.13119226694107056, 0.06463941931724548, 0.141410693526268, 0.028464898467063904, -0.09572461247444153, -0.07178116589784622, 0.02306533232331276, 0.11804500222206116, 0.08436568081378937, -0.07908574491739273, 0.11999892443418503, 0.22578224539756775, -0.17185789346694946, -0.09867504239082336, -0.321716845035553, 0.14205828309059143, 0.21594049036502838, 0.17655663192272186, -0.03422747552394867, 0.09293494373559952, 0.13515548408031464, 0.27773672342300415, -0.34352371096611023, 0.1571190357208252, -0.03172081708908081, -0.18266741931438446, -0.017951540648937225, -0.038184672594070435, -0.07138621062040329, -0.2098054140806198, -0.06703251600265503, 0.20537523925304413, 0.1002182886004448, 0.29938745498657227, 0.01672210544347763, -0.04208594560623169, -0.12964332103729248, 0.047654323279857635, -0.21147020161151886, 0.13149696588516235, -0.011043259873986244, -0.07186858355998993, 0.0018838383257389069, -0.11331690847873688, -0.09052467346191406, -0.024689842015504837, -0.07369488477706909, -0.030625399202108383, 0.06967639178037643, 0.14585164189338684, -0.027281612157821655, -0.012122230604290962, 0.11578346788883209, -0.06834264099597931, -0.18771326541900635, -0.5366949439048767, -0.022598236799240112, 0.18056310713291168, 0.10594064742326736, -0.0537630170583725, 0.1166730672121048, -0.05829652398824692, 0.2669559121131897, 0.17991232872009277, 0.09307506680488586, -0.02387876808643341, -0.10296011716127396, -0.04627441242337227, -0.1518881916999817, 0.01218261756002903, 0.06399552524089813, 0.14481551945209503, -0.1691843718290329, 0.08493733406066895, 0.06613536179065704, 0.07969063520431519, 0.23527580499649048, 0.036384738981723785, 0.008784875273704529, 0.04130947217345238, 0.07672390341758728, 0.11325052380561829, 0.1999187469482422, 0.15734736621379852, 0.08091600984334946, 0.0852082148194313, 0.24826471507549286, -0.03138495981693268, 0.009872376918792725, -0.44624063372612, 0.20218190550804138, -0.1990019679069519, 0.006966826505959034, -0.006014600396156311, 0.40782612562179565, -0.02693285420536995, 0.02256939560174942, 0.08521682024002075, 0.238307386636734, 0.018779423087835312, 0.1713280826807022, 0.1811164915561676, -0.12306404858827591, 0.09304546564817429, -0.11200518906116486, 0.1001710519194603, -0.0873473659157753, -0.03137119486927986, 0.16487325727939606, 0.022088125348091125, -0.13334067165851593, 0.12037140130996704, 0.29094234108924866, 0.13128027319908142, 0.05590138956904411, 0.07735150307416916, 0.21387289464473724, -0.1282445341348648, -0.2762080729007721, 0.6051650643348694, -0.4115986227989197, 0.21644742786884308, -0.2577449083328247, 0.457400381565094, -0.09729605913162231, 0.38948577642440796, -0.02998916059732437, 0.07085517048835754, 0.036182962357997894, 0.18674498796463013, -0.17424730956554413, -0.19071254134178162, -0.11198580265045166, 0.26981136202812195, 0.15840598940849304, 0.18787473440170288, 0.2483234852552414, -0.04658247157931328, 0.13296261429786682, -0.06493537127971649, -0.12307877838611603, 0.12377770245075226, -0.027161069214344025, -0.07860907912254333, 0.09129944443702698, 0.4108939468860626, -0.17093569040298462, -0.07290917634963989, -0.0006494317203760147, -0.02060626819729805, 0.286909818649292, -0.3718639612197876, 0.17947763204574585, -0.1312789022922516, 0.2586108148097992, -0.538250744342804, -0.3771554231643677, 0.019635047763586044, -0.1498478800058365, 0.046326346695423126, 0.17158694565296173, 0.11255259811878204, 0.17455914616584778, -0.2887861430644989, 0.05808287486433983, -0.0980294942855835, -0.1571921706199646, -0.009829580783843994, 0.041525840759277344, 0.07254993170499802, 0.07919960469007492, 0.1292686015367508, 0.044479526579380035, 0.061551399528980255, 0.09284835308790207, -0.14039799571037292, 0.22934618592262268, 0.18130287528038025, 0.2301904410123825, -0.0856558233499527, 0.16428562998771667, -0.23604819178581238, 0.11628097295761108, -0.11137038469314575, 0.022119827568531036, -0.03133899345993996, -0.039623647928237915, 0.176295205950737, -0.11858762800693512, -0.16370029747486115, 0.11554640531539917, 0.25290438532829285, -0.0769505649805069, 0.2401033490896225, 0.12032860517501831, 0.03685849532485008, 0.1331007331609726, -0.15002809464931488, -0.14953544735908508, -0.16879598796367645, 0.059617478400468826, 0.025535207241773605, 0.05283423513174057, 0.09804879128932953, 0.19190062582492828, -0.1061384379863739, 0.13864940404891968, -0.34618306159973145, -0.19838854670524597, 0.29368793964385986, 0.20579156279563904, 0.11999865621328354, 0.026104819029569626, -0.255533903837204, -0.11948318779468536, -0.0845983698964119, -0.0911465585231781, -0.11162028461694717, 0.10425885021686554, -0.2383003532886505, 0.02097630500793457, 0.3136436939239502, 0.1831178218126297, 0.16022515296936035, 0.08136308193206787, -0.022002875804901123, -0.10038550198078156, -0.02063898742198944, 0.04491370916366577, 0.07460179179906845, -0.060439351946115494, 0.1351495236158371, 0.037067659199237823, 0.05391368269920349, -0.005196880549192429, -0.061354197561740875, 0.42326119542121887, 0.13800689578056335, -0.11170575022697449, 0.09559566527605057, -0.10655790567398071, 0.059199124574661255, -0.030848268419504166, -0.3928411602973938, 0.16348132491111755, 0.24993249773979187, 0.12417520582675934, 0.09222763031721115, 0.12344913929700851, 0.03344641253352165, 0.007923629134893417, 0.044395893812179565, -0.10510899126529694, -0.11563458293676376, -0.01438816636800766, -0.057793982326984406, 0.12787455320358276, -0.007467977702617645, 0.18717294931411743, 0.09441076219081879, 0.17133866250514984, 0.28731077909469604, 0.032356105744838715, 0.020684894174337387, -0.02583211287856102, 0.06084894388914108, -0.1449003964662552, -0.3294033110141754, 0.06039729341864586, -0.176201730966568, 0.03332459181547165, 0.01995924860239029, 0.16782763600349426, 0.04629330337047577, 0.016449756920337677, -0.14079231023788452, 0.36045360565185547, 0.08902003616094589, -0.12833774089813232, -0.008922401815652847, -0.05281601473689079, 0.23360781371593475, -0.01830454170703888, 0.2192383110523224, 0.25965166091918945, 0.18863071501255035, 0.05269106477499008, 0.18351690471172333, 0.38192155957221985, -0.09196044504642487, 0.018926460295915604, 0.13595549762248993, 0.017785243690013885, -0.10222218930721283, -0.2025071531534195, -0.19220533967018127, -0.04579509049654007, 0.1104549691081047, 0.19264356791973114, -0.16509968042373657, -0.06451769918203354, -0.11380379647016525, 0.12975487112998962, -0.04118902236223221, 0.08802516013383865, 0.09715933352708817, -0.11400377750396729, 0.06065403297543526, -0.04034587740898132, 0.35833001136779785, -0.1097092479467392, -0.2057783603668213, -0.04857533797621727, -0.040965549647808075, 0.016243459656834602, 0.04062235355377197, 0.1591462790966034, 0.03446268290281296, 0.19791334867477417, 0.11379645019769669, 0.06091576814651489, -0.010908275842666626, 0.052143342792987823, 0.21134835481643677, -0.17949749529361725, 0.03450195491313934, 0.11698532104492188, 0.016776446253061295, 0.2726972699165344, -0.10649407655000687, -0.2615449130535126, -0.09425633400678635, 0.24593323469161987, -0.08735264837741852, 0.17067529261112213, 0.03131880611181259, 0.2978297770023346, 0.10639888793230057, -0.017294246703386307, -0.0237104669213295, -0.06450861692428589, -0.7197355628013611, -0.039744604378938675, 0.20456042885780334, -0.1161791980266571, 0.075644850730896, 0.23198607563972473, 0.032019615173339844, 0.06852339953184128, 0.1238100528717041, 0.03227619081735611, -0.029400058090686798, 0.16330434381961823, 0.18280397355556488, -0.11703112721443176, -0.19700013101100922, 0.1353822648525238, 0.1422397792339325, -0.2502777576446533, 0.28305208683013916, 0.01318324450403452, -0.20909154415130615, 0.026914771646261215, 0.3730773329734802, 0.02115119993686676, -0.012399349361658096, 0.2146908938884735, 0.05787287652492523, 0.26786738634109497, -0.08608850836753845, 0.031061286106705666, 0.44043871760368347, 0.22402958571910858, -0.30063045024871826, 0.05247407779097557, 0.09611586481332779, 0.14628735184669495, -0.03673774003982544, 13.696481704711914, -0.04151294007897377, 0.28732919692993164, -0.2266230285167694, -0.07266820967197418, 0.01354089006781578, -0.019052773714065552, 0.08685802668333054, 0.007547251880168915, -0.119905486702919, 0.1090533435344696, -0.06516679376363754, 0.012395111843943596, 0.025433098897337914, -0.08076852560043335, -0.18134251236915588, -0.06304346024990082, -0.10717746615409851, 0.22562170028686523, -0.015967853367328644, -0.24916380643844604, -0.1446586400270462, -0.07304497063159943, -0.6185749769210815, -0.08339085429906845, 0.007359065115451813, 0.15133747458457947, 0.07556852698326111, 0.007197846658527851, 0.0755242109298706, 0.2396242320537567, 0.15448565781116486, 0.08715149760246277, -0.01804252713918686, 0.07955683022737503, -0.07231828570365906, -0.46529269218444824, -0.1496884673833847, 0.16947105526924133, 0.07544326782226562, -0.02894458919763565, 0.060264162719249725, 0.1983685940504074, -0.08037420362234116, 0.10278093814849854, 0.1445184201002121, -0.35092324018478394, 0.20121094584465027, -0.13926279544830322, -0.0726335272192955, 0.1918322592973709, 0.10374870151281357, 0.34324902296066284, 0.060960933566093445, -0.1825403869152069, -0.3201534152030945, 0.25837939977645874, -0.0712420642375946, -0.11023461818695068, 0.4974292516708374, -0.039530716836452484, -0.17280331254005432, 0.05009571462869644, 0.026446882635354996, 0.053607746958732605, 0.07502597570419312, 0.07036339491605759, -0.051325902342796326, -0.2441978007555008, 0.13182595372200012, 0.29426178336143494, -0.219473734498024, 0.2071904093027115, -0.05104799196124077, 0.0055854469537734985, 0.10378490388393402, 0.06251733750104904, -0.10667984187602997, 0.06156769022345543, -0.11165282130241394, -0.022470824420452118, 0.04644806683063507, -0.24064120650291443, -0.20718005299568176, -0.35158300399780273, 0.07825862616300583, -0.13239368796348572, 0.30181634426116943, 0.33695274591445923, -0.05148349702358246, -0.04496583342552185, 0.08708491921424866, 0.009431842714548111, -0.3074762225151062, 0.10922171175479889, 0.06724685430526733, -0.09767414629459381, -0.16778545081615448, -0.031178653240203857, 0.16373416781425476, -0.15336623787879944, -0.10178834199905396, 0.018867939710617065, -0.025721028447151184, -0.09120500832796097, 0.0005262754857540131, -0.10328740626573563, 0.07179252058267593, -0.05726458132266998, 0.044987231492996216, 0.1636723130941391, 0.1423007994890213, 0.18838359415531158, -0.2260555475950241, -0.16654512286186218, 0.008594350889325142, 0.02042624168097973, 0.04191477224230766, 0.2822258472442627, 0.033145785331726074, 0.17485517263412476, 0.07975368946790695, -0.07952393591403961, -0.07139661908149719, 0.09481584280729294, -0.2400960475206375, 0.020009739324450493, 0.2212105393409729, 0.047012027353048325, -0.07231135666370392, 0.07521508634090424, -0.12591442465782166, 0.48118898272514343, 0.08375507593154907, 0.07586540281772614, -0.037995293736457825, 0.07254542410373688, 0.0484606958925724, 0.08869190514087677, 0.3015648424625397, 0.11661666631698608, -0.006655074656009674, 0.21349264681339264, -0.13763688504695892, -0.06761374324560165, 0.31381481885910034, 0.1515582650899887, 0.029744599014520645, -0.21692180633544922, 0.21909871697425842, 0.18823380768299103, 0.25245893001556396, -0.24450214207172394, -0.16929958760738373, -0.027966435998678207, -0.16594155132770538, -0.28037163615226746, 0.010886956006288528, -0.06792803853750229, -0.0047065140679478645, 0.15151357650756836, -0.40196263790130615, 0.23597505688667297, -0.4156899154186249, -0.00852138176560402, 0.017556482926011086, 0.024831436574459076, 0.1341191828250885, 0.1460357904434204, -0.14805001020431519, 0.03027735836803913, 0.10777843743562698, -0.2900012731552124, -0.045128725469112396, -0.09109067916870117, 0.10731397569179535, 0.31546810269355774, -0.44791656732559204, -0.21642941236495972, 0.12141633033752441]}"
"{\"sha\": \"7b48b82bbc8f145d11cbaa19be107cb42074273e\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/cc_array.c\", \"func_name\": \"cc_array_add_at\", \"original_string\": \"enum cc_stat cc_array_add_at(CC_Array *ar, void *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * sizeof(void*);\\n\\n    memmove(&(ar->buffer[index + 1]),\\n            &(ar->buffer[index]),\\n            shift);\\n\\n    ar->buffer[index] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\", \"code_tokens\": [\"enum\", \"cc_stat\", \"cc_array_add_at\", \"(\", \"CC_Array\", \"*\", \"ar\", \",\", \"void\", \"*\", \"element\", \",\", \"size_t\", \"index\", \")\", \"{\", \"if\", \"(\", \"index\", \"==\", \"ar\", \"->\", \"size\", \")\", \"return\", \"cc_array_add\", \"(\", \"ar\", \",\", \"element\", \")\", \";\", \"if\", \"(\", \"(\", \"ar\", \"->\", \"size\", \"==\", \"0\", \"&&\", \"index\", \"!=\", \"0\", \")\", \"||\", \"index\", \">\", \"(\", \"ar\", \"->\", \"size\", \"-\", \"1\", \")\", \")\", \"return\", \"CC_ERR_OUT_OF_RANGE\", \";\", \"if\", \"(\", \"ar\", \"->\", \"size\", \">=\", \"ar\", \"->\", \"capacity\", \")\", \"{\", \"enum\", \"cc_stat\", \"status\", \"=\", \"expand_capacity\", \"(\", \"ar\", \")\", \";\", \"if\", \"(\", \"status\", \"!=\", \"CC_OK\", \")\", \"return\", \"status\", \";\", \"}\", \"size_t\", \"shift\", \"=\", \"(\", \"ar\", \"->\", \"size\", \"-\", \"index\", \")\", \"*\", \"sizeof\", \"(\", \"void\", \"*\", \")\", \";\", \"memmove\", \"(\", \"&\", \"(\", \"ar\", \"->\", \"buffer\", \"[\", \"index\", \"+\", \"1\", \"]\", \")\", \",\", \"&\", \"(\", \"ar\", \"->\", \"buffer\", \"[\", \"index\", \"]\", \")\", \",\", \"shift\", \")\", \";\", \"ar\", \"->\", \"buffer\", \"[\", \"index\", \"]\", \"=\", \"element\", \";\", \"ar\", \"->\", \"size\", \"++\", \";\", \"return\", \"CC_OK\", \";\", \"}\"], \"docstring\": \"/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Adds\", \"a\", \"new\", \"element\", \"to\", \"the\", \"array\", \"at\", \"a\", \"specified\", \"position\", \"by\", \"shifting\", \"all\", \"*\", \"subsequent\", \"elements\", \"by\", \"one\", \".\", \"The\", \"specified\", \"index\", \"must\", \"be\", \"within\", \"the\", \"bounds\", \"*\", \"of\", \"the\", \"array\", \".\", \"This\", \"function\", \"may\", \"also\", \"fail\", \"if\", \"the\", \"memory\", \"allocation\", \"for\", \"*\", \"the\", \"new\", \"element\", \"was\", \"unsuccessful\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"ar\", \"the\", \"array\", \"to\", \"which\", \"the\", \"element\", \"is\", \"being\", \"added\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"element\", \"the\", \"element\", \"that\", \"is\", \"being\", \"added\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"index\", \"the\", \"position\", \"in\", \"the\", \"array\", \"at\", \"which\", \"the\", \"element\", \"is\", \"being\", \"*\", \"added\", \"*\", \"*\", \"@return\", \"CC_OK\", \"if\", \"the\", \"element\", \"was\", \"successfully\", \"added\", \"CC_ERR_OUT_OF_RANGE\", \"if\", \"*\", \"the\", \"specified\", \"index\", \"was\", \"not\", \"in\", \"range\", \"CC_ERR_ALLOC\", \"if\", \"the\", \"memory\", \"*\", \"allocation\", \"for\", \"the\", \"new\", \"element\", \"failed\", \"or\", \"CC_ERR_MAX_CAPACITY\", \"if\", \"the\", \"*\", \"array\", \"is\", \"already\", \"at\", \"maximum\", \"capacity\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2014 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n#include \\\"cc_array.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\nstruct cc_array_s {\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    void   **buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_Array *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new(CC_Array **out)\\n{\\n    CC_ArrayConf c;\\n    cc_array_conf_init(&c);\\n    return cc_array_new_conf(&c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_Array based on the specified CC_ArrayConf struct and\\n * returns a status code.\\n *\\n * The CC_Array is allocated using the allocators specified in the CC_ArrayConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArrayConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new_conf(CC_ArrayConf const * const conf, CC_Array **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_Array *ar = conf->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    void **buff = conf->mem_alloc(conf->capacity * sizeof(void*));\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->buffer     = buff;\\n    ar->exp_factor = ex;\\n    ar->capacity   = conf->capacity;\\n    ar->mem_alloc  = conf->mem_alloc;\\n    ar->mem_calloc = conf->mem_calloc;\\n    ar->mem_free   = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArrayConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArrayConf structure that is being initialized\\n */\\nvoid cc_array_conf_init(CC_ArrayConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_Array structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_destroy(CC_Array *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n/**\\n * Destroys the CC_Array structure along with all the data it holds.\\n *\\n * @note\\n * This function should not be called on a array that has some of its elements\\n * allocated on the stack.\\n *\\n * @param[in] ar the array that is being destroyed\\n */\\nvoid cc_array_destroy_cb(CC_Array *ar, void (*cb) (void*))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        cb(ar->buffer[i]);\\n\\n    cc_array_destroy(ar);\\n}\\n\\n/**\\n * Adds a new element to the CC_Array. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_Array.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add(CC_Array *ar, void *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    ar->buffer[ar->size] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add_at(CC_Array *ar, void *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * sizeof(void*);\\n\\n    memmove(&(ar->buffer[index + 1]),\\n            &(ar->buffer[index]),\\n            shift);\\n\\n    ar->buffer[index] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_Array.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_replace_at(CC_Array *ar, void *element, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    ar->buffer[index] = element;\\n\\n    return CC_OK;\\n}\\n\\nenum cc_stat cc_array_swap_at(CC_Array *ar, size_t index1, size_t index2)\\n{\\n    void *tmp;\\n\\n    if (index1 >= ar->size || index2 >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    tmp = ar->buffer[index1];\\n\\n    ar->buffer[index1] = ar->buffer[index2];\\n    ar->buffer[index2] = tmp;\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_Array if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_remove(CC_Array *ar, void *element, void **out)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    if (out)\\n        *out = element;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_remove_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_remove_last(CC_Array *ar, void **out)\\n{\\n    return cc_array_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all(CC_Array *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Removes and frees all elements from the specified array. This function does\\n * not shrink the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all_free(CC_Array *ar)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        free(ar->buffer[i]);\\n\\n    cc_array_remove_all(ar);\\n}\\n\\n/**\\n * Gets an CC_Array element from the specified index and sets the out parameter to\\n * its value. The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] index the index of the array element\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_get_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    *out = ar->buffer[index];\\n    return CC_OK;\\n}\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_get_last(CC_Array *ar, void **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    return cc_array_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst void * const* cc_array_get_buffer(CC_Array *ar)\\n{\\n    return (const void* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_Array.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_index_of(CC_Array *ar, void *element, size_t *index)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element) {\\n            *index = i;\\n            return CC_OK;\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_Array, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_Array, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_subarray(CC_Array *ar, size_t b, size_t e, CC_Array **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_Array *sub_ar = ar->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * sizeof(void*)))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc  = ar->mem_alloc;\\n    sub_ar->mem_calloc = ar->mem_calloc;\\n    sub_ar->mem_free   = ar->mem_free;\\n    sub_ar->size       = e - b + 1;\\n    sub_ar->capacity   = sub_ar->size;\\n\\n    memcpy(sub_ar->buffer,\\n           &(ar->buffer[b]),\\n           sub_ar->size * sizeof(void*));\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a shallow copy of the specified CC_Array. A shallow copy is a copy of\\n * the CC_Array structure, but not the elements it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_shallow(CC_Array *ar, CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * sizeof(void*));\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a deep copy of the specified CC_Array. A deep copy is a copy of\\n * both the CC_Array structure and the data it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar   array to be copied\\n * @param[in] cp   the copy function that should return a pointer to the copy of\\n *                 the data\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_deep(CC_Array *ar, void *(*cp) (void *), CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    size_t i;\\n    for (i = 0; i < copy->size; i++)\\n        copy->buffer[i] = cp(ar->buffer[i]);\\n\\n    *out = copy;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty.\\n */\\nenum cc_stat cc_array_filter_mut(CC_Array *ar, bool (*pred) (const void*))\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(ar->buffer[i])) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * sizeof(void*);\\n                memmove(&(ar->buffer[i + 1]),\\n                        &(ar->buffer[i + 1 + rm]),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * sizeof(void*);\\n        memmove(&(ar->buffer[0]),\\n                &(ar->buffer[rm]),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by creating a new CC_Array that contains all elements from the\\n * original CC_Array that return true on pred(element) without modifying the original\\n * CC_Array.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_filter(CC_Array *ar, bool (*pred) (const void*), CC_Array **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    CC_Array *filtered = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!filtered)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->exp_factor = ar->exp_factor;\\n    filtered->size       = 0;\\n    filtered->capacity   = ar->capacity;\\n    filtered->mem_alloc  = ar->mem_alloc;\\n    filtered->mem_calloc = ar->mem_calloc;\\n    filtered->mem_free   = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(ar->buffer[i])) {\\n            filtered->buffer[f++] = ar->buffer[i];\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_reverse(CC_Array *ar)\\n{\\n    if (ar->size == 0)\\n        return;\\n\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        void *tmp = ar->buffer[i];\\n        ar->buffer[i] = ar->buffer[j];\\n        ar->buffer[j] = tmp;\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_Array, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_trim_capacity(CC_Array *ar)\\n{\\n    if (ar->size == ar->capacity)\\n        return CC_OK;\\n\\n    void **new_buff = ar->mem_calloc(ar->size, sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * sizeof(void*));\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_contains(CC_Array *ar, void *element)\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the number of occurrences of the value pointed to by <code>e</code>\\n * within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n * @param[in] cmp comparator function which returns 0 if the values passed to it are equal\\n *\\n * @return the number of occurrences of the value.\\n */\\nsize_t cc_array_contains_value(CC_Array *ar, void *element, int (*cmp) (const void*, const void*))\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (cmp(element, ar->buffer[i]) == 0)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_Array. The size of the array is the\\n * number of elements contained within the CC_Array.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_Array.\\n */\\nsize_t cc_array_size(CC_Array *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_Array. The capacity of the CC_Array is\\n * the maximum number of elements an CC_Array can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_Array.\\n */\\nsize_t cc_array_capacity(CC_Array *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sort(CC_Array *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, sizeof(void*), cmp);\\n}\\n\\n/**\\n * Expands the CC_Array capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_Array *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS)\\n        return CC_ERR_MAX_CAPACITY;\\n\\n    size_t new_capacity = (size_t)(ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity)\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    else\\n        ar->capacity = new_capacity;\\n\\n    void **new_buff = ar->mem_alloc(ar->capacity * sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    memcpy(new_buff, ar->buffer, ar->size * sizeof(void*));\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_map(CC_Array *ar, void (*fn) (void *e))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        fn(ar->buffer[i]);\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_reduce(CC_Array *ar, void (*fn) (void*, void*, void*), void *result)\\n{\\n    if (ar->size == 1) {\\n        fn(ar->buffer[0], NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1)\\n        fn(ar->buffer[0], ar->buffer[1], result);\\n\\n    for (size_t i = 2; i < ar->size; i++)\\n        fn(result, ar->buffer[i], result);\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_iter_init(CC_ArrayIter *iter, CC_Array *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the value of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_iter_next(CC_ArrayIter *iter, void **out)\\n{\\n    if (iter->index >= iter->ar->size)\\n        return CC_ITER_END;\\n\\n    *out = iter->ar->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_iter_remove(CC_ArrayIter *iter, void **out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK)\\n            iter->last_removed = true;\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_Array after the last returned element by\\n * <code>cc_array_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_iter_add(CC_ArrayIter *iter, void *element)\\n{\\n    return cc_array_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_iter_replace(CC_ArrayIter *iter, void *element, void **out)\\n{\\n    return cc_array_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_iter_index(CC_ArrayIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_zip_iter_init(CC_ArrayZipIter *iter, CC_Array *ar1, CC_Array *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_zip_iter_next(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size)\\n        return CC_ITER_END;\\n\\n    *out1 = iter->ar1->buffer[iter->index];\\n    *out2 = iter->ar2->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_zip_iter_remove(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (!iter->last_removed) {\\n        cc_array_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_zip_iter_add(CC_ArrayZipIter *iter, void *e1, void *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_Array  *ar1  = iter->ar1;\\n    CC_Array  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n            (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK)))\\n        return CC_ERR_ALLOC;\\n\\n    cc_array_add_at(ar1, e1, index);\\n    cc_array_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_zip_iter_replace(CC_ArrayZipIter *iter, void *e1, void *e2, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    cc_array_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_zip_iter_index(CC_ArrayZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_struct_size()\\n{\\n    return sizeof(CC_Array);\\n}\", \"embeddings\": [0.04584807902574539, 0.027625136077404022, 0.014483578503131866, 0.13413174450397491, 0.4464394152164459, -0.161369189620018, 0.13583607971668243, 0.4447841942310333, -0.1247653216123581, -0.31244218349456787, 0.04437825456261635, -0.20657041668891907, 0.07363730669021606, 0.09312446415424347, -0.0037826448678970337, -0.030239112675189972, -0.013048307038843632, -0.08133191615343094, 0.07915891706943512, -0.4720239043235779, -0.21365030109882355, 0.11297249794006348, 0.15309298038482666, 0.16277754306793213, 0.18995410203933716, 0.08086000382900238, 0.1416316032409668, 0.13435477018356323, 0.4939311146736145, -0.17073844373226166, 0.053410258144140244, -0.13740086555480957, 0.08334913849830627, -0.1880791336297989, 0.060348108410835266, -0.039638496935367584, -0.013854287564754486, 0.11621652543544769, -0.02733398601412773, -0.008246652781963348, -0.2348596751689911, 0.03845524787902832, 0.06025002524256706, 0.19571980834007263, 0.18965590000152588, -0.03776717185974121, 0.11423453688621521, 0.2600264251232147, -0.04371577873826027, 0.09712263941764832, 0.06915313005447388, -0.11484381556510925, 0.08293190598487854, -0.141900897026062, -0.061079975217580795, -0.13400894403457642, -0.027349557727575302, 0.3548121452331543, 0.050257258117198944, -0.02078932523727417, -0.11868450045585632, -0.26996856927871704, -0.19562706351280212, 0.143710657954216, 0.14388513565063477, 0.05187833309173584, -0.1738397479057312, -0.17867963016033173, 0.07588563859462738, -0.03381519019603729, 0.13839274644851685, 0.20346777141094208, 0.11696964502334595, -0.13168348371982574, -0.20483575761318207, -0.06029726564884186, 0.01060841977596283, 0.4583267271518707, -0.06465877592563629, 0.2152554839849472, 0.2533649206161499, -0.0698002427816391, 0.2553846538066864, 0.28304070234298706, 0.2157527208328247, -0.027487896382808685, -0.1471538543701172, 0.18040922284126282, -0.06410317122936249, 0.21696539223194122, 0.05128692463040352, 0.1777767539024353, -0.1402493715286255, -0.12862712144851685, -0.04575116187334061, -0.07629425823688507, 0.06108051538467407, -0.09258250892162323, 0.06817903369665146, 0.5059789419174194, -0.05123291537165642, -0.15057682991027832, -0.35857394337654114, -0.2415226697921753, -0.0941958948969841, 0.06526349484920502, -0.1622532308101654, 0.07337924093008041, 0.11065931618213654, 0.016896795481443405, 0.1688835471868515, 0.013499893248081207, 0.011483175680041313, 0.004752397537231445, -0.04289761930704117, -0.12230091542005539, 0.09716726839542389, 0.015278827399015427, 0.23368215560913086, -0.17435342073440552, 0.137911856174469, -0.032054923474788666, 0.062365055084228516, -0.06997986137866974, -0.12405262887477875, -0.041383687406778336, 0.03739440068602562, -0.3021489083766937, 0.08712132275104523, 0.013430237770080566, -0.059481166303157806, -0.10282457619905472, 0.00668112188577652, 0.055866267532110214, 0.20944587886333466, -0.023216303437948227, 0.24951937794685364, -0.06195235997438431, 0.11875194311141968, 0.017581559717655182, -0.06665893644094467, 0.029187321662902832, 0.23855163156986237, 0.01615060865879059, 0.18042287230491638, -0.19598475098609924, 0.19128882884979248, 0.09204751253128052, -0.42772555351257324, -0.25081712007522583, -0.019184216856956482, -0.12996847927570343, -0.01900738663971424, 0.049108292907476425, -0.15196776390075684, 0.7876315712928772, 0.08400867134332657, -0.20799946784973145, -0.08466652035713196, -0.04069945961236954, 0.01164310798048973, -0.27143195271492004, -0.11408887803554535, 0.21166199445724487, 0.06762779504060745, 0.12800957262516022, 0.09388482570648193, 0.12412232160568237, 0.2539973258972168, 0.00704164057970047, 0.14104390144348145, -0.16133306920528412, -0.026074402034282684, 0.13993299007415771, 0.023318927735090256, -0.10438591986894608, -0.10453714430332184, 0.08278274536132812, -0.008001682348549366, 0.051233887672424316, -0.123016357421875, -0.007121860980987549, -0.1957124024629593, 0.023835361003875732, -0.1928122639656067, -0.023591067641973495, -0.0287577286362648, -0.0447806641459465, 0.03574422001838684, -0.023987902328372, 0.14447948336601257, 0.0011055003851652145, 0.19280540943145752, -0.12943729758262634, -0.09681744128465652, 0.09746897965669632, -0.12306343764066696, -0.017550086602568626, 0.35429027676582336, -0.038243792951107025, 0.007799122482538223, -0.2347373068332672, 0.27298179268836975, -0.07561196386814117, 0.010634876787662506, 0.158875972032547, -0.22895212471485138, -0.06396942585706711, -0.05144989863038063, -0.1916443407535553, -0.12426231801509857, 0.16134923696517944, 0.1439296007156372, 0.04100160673260689, -0.033767905086278915, -0.08705154061317444, 0.08144591748714447, 0.22385163605213165, 0.11437202990055084, -0.031020542606711388, 0.176356703042984, 0.2279495894908905, -0.1096639409661293, -0.07076756656169891, -0.21359790861606598, 0.06749279052019119, 0.2462153136730194, 0.14068856835365295, -0.01157832145690918, 0.1193050891160965, 0.1257731020450592, 0.2669515013694763, -0.2907510995864868, 0.17004069685935974, -0.04176829010248184, -0.15454544126987457, -0.03893832117319107, -0.01773613691329956, -0.07242385298013687, -0.1851407289505005, -0.001364290714263916, 0.21554194390773773, 0.16205252707004547, 0.3261038661003113, 0.05616738647222519, -0.005776248872280121, -0.16348977386951447, -0.044892534613609314, -0.15491075813770294, 0.12845231592655182, 0.022634929046034813, -0.11609824746847153, -0.07583247870206833, -0.14509616792201996, -0.09378376603126526, 0.0014564953744411469, -0.1445319503545761, -0.08150479197502136, 0.08879522234201431, 0.19941505789756775, 0.043501485139131546, -0.029442360624670982, 0.13481587171554565, -0.04756494611501694, -0.24153080582618713, -0.4862748086452484, -0.0582575723528862, 0.1484033465385437, 0.0799628347158432, -0.040049415081739426, 0.16428369283676147, -0.07198146730661392, 0.26524782180786133, 0.13876453042030334, 0.05235330015420914, -0.06766606867313385, -0.14916400611400604, -0.10800223052501678, -0.2111409604549408, 0.05551091581583023, 0.02820010855793953, 0.11047807335853577, -0.24535222351551056, 0.06800553947687149, 0.12317873537540436, 0.061685286462306976, 0.24038688838481903, -0.008421061560511589, 0.02731924317777157, 0.015498086810112, 0.08016394823789597, 0.10674003511667252, 0.11475912481546402, 0.1472906470298767, 0.09172213077545166, 0.07100825011730194, 0.24537725746631622, -0.04146692156791687, 0.06988745927810669, -0.38489046692848206, 0.16230562329292297, -0.2866266965866089, 0.017763376235961914, 0.01123273279517889, 0.36053499579429626, 0.006461461074650288, -0.05433565378189087, 0.06944802403450012, 0.21741831302642822, 0.04502079635858536, 0.16669432818889618, 0.12961745262145996, -0.1549656093120575, 0.10721994936466217, -0.09262503683567047, 0.15166476368904114, -0.13179726898670197, -0.06791092455387115, 0.15675683319568634, 0.0018948167562484741, -0.1565365195274353, 0.1707967221736908, 0.32676851749420166, 0.12932489812374115, 0.07582497596740723, 0.033488497138023376, 0.08498939871788025, -0.1163427084684372, -0.25711581110954285, 0.6305396556854248, -0.34066885709762573, 0.19202235341072083, -0.2794133424758911, 0.5361244678497314, -0.07224279642105103, 0.40404456853866577, -0.007401309907436371, 0.08114873617887497, 0.10784086585044861, 0.20263618230819702, -0.18418991565704346, -0.1794968992471695, -0.1647242158651352, 0.2997124493122101, 0.20720987021923065, 0.20683553814888, 0.22203950583934784, -0.050936851650476456, 0.13442103564739227, -0.054710280150175095, -0.07448229193687439, 0.1581422984600067, 0.010875683277845383, -0.05104609578847885, 0.14416804909706116, 0.433714896440506, -0.23466181755065918, -0.012874584645032883, -0.014197532087564468, -0.0006687869317829609, 0.22067007422447205, -0.4369775950908661, 0.15917855501174927, -0.05219864100217819, 0.30112308263778687, -0.5614005327224731, -0.3973487615585327, 0.00930534116923809, -0.13525038957595825, 0.04726676642894745, 0.20843160152435303, 0.13809239864349365, 0.18082237243652344, -0.2237725406885147, 0.12850384414196014, -0.0687805563211441, -0.12417411804199219, -0.002905838191509247, -0.016730189323425293, 0.10925184190273285, 0.0671440064907074, 0.12895667552947998, 0.04276979714632034, 0.03909209743142128, 0.11925250291824341, -0.14187631011009216, 0.207743838429451, 0.24351435899734497, 0.22598829865455627, -0.10209989547729492, 0.1592492163181305, -0.2579452097415924, 0.10982108116149902, -0.09518760442733765, 0.037343062460422516, -0.01177779957652092, -0.06306782364845276, 0.15093813836574554, -0.04378119111061096, -0.17370159924030304, 0.12705011665821075, 0.2623208165168762, -0.09453935921192169, 0.15397241711616516, 0.09994949400424957, -0.06184423714876175, 0.12407989799976349, -0.1933191567659378, -0.15691065788269043, -0.1290867179632187, 0.06776036322116852, 0.07366400957107544, 0.09229280799627304, 0.05168690159916878, 0.19723480939865112, -0.16050364077091217, 0.17224109172821045, -0.39678502082824707, -0.20306718349456787, 0.2602078914642334, 0.23848333954811096, 0.1495295763015747, 0.08888640999794006, -0.26288902759552, -0.0870814323425293, -0.016911305487155914, -0.006255805492401123, -0.095002681016922, 0.0519503615796566, -0.21403822302818298, 0.030975624918937683, 0.2773621678352356, 0.14453326165676117, 0.13854387402534485, 0.093170665204525, 0.022248078137636185, -0.10119915008544922, 0.02654740959405899, 0.07614661753177643, 0.0686551183462143, -0.086101233959198, 0.13534927368164062, 0.06368178129196167, 0.05215105414390564, 0.07115969061851501, -0.05536077916622162, 0.4677063226699829, 0.1348479986190796, -0.051653243601322174, 0.14459893107414246, -0.11941017210483551, 0.03963201493024826, -0.11025290191173553, -0.26436829566955566, 0.21170568466186523, 0.25914207100868225, 0.11883921921253204, 0.1113797202706337, 0.1295856535434723, 0.007976673543453217, 0.022768404334783554, 0.06143315136432648, -0.15745992958545685, -0.14475567638874054, -0.0347159281373024, -0.09347362071275711, 0.059878017753362656, 0.084930419921875, 0.2064260095357895, 0.08485791087150574, 0.17208868265151978, 0.24235856533050537, 0.03786076605319977, -0.0365707203745842, -0.016537677496671677, 0.03919292613863945, -0.12048783898353577, -0.31079110503196716, 0.11368513852357864, -0.18552447855472565, 0.03677665814757347, 0.04474940150976181, 0.1770159900188446, 0.04721250757575035, 0.08615901321172714, -0.16285830736160278, 0.3566873073577881, 0.12047266960144043, -0.15974612534046173, -0.020117629319429398, -0.08245280385017395, 0.2356109917163849, 0.07223974168300629, 0.1663537472486496, 0.2564743757247925, 0.14240428805351257, 0.0044176578521728516, 0.1717342883348465, 0.3189525008201599, -0.11932636797428131, 0.009696312248706818, 0.1287669688463211, -0.007610350847244263, -0.14223797619342804, -0.198076531291008, -0.15177670121192932, -0.09023451805114746, 0.13583973050117493, 0.19279681146144867, -0.1700035035610199, -0.07769031822681427, -0.08234124630689621, 0.15110254287719727, 0.0013017505407333374, 0.06805576384067535, 0.09445293247699738, -0.020470991730690002, 0.03345567733049393, -0.10238185524940491, 0.4352940618991852, -0.09506538510322571, -0.12852497398853302, -0.10450564324855804, -0.07353194802999496, -0.02207438088953495, 0.020765084773302078, 0.13616988062858582, 0.05823231488466263, 0.1533885896205902, 0.10629426687955856, 0.09731888771057129, -0.06929118931293488, 0.09378362447023392, 0.24940094351768494, -0.1441662460565567, 0.016574518755078316, 0.07574410736560822, 0.05363251641392708, 0.2226586490869522, -0.0898955762386322, -0.27367010712623596, -0.04041018337011337, 0.20730793476104736, -0.09069277346134186, 0.1781616061925888, 0.03552345186471939, 0.20519721508026123, 0.09280803799629211, -0.017594240605831146, 0.016703877598047256, -0.05145428702235222, -0.6972261667251587, -0.0220891572535038, 0.1845615953207016, -0.08025656640529633, 0.05259878933429718, 0.26414716243743896, 0.04737862944602966, 0.07247219979763031, 0.1609555333852768, 0.030088139697909355, -0.00810154527425766, 0.16100925207138062, 0.20519308745861053, -0.05083068460226059, -0.1381508708000183, 0.09048281610012054, 0.14447446167469025, -0.2861587405204773, 0.254372239112854, -0.11246978491544724, -0.20334619283676147, 0.027092963457107544, 0.3862901031970978, 0.02659723162651062, -0.006249923259019852, 0.21510496735572815, 0.04695497453212738, 0.3019866943359375, -0.061406463384628296, 0.06018143892288208, 0.4598991870880127, 0.18129539489746094, -0.29172274470329285, 0.04998592659831047, 0.10786285251379013, 0.1632806658744812, -0.059269994497299194, 13.850351333618164, -0.03759022802114487, 0.28589361906051636, -0.30678194761276245, -0.06550326198339462, 0.03430061787366867, -0.08858770877122879, 0.02390287071466446, -0.054295048117637634, -0.09035608172416687, 0.10395292937755585, -0.09905584901571274, -0.00948648527264595, -0.007225539535284042, -0.10475632548332214, -0.15027613937854767, -0.13218286633491516, -0.13225390017032623, 0.19667798280715942, -0.03884118050336838, -0.25881239771842957, -0.22186945378780365, -0.061300963163375854, -0.534833550453186, -0.05464017018675804, -0.05974891036748886, 0.1794039011001587, 0.09212402254343033, -0.050406552851200104, 0.02352355420589447, 0.27273327112197876, 0.15195943415164948, 0.10155703872442245, 0.009281143546104431, 0.04165485501289368, -0.06274262815713882, -0.4113919734954834, -0.17855645716190338, 0.14542703330516815, 0.042269203811883926, 0.006722539663314819, -0.01851857453584671, 0.2263464629650116, -0.07740401476621628, 0.12670131027698517, 0.1490497589111328, -0.35643649101257324, 0.20101667940616608, -0.20709607005119324, -0.10444769263267517, 0.2412986159324646, 0.1434459090232849, 0.3652651309967041, 0.13048765063285828, -0.20246997475624084, -0.32188522815704346, 0.34412330389022827, -0.10168729722499847, -0.09962712228298187, 0.46823108196258545, -0.06109399348497391, -0.15896549820899963, -0.04868375137448311, 0.05766786262392998, 0.07305562496185303, 0.008447028696537018, 0.039388127624988556, -0.028331995010375977, -0.2775418758392334, 0.10665395855903625, 0.32819226384162903, -0.20839117467403412, 0.2166905701160431, 0.002448062412440777, 0.030852332711219788, 0.05732286721467972, 0.004482261836528778, -0.07800692319869995, 0.10320962220430374, -0.07755935192108154, -0.008717603981494904, 0.057472895830869675, -0.28996190428733826, -0.1884794533252716, -0.40740257501602173, 0.06435606628656387, -0.14062681794166565, 0.3433438539505005, 0.3025248646736145, -0.07313191890716553, -0.04451454058289528, 0.13503313064575195, 0.04169870913028717, -0.3357812166213989, 0.11928611248731613, 0.04625435173511505, -0.2040540724992752, -0.21769818663597107, 0.0017009079456329346, 0.18883943557739258, -0.05474283546209335, -0.04357021674513817, 0.013480596244335175, -0.07834610342979431, -0.09670993685722351, 0.02219044417142868, -0.13415515422821045, 0.0010259002447128296, 0.013907130807638168, 0.06861691176891327, 0.1517355591058731, 0.15467259287834167, 0.1765209287405014, -0.24708192050457, -0.12987789511680603, -0.022090047597885132, 0.016273176297545433, 0.04036545008420944, 0.22883954644203186, 0.035786181688308716, 0.2557745575904846, 0.09725628793239594, -0.04442108795046806, -0.02705368772149086, 0.07723237574100494, -0.25293615460395813, -0.01061292365193367, 0.21249210834503174, 0.07224756479263306, -0.07781977951526642, 0.09339582175016403, -0.11366169899702072, 0.5224871039390564, 0.10922915488481522, 0.09717632830142975, -0.07255783677101135, 0.017763294279575348, 0.008979946374893188, 0.10828782618045807, 0.2682952284812927, 0.07621529698371887, -0.03438299149274826, 0.19481417536735535, -0.15359489619731903, -0.11479151248931885, 0.3141624331474304, 0.11824971437454224, 0.0656568855047226, -0.24265968799591064, 0.22702908515930176, 0.10150923579931259, 0.27358776330947876, -0.27009332180023193, -0.09010574221611023, -0.10029181838035583, -0.1693395972251892, -0.26489022374153137, 0.012800734490156174, -0.049303777515888214, -0.05445489659905434, 0.16093122959136963, -0.3696836233139038, 0.2162913829088211, -0.4487042725086212, -0.05415104329586029, 0.029348406940698624, 0.031343698501586914, 0.12388172745704651, 0.15090841054916382, -0.15400803089141846, 0.02483719028532505, 0.09587492048740387, -0.18059904873371124, 0.007520671933889389, -0.0853845477104187, 0.13996295630931854, 0.364791601896286, -0.42823272943496704, -0.17217624187469482, 0.11814691126346588]}"
"{\"sha\": \"7b48b82bbc8f145d11cbaa19be107cb42074273e\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/cc_array.c\", \"func_name\": \"cc_array_replace_at\", \"original_string\": \"enum cc_stat cc_array_replace_at(CC_Array *ar, void *element, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    ar->buffer[index] = element;\\n\\n    return CC_OK;\\n}\", \"code_tokens\": [\"enum\", \"cc_stat\", \"cc_array_replace_at\", \"(\", \"CC_Array\", \"*\", \"ar\", \",\", \"void\", \"*\", \"element\", \",\", \"size_t\", \"index\", \",\", \"void\", \"*\", \"*\", \"out\", \")\", \"{\", \"if\", \"(\", \"index\", \">=\", \"ar\", \"->\", \"size\", \")\", \"return\", \"CC_ERR_OUT_OF_RANGE\", \";\", \"if\", \"(\", \"out\", \")\", \"*\", \"out\", \"=\", \"ar\", \"->\", \"buffer\", \"[\", \"index\", \"]\", \";\", \"ar\", \"->\", \"buffer\", \"[\", \"index\", \"]\", \"=\", \"element\", \";\", \"return\", \"CC_OK\", \";\", \"}\"], \"docstring\": \"/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_Array.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Replaces\", \"an\", \"array\", \"element\", \"at\", \"the\", \"specified\", \"index\", \"and\", \"optionally\", \"sets\", \"the\", \"out\", \"*\", \"parameter\", \"to\", \"the\", \"value\", \"of\", \"the\", \"replaced\", \"element\", \".\", \"The\", \"specified\", \"index\", \"must\", \"be\", \"*\", \"within\", \"the\", \"bounds\", \"of\", \"the\", \"CC_Array\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"ar\", \"array\", \"whose\", \"element\", \"is\", \"being\", \"replaced\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"element\", \"replacement\", \"element\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"index\", \"index\", \"at\", \"which\", \"the\", \"replacement\", \"element\", \"should\", \"be\", \"inserted\", \"*\", \"@param\", \"[\", \"out\", \"]\", \"out\", \"pointer\", \"to\", \"where\", \"the\", \"replaced\", \"element\", \"is\", \"stored\", \"or\", \"NULL\", \"if\", \"*\", \"it\", \"is\", \"to\", \"be\", \"ignored\", \"*\", \"*\", \"@return\", \"CC_OK\", \"if\", \"the\", \"element\", \"was\", \"successfully\", \"replaced\", \"or\", \"CC_ERR_OUT_OF_RANGE\", \"*\", \"if\", \"the\", \"index\", \"was\", \"out\", \"of\", \"range\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2014 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n#include \\\"cc_array.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\nstruct cc_array_s {\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    void   **buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_Array *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new(CC_Array **out)\\n{\\n    CC_ArrayConf c;\\n    cc_array_conf_init(&c);\\n    return cc_array_new_conf(&c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_Array based on the specified CC_ArrayConf struct and\\n * returns a status code.\\n *\\n * The CC_Array is allocated using the allocators specified in the CC_ArrayConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArrayConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_Array is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_Array structure failed.\\n */\\nenum cc_stat cc_array_new_conf(CC_ArrayConf const * const conf, CC_Array **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_Array *ar = conf->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    void **buff = conf->mem_alloc(conf->capacity * sizeof(void*));\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->buffer     = buff;\\n    ar->exp_factor = ex;\\n    ar->capacity   = conf->capacity;\\n    ar->mem_alloc  = conf->mem_alloc;\\n    ar->mem_calloc = conf->mem_calloc;\\n    ar->mem_free   = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArrayConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArrayConf structure that is being initialized\\n */\\nvoid cc_array_conf_init(CC_ArrayConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_Array structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_destroy(CC_Array *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n/**\\n * Destroys the CC_Array structure along with all the data it holds.\\n *\\n * @note\\n * This function should not be called on a array that has some of its elements\\n * allocated on the stack.\\n *\\n * @param[in] ar the array that is being destroyed\\n */\\nvoid cc_array_destroy_cb(CC_Array *ar, void (*cb) (void*))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        cb(ar->buffer[i]);\\n\\n    cc_array_destroy(ar);\\n}\\n\\n/**\\n * Adds a new element to the CC_Array. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_Array.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add(CC_Array *ar, void *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    ar->buffer[ar->size] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_add_at(CC_Array *ar, void *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * sizeof(void*);\\n\\n    memmove(&(ar->buffer[index + 1]),\\n            &(ar->buffer[index]),\\n            shift);\\n\\n    ar->buffer[index] = element;\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_Array.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_replace_at(CC_Array *ar, void *element, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    ar->buffer[index] = element;\\n\\n    return CC_OK;\\n}\\n\\nenum cc_stat cc_array_swap_at(CC_Array *ar, size_t index1, size_t index2)\\n{\\n    void *tmp;\\n\\n    if (index1 >= ar->size || index2 >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    tmp = ar->buffer[index1];\\n\\n    ar->buffer[index1] = ar->buffer[index2];\\n    ar->buffer[index2] = tmp;\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_Array if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_remove(CC_Array *ar, void *element, void **out)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    if (out)\\n        *out = element;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_remove_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (out)\\n        *out = ar->buffer[index];\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * sizeof(void*);\\n\\n        memmove(&(ar->buffer[index]),\\n                &(ar->buffer[index + 1]),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_Array element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_remove_last(CC_Array *ar, void **out)\\n{\\n    return cc_array_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all(CC_Array *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Removes and frees all elements from the specified array. This function does\\n * not shrink the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_remove_all_free(CC_Array *ar)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        free(ar->buffer[i]);\\n\\n    cc_array_remove_all(ar);\\n}\\n\\n/**\\n * Gets an CC_Array element from the specified index and sets the out parameter to\\n * its value. The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] index the index of the array element\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_get_at(CC_Array *ar, size_t index, void **out)\\n{\\n    if (index >= ar->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    *out = ar->buffer[index];\\n    return CC_OK;\\n}\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_get_last(CC_Array *ar, void **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    return cc_array_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst void * const* cc_array_get_buffer(CC_Array *ar)\\n{\\n    return (const void* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_Array.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_index_of(CC_Array *ar, void *element, size_t *index)\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element) {\\n            *index = i;\\n            return CC_OK;\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_Array, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_Array, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_subarray(CC_Array *ar, size_t b, size_t e, CC_Array **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_Array *sub_ar = ar->mem_calloc(1, sizeof(CC_Array));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * sizeof(void*)))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc  = ar->mem_alloc;\\n    sub_ar->mem_calloc = ar->mem_calloc;\\n    sub_ar->mem_free   = ar->mem_free;\\n    sub_ar->size       = e - b + 1;\\n    sub_ar->capacity   = sub_ar->size;\\n\\n    memcpy(sub_ar->buffer,\\n           &(ar->buffer[b]),\\n           sub_ar->size * sizeof(void*));\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a shallow copy of the specified CC_Array. A shallow copy is a copy of\\n * the CC_Array structure, but not the elements it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_shallow(CC_Array *ar, CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * sizeof(void*));\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a deep copy of the specified CC_Array. A deep copy is a copy of\\n * both the CC_Array structure and the data it holds.\\n *\\n * @note The new CC_Array is allocated using the original CC_Array's allocators\\n *       and it also inherits the configuration of the original CC_Array.\\n *\\n * @param[in] ar   array to be copied\\n * @param[in] cp   the copy function that should return a pointer to the copy of\\n *                 the data\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_copy_deep(CC_Array *ar, void *(*cp) (void *), CC_Array **out)\\n{\\n    CC_Array *copy = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    copy->exp_factor = ar->exp_factor;\\n    copy->size       = ar->size;\\n    copy->capacity   = ar->capacity;\\n    copy->mem_alloc  = ar->mem_alloc;\\n    copy->mem_calloc = ar->mem_calloc;\\n    copy->mem_free   = ar->mem_free;\\n\\n    size_t i;\\n    for (i = 0; i < copy->size; i++)\\n        copy->buffer[i] = cp(ar->buffer[i]);\\n\\n    *out = copy;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty.\\n */\\nenum cc_stat cc_array_filter_mut(CC_Array *ar, bool (*pred) (const void*))\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(ar->buffer[i])) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * sizeof(void*);\\n                memmove(&(ar->buffer[i + 1]),\\n                        &(ar->buffer[i + 1 + rm]),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * sizeof(void*);\\n        memmove(&(ar->buffer[0]),\\n                &(ar->buffer[rm]),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_Array by creating a new CC_Array that contains all elements from the\\n * original CC_Array that return true on pred(element) without modifying the original\\n * CC_Array.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_filter(CC_Array *ar, bool (*pred) (const void*), CC_Array **out)\\n{\\n    if (ar->size == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    CC_Array *filtered = ar->mem_alloc(sizeof(CC_Array));\\n\\n    if (!filtered)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, sizeof(void*)))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->exp_factor = ar->exp_factor;\\n    filtered->size       = 0;\\n    filtered->capacity   = ar->capacity;\\n    filtered->mem_alloc  = ar->mem_alloc;\\n    filtered->mem_calloc = ar->mem_calloc;\\n    filtered->mem_free   = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(ar->buffer[i])) {\\n            filtered->buffer[f++] = ar->buffer[i];\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_reverse(CC_Array *ar)\\n{\\n    if (ar->size == 0)\\n        return;\\n\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        void *tmp = ar->buffer[i];\\n        ar->buffer[i] = ar->buffer[j];\\n        ar->buffer[j] = tmp;\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_Array, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_trim_capacity(CC_Array *ar)\\n{\\n    if (ar->size == ar->capacity)\\n        return CC_OK;\\n\\n    void **new_buff = ar->mem_calloc(ar->size, sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * sizeof(void*));\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_contains(CC_Array *ar, void *element)\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (ar->buffer[i] == element)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the number of occurrences of the value pointed to by <code>e</code>\\n * within the specified CC_Array.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n * @param[in] cmp comparator function which returns 0 if the values passed to it are equal\\n *\\n * @return the number of occurrences of the value.\\n */\\nsize_t cc_array_contains_value(CC_Array *ar, void *element, int (*cmp) (const void*, const void*))\\n{\\n    size_t o = 0;\\n    size_t i;\\n    for (i = 0; i < ar->size; i++) {\\n        if (cmp(element, ar->buffer[i]) == 0)\\n            o++;\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_Array. The size of the array is the\\n * number of elements contained within the CC_Array.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_Array.\\n */\\nsize_t cc_array_size(CC_Array *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_Array. The capacity of the CC_Array is\\n * the maximum number of elements an CC_Array can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_Array.\\n */\\nsize_t cc_array_capacity(CC_Array *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sort(CC_Array *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, sizeof(void*), cmp);\\n}\\n\\n/**\\n * Expands the CC_Array capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_Array *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS)\\n        return CC_ERR_MAX_CAPACITY;\\n\\n    size_t new_capacity = (size_t)(ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity)\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    else\\n        ar->capacity = new_capacity;\\n\\n    void **new_buff = ar->mem_alloc(ar->capacity * sizeof(void*));\\n\\n    if (!new_buff)\\n        return CC_ERR_ALLOC;\\n\\n    memcpy(new_buff, ar->buffer, ar->size * sizeof(void*));\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_map(CC_Array *ar, void (*fn) (void *e))\\n{\\n    size_t i;\\n    for (i = 0; i < ar->size; i++)\\n        fn(ar->buffer[i]);\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_reduce(CC_Array *ar, void (*fn) (void*, void*, void*), void *result)\\n{\\n    if (ar->size == 1) {\\n        fn(ar->buffer[0], NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1)\\n        fn(ar->buffer[0], ar->buffer[1], result);\\n\\n    for (size_t i = 2; i < ar->size; i++)\\n        fn(result, ar->buffer[i], result);\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_iter_init(CC_ArrayIter *iter, CC_Array *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the value of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_iter_next(CC_ArrayIter *iter, void **out)\\n{\\n    if (iter->index >= iter->ar->size)\\n        return CC_ITER_END;\\n\\n    *out = iter->ar->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_iter_remove(CC_ArrayIter *iter, void **out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK)\\n            iter->last_removed = true;\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_Array after the last returned element by\\n * <code>cc_array_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_iter_add(CC_ArrayIter *iter, void *element)\\n{\\n    return cc_array_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_iter_replace(CC_ArrayIter *iter, void *element, void **out)\\n{\\n    return cc_array_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_iter_index(CC_ArrayIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_zip_iter_init(CC_ArrayZipIter *iter, CC_Array *ar1, CC_Array *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_zip_iter_next(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size)\\n        return CC_ITER_END;\\n\\n    *out1 = iter->ar1->buffer[iter->index];\\n    *out2 = iter->ar2->buffer[iter->index];\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_zip_iter_remove(CC_ArrayZipIter *iter, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (!iter->last_removed) {\\n        cc_array_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_zip_iter_add(CC_ArrayZipIter *iter, void *e1, void *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_Array  *ar1  = iter->ar1;\\n    CC_Array  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n            (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK)))\\n        return CC_ERR_ALLOC;\\n\\n    cc_array_add_at(ar1, e1, index);\\n    cc_array_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_zip_iter_replace(CC_ArrayZipIter *iter, void *e1, void *e2, void **out1, void **out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    cc_array_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_zip_iter_index(CC_ArrayZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_struct_size()\\n{\\n    return sizeof(CC_Array);\\n}\", \"embeddings\": [0.019337035715579987, 0.04144222289323807, 0.016712907701730728, 0.10165813565254211, 0.3522007465362549, -0.16175229847431183, 0.08895014226436615, 0.3503000736236572, -0.021637719124555588, -0.29729849100112915, 0.03632007911801338, -0.1525823175907135, 0.060355737805366516, 0.03226489573717117, 0.02155909687280655, 0.06499006599187851, 0.0226303581148386, -0.00070924311876297, 0.03296894580125809, -0.34166771173477173, -0.17525385320186615, 0.1587163209915161, 0.18614137172698975, 0.10295991599559784, 0.2648610472679138, 0.09464851021766663, 0.21776100993156433, 0.1379604935646057, 0.397664338350296, -0.16163602471351624, 0.05349617451429367, -0.08375806361436844, 0.07953671365976334, -0.1613142341375351, 0.05377089977264404, -0.0016097277402877808, 0.00231083482503891, 0.08701863884925842, -0.02227378636598587, -0.0020508579909801483, -0.24478265643119812, 0.0052941045723855495, 0.09071902185678482, 0.19356752932071686, 0.11523918062448502, 0.0022864751517772675, 0.03358998894691467, 0.20853795111179352, -0.05340304598212242, 0.053996481001377106, 0.06899385899305344, -0.06237586960196495, 0.02085714042186737, -0.07237649708986282, -0.05569019541144371, 0.0022407062351703644, -0.005953468382358551, 0.3533000349998474, 0.012180954217910767, 0.021637268364429474, -0.08096639811992645, -0.12248674035072327, -0.14020203053951263, 0.17089174687862396, 0.1483224630355835, 0.02201649360358715, -0.09235116839408875, -0.21118898689746857, 0.037227801978588104, -0.029202386736869812, 0.15262646973133087, 0.12010883539915085, 0.09902290254831314, -0.1346030980348587, -0.15733759105205536, -0.036608949303627014, 0.06546125560998917, 0.6007839441299438, -0.04652274399995804, 0.16687874495983124, 0.21094825863838196, -0.054481375962495804, 0.10108371824026108, 0.19276779890060425, 0.15578323602676392, -0.023013778030872345, -0.08793839067220688, 0.10220562666654587, -0.02654804289340973, 0.1460888832807541, 0.12415887415409088, 0.158778578042984, -0.07403788715600967, -0.07707886397838593, -0.010122459381818771, 0.02141452766954899, 0.04828683286905289, -0.1752987504005432, 0.07224472612142563, 0.39034053683280945, -0.026564572006464005, -0.08620432019233704, -0.29387515783309937, -0.1454894244670868, -0.028208285570144653, 0.05319584906101227, -0.06623875349760056, 0.11844614148139954, 0.09321070462465286, -0.025656968355178833, 0.1710774153470993, -0.049253903329372406, 0.010775993578135967, -0.004026465117931366, 0.014724459499120712, -0.07234250009059906, 0.09415712207555771, -0.03668399900197983, 0.18653829395771027, -0.13039249181747437, 0.13831447064876556, -0.022955477237701416, -0.003960311412811279, -0.06840746104717255, -0.11129529774188995, 0.045911774039268494, 0.005601838231086731, -0.25842800736427307, 0.09559565037488937, 0.0788363367319107, -0.014835983514785767, -0.13300982117652893, -0.025165855884552002, 0.0246572345495224, 0.1464480757713318, -0.029742557555437088, 0.13905486464500427, -0.017319999635219574, 0.043093543499708176, 0.04986397922039032, -0.021061956882476807, 0.058587659150362015, 0.2690821886062622, 0.00491037592291832, 0.13973088562488556, -0.16307060420513153, 0.15196101367473602, 0.12290704250335693, -0.4040970206260681, -0.2029382884502411, 0.004422478377819061, -0.08683349192142487, 0.01110504288226366, -0.011568240821361542, -0.09908446669578552, 0.7936120629310608, 0.11825153976678848, -0.12820139527320862, -0.05069497972726822, -0.03620525449514389, 0.021716315299272537, -0.2629883587360382, -0.025452986359596252, 0.17485423386096954, 0.06729403883218765, 0.1459808498620987, 0.05202849581837654, 0.13852697610855103, 0.21242961287498474, 0.07220236212015152, 0.08692559599876404, -0.10353602468967438, -0.08012241125106812, 0.1521211564540863, 0.07012902945280075, -0.06299886852502823, -0.13164585828781128, 0.05634055286645889, -0.06832484900951385, 0.033088259398937225, -0.15408964455127716, -0.00040036439895629883, -0.17150850594043732, 0.018816784024238586, -0.09533684700727463, -0.009334750473499298, -0.011194542050361633, -0.05349963158369064, 0.07576224952936172, -0.014180507510900497, 0.055722545832395554, -0.0030917953699827194, 0.1361950784921646, -0.12817437946796417, -0.06362181156873703, 0.03937115520238876, -0.12032099813222885, -0.021075552329421043, 0.30858394503593445, -0.0765518844127655, -0.03546442091464996, -0.2024536430835724, 0.305609792470932, -0.07190239429473877, 0.14057496190071106, 0.17915558815002441, -0.24619202315807343, -0.05189784616231918, -0.05329317972064018, -0.15342821180820465, -0.071672722697258, 0.16938970983028412, 0.06416911631822586, 0.029575802385807037, -0.08521687984466553, -0.053955212235450745, 0.060186102986335754, 0.11355836689472198, 0.04572580009698868, -0.11255858093500137, 0.12408645451068878, 0.21102046966552734, -0.027737589552998543, -0.08400194346904755, -0.0949639081954956, 0.14918066561222076, 0.15626320242881775, 0.10328057408332825, 0.01122206263244152, 0.15641438961029053, 0.14710983633995056, 0.20305490493774414, -0.23038743436336517, 0.110036700963974, 0.019163213670253754, -0.22145366668701172, -0.08156725764274597, 0.032227933406829834, -0.07856617122888565, -0.14959006011486053, -0.05184090882539749, 0.1786029040813446, 0.15866634249687195, 0.2933410704135895, 0.04506294056773186, 0.02786439284682274, -0.19559501111507416, -0.008371531963348389, -0.12778018414974213, 0.07871624082326889, 0.0035455171018838882, -0.004127568565309048, 0.0434739775955677, -0.07945148646831512, -0.06470952928066254, -0.0454101599752903, -0.14062108099460602, 0.030654793605208397, 0.08298832178115845, 0.2122100293636322, -0.011904779821634293, -0.025789009407162666, 0.0870218276977539, -0.09515433013439178, -0.15354719758033752, -0.4502030611038208, -0.056469954550266266, 0.09569789469242096, 0.033763524144887924, -0.049149006605148315, 0.13796550035476685, -0.06912947446107864, 0.22741293907165527, 0.2080795168876648, 0.023990098387002945, -0.0261223167181015, -0.04410160332918167, 0.006548762321472168, -0.07744411379098892, -0.014824464917182922, -0.012535352259874344, 0.06469903141260147, -0.23376640677452087, 0.113896943628788, 0.012449498288333416, -0.04210395738482475, 0.11641591787338257, 0.03298642486333847, 0.0427117757499218, 0.06173942610621452, 0.040360886603593826, 0.04512530565261841, 0.1680828332901001, 0.14521491527557373, 0.06720708310604095, 0.1416691392660141, 0.17256739735603333, -0.08437894284725189, 0.026008091866970062, -0.3322620391845703, 0.11150476336479187, -0.21652038395404816, -0.0005622234893962741, -0.03452644124627113, 0.41056138277053833, 0.02247254177927971, -0.02950277179479599, 0.025868140161037445, 0.27007341384887695, 0.061397574841976166, 0.06394463777542114, 0.06929603964090347, -0.14965148270130157, 0.11539217084646225, -0.12211129069328308, 0.07912545651197433, -0.11621376127004623, -0.08079551160335541, 0.09370986372232437, -0.01156153529882431, -0.059066664427518845, 0.19641822576522827, 0.2538159489631653, 0.13910077512264252, 0.011473837308585644, 0.08998945355415344, 0.09160371124744415, -0.042817018926143646, -0.21148866415023804, 0.644500732421875, -0.4434852600097656, 0.23973426222801208, -0.24958917498588562, 0.35104936361312866, -0.052162885665893555, 0.34136486053466797, -0.052755266427993774, 0.10137899219989777, 0.05691688880324364, 0.10231050848960876, -0.13188926875591278, -0.1454443782567978, -0.14654766023159027, 0.30298563838005066, 0.15610864758491516, 0.14819450676441193, 0.2042459100484848, -0.06436434388160706, 0.15721090137958527, -0.10648252069950104, -0.1501380354166031, 0.16823096573352814, 0.0070962607860565186, -0.06967655569314957, 0.09160996228456497, 0.382039338350296, -0.14860114455223083, -0.03727662190794945, 0.016918309032917023, 0.0791194960474968, 0.1605367660522461, -0.2526761591434479, 0.1605421006679535, -0.048609212040901184, 0.29338133335113525, -0.4488697052001953, -0.37339287996292114, -0.019343510270118713, -0.09996235370635986, 0.11582093685865402, 0.16859431564807892, 0.18752160668373108, 0.16621477901935577, -0.20493079721927643, 0.04882332310080528, -0.03351687267422676, -0.14234735071659088, -0.007110565900802612, -0.026366204023361206, 0.09578430652618408, 0.05021988973021507, 0.09446340799331665, 0.06874462962150574, 0.039108291268348694, 0.08482661098241806, -0.17297077178955078, 0.19759562611579895, 0.18696990609169006, 0.2536092698574066, -0.05240778252482414, 0.10444481670856476, -0.18038342893123627, 0.09045860171318054, -0.07609578967094421, 0.035030901432037354, 0.045925986021757126, 0.024546008557081223, 0.1053478866815567, -0.07855165004730225, -0.16271239519119263, 0.1549939513206482, 0.2041073739528656, -0.0657844990491867, 0.1434514820575714, 0.1089816614985466, 0.051300108432769775, 0.07904311269521713, -0.12442873418331146, -0.16930273175239563, -0.1778094321489334, 0.08229023963212967, 0.07881941646337509, 0.014019079506397247, 0.0658847987651825, 0.15226341784000397, -0.1455191820859909, 0.0701334998011589, -0.27942919731140137, -0.1861485242843628, 0.15248921513557434, 0.17312899231910706, 0.10937699675559998, 0.0518568679690361, -0.13878044486045837, -0.06236465275287628, -0.0300205759704113, -0.04081200808286667, -0.10790913552045822, 0.1050751656293869, -0.17835918068885803, 0.021413631737232208, 0.2059786319732666, 0.07661541551351547, 0.15056931972503662, 0.11919894814491272, -0.014682363718748093, -0.10984207689762115, 0.02318328060209751, 0.060933917760849, 0.04346981272101402, -0.12179884314537048, 0.029510876163840294, 0.04969675838947296, 0.0899784117937088, -0.0096410121768713, -0.06827347725629807, 0.42542392015457153, 0.12362271547317505, -0.06745889782905579, 0.062285415828228, -0.20761257410049438, 0.02548132836818695, -0.058351341634988785, -0.29213783144950867, 0.15140604972839355, 0.22266726195812225, 0.08476775884628296, 0.04286756366491318, 0.14466407895088196, 0.047663670033216476, 0.02839561738073826, 0.09488922357559204, -0.10725101828575134, -0.13815169036388397, 0.020331881940364838, -0.08660612255334854, 0.1268768310546875, 0.046352535486221313, 0.22964061796665192, 0.13475798070430756, 0.12503166496753693, 0.2354244887828827, 0.026891794055700302, -0.11670900881290436, -0.003195006400346756, -0.012266755104064941, -0.04315231740474701, -0.24447603523731232, 0.10242938250303268, -0.16651864349842072, -0.012684490531682968, 0.10390886664390564, 0.18136155605316162, 0.0019090250134468079, 0.013639796525239944, -0.12774652242660522, 0.2087920606136322, 0.11302005499601364, -0.12920552492141724, 0.006028160452842712, -0.11878140270709991, 0.21917559206485748, 0.03885935992002487, 0.18553617596626282, 0.2635849118232727, 0.1547829806804657, 0.09620411694049835, 0.1559755504131317, 0.2644818425178528, -0.1129351556301117, 0.02465365082025528, 0.0740203708410263, 0.03858373314142227, -0.05388801172375679, -0.1826028823852539, -0.09494095295667648, -0.0454413965344429, 0.10557834059000015, 0.19254668056964874, -0.1927100121974945, -0.03664252161979675, -0.06785153597593307, 0.13207761943340302, -0.025892607867717743, 0.0418156236410141, 0.046708784997463226, -0.018358364701271057, 0.034371890127658844, -0.06694474071264267, 0.3322097659111023, -0.10620659589767456, -0.12758024036884308, -0.07094311714172363, 0.015680678188800812, -0.07176665961742401, 0.054283805191516876, 0.11996902525424957, -0.005219481885433197, 0.08749192208051682, 0.0053307488560676575, 0.013966478407382965, 0.03176805377006531, 0.08033496886491776, 0.21690607070922852, -0.1057061105966568, 0.03428464010357857, 0.0833219587802887, -0.006556190550327301, 0.23270052671432495, -0.08225256204605103, -0.20608310401439667, -0.07733946293592453, 0.1842702031135559, -0.0789211243391037, 0.15159815549850464, 0.014894666150212288, 0.13076548278331757, 0.07498789578676224, 0.01678844913840294, -0.034964628517627716, -0.11825966835021973, -0.8292933106422424, -0.07177972793579102, 0.1974756419658661, -0.06381435692310333, 0.08855392783880234, 0.12926487624645233, 0.09943949431180954, 0.07838951051235199, 0.10335634648799896, 0.028436873108148575, 0.05035888031125069, 0.18390114605426788, 0.2350541353225708, -0.07908978313207626, -0.118551105260849, 0.08145298063755035, 0.10845789313316345, -0.22981905937194824, 0.24889957904815674, -0.0038178444374352694, -0.13647347688674927, 0.032970283180475235, 0.3018205761909485, -0.019496798515319824, 0.06974869966506958, 0.20493462681770325, 0.07311457395553589, 0.2735404372215271, -0.012564659118652344, 0.045816726982593536, 0.2721535861492157, 0.14508739113807678, -0.3134864568710327, 0.01326439157128334, 0.1473902463912964, 0.13166740536689758, 0.023197725415229797, 13.807149887084961, -0.059695765376091, 0.2458605319261551, -0.2152383029460907, -0.0576133206486702, -0.04612252861261368, -0.056627996265888214, 0.06926070898771286, -0.05847388505935669, -0.06567133963108063, 0.11634166538715363, -0.07180065661668777, -0.0006111934781074524, 0.03537771850824356, -0.08245797455310822, -0.07545702159404755, -0.07517779618501663, -0.10223224759101868, 0.16663774847984314, 0.010213539004325867, -0.2660246789455414, -0.14093664288520813, -0.023642949759960175, -0.4965704381465912, -0.03950488194823265, -0.09631837159395218, 0.10675627738237381, 0.07107588648796082, -0.005163984373211861, 0.04745369777083397, 0.17403191328048706, 0.1333225667476654, 0.09924574196338654, -0.08217284083366394, 0.06567363440990448, -0.0590694285929203, -0.44002699851989746, -0.14729243516921997, 0.16280104219913483, -0.054223597049713135, 0.023164615035057068, 0.0070249587297439575, 0.20683836936950684, -0.023171894252300262, 0.13199466466903687, 0.11919517070055008, -0.2632838785648346, 0.16130809485912323, -0.11193645745515823, -0.1040131151676178, 0.20002709329128265, 0.15179622173309326, 0.34871798753738403, 0.03217348828911781, -0.15706244111061096, -0.3169536590576172, 0.2661152482032776, -0.025678522884845734, -0.11894290149211884, 0.3540883958339691, -0.0219099223613739, -0.1188809797167778, 0.010967489331960678, 0.017705237492918968, -0.07761627435684204, 0.031693875789642334, 0.10004745423793793, 0.09426500648260117, -0.2067384272813797, 0.10746277868747711, 0.24634239077568054, -0.18717147409915924, 0.16554966568946838, 0.007030382752418518, 0.03509054332971573, 0.0635799914598465, 0.029941849410533905, -0.03443462774157524, 0.11082572489976883, -0.08858674764633179, -0.03467297554016113, 0.06394480168819427, -0.16329412162303925, -0.15780991315841675, -0.3266502618789673, 0.07179486006498337, -0.13508711755275726, 0.22813811898231506, 0.23803454637527466, -0.04019599407911301, -0.08321816474199295, 0.12468087673187256, -4.3064355850219727e-05, -0.1992940604686737, 0.20334744453430176, -0.0643836185336113, -0.03824351727962494, -0.14934243261814117, 0.026448871940374374, 0.11721101403236389, -0.05616284906864166, -0.01661304011940956, 0.01946309581398964, -0.007932707667350769, -0.1086411327123642, -0.010806344449520111, -0.07042394578456879, 0.03155172988772392, -0.028638437390327454, 0.07672829926013947, 0.04789261519908905, 0.13953927159309387, 0.11921271681785583, -0.20235587656497955, -0.15513114631175995, 0.0018255561590194702, 0.02279839478433132, -0.018898386508226395, 0.24614442884922028, 0.009899530559778214, 0.1786707639694214, 0.0746900886297226, -0.11455024778842926, -0.04840231314301491, 0.06696005165576935, -0.24506427347660065, -0.026107806712388992, 0.18647655844688416, 0.06139722466468811, -0.0440538115799427, 0.05313015729188919, -0.06576409190893173, 0.44768545031547546, 0.09101861715316772, 0.016458671540021896, -0.008360952138900757, -0.06900910288095474, 0.04771755635738373, 0.11869488656520844, 0.23411428928375244, 0.05768774077296257, -0.02256511151790619, 0.194657564163208, -0.14067895710468292, -0.03137984126806259, 0.3059922158718109, 0.07792039960622787, 0.03797338530421257, -0.11313362419605255, 0.17945441603660583, 0.054101575165987015, 0.20955345034599304, -0.10005279630422592, -0.09177906811237335, -0.10118873417377472, -0.16123127937316895, -0.20944437384605408, 0.023862991482019424, -0.035900428891181946, -0.046280380338430405, 0.17417898774147034, -0.33210647106170654, 0.16942907869815826, -0.31501349806785583, -0.09892860054969788, 0.07363034784793854, 0.05470734089612961, 0.13385148346424103, 0.1517913043498993, -0.10500221699476242, 0.05184849724173546, 0.11209061741828918, -0.24669302999973297, -0.00020530074834823608, -0.08626976609230042, 0.08259842544794083, 0.22808516025543213, -0.40896204113960266, -0.18954910337924957, 0.06508075445890427]}"
"{\"sha\": \"1df65eae4a4b776c2e3f9aef2e82e19ae62a2f23\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/cc_slist.c\", \"func_name\": \"cc_slist_iter_next\", \"original_string\": \"enum cc_stat cc_slist_iter_next(CC_SListIter *iter, void **out)\\n{\\n    if (!iter->next)\\n        return CC_ITER_END;\\n\\n    void *data = iter->next->data;\\n\\n    if (iter->current)\\n        iter->prev = iter->current;\\n\\n    iter->current = iter->next;\\n    iter->next = iter->next->next;\\n    iter->index++;\\n\\n    *out = data;\\n\\n    return CC_OK;\\n}\", \"code_tokens\": [\"enum\", \"cc_stat\", \"cc_slist_iter_next\", \"(\", \"CC_SListIter\", \"*\", \"iter\", \",\", \"void\", \"*\", \"*\", \"out\", \")\", \"{\", \"if\", \"(\", \"!\", \"iter\", \"->\", \"next\", \")\", \"return\", \"CC_ITER_END\", \";\", \"void\", \"*\", \"data\", \"=\", \"iter\", \"->\", \"next\", \"->\", \"data\", \";\", \"if\", \"(\", \"iter\", \"->\", \"current\", \")\", \"iter\", \"->\", \"prev\", \"=\", \"iter\", \"->\", \"current\", \";\", \"iter\", \"->\", \"current\", \"=\", \"iter\", \"->\", \"next\", \";\", \"iter\", \"->\", \"next\", \"=\", \"iter\", \"->\", \"next\", \"->\", \"next\", \";\", \"iter\", \"->\", \"index\", \"++\", \";\", \"*\", \"out\", \"=\", \"data\", \";\", \"return\", \"CC_OK\", \";\", \"}\"], \"docstring\": \"/**\\n * Advances the iterator and sets the out parameter to the value of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out Pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the list has been reached.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Advances\", \"the\", \"iterator\", \"and\", \"sets\", \"the\", \"out\", \"parameter\", \"to\", \"the\", \"value\", \"of\", \"the\", \"*\", \"next\", \"element\", \"in\", \"the\", \"sequence\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"iter\", \"the\", \"iterator\", \"that\", \"is\", \"being\", \"advanced\", \"*\", \"@param\", \"[\", \"out\", \"]\", \"out\", \"Pointer\", \"to\", \"where\", \"the\", \"next\", \"element\", \"is\", \"set\", \"*\", \"*\", \"@return\", \"CC_OK\", \"if\", \"the\", \"iterator\", \"was\", \"advanced\", \"or\", \"CC_ITER_END\", \"if\", \"the\", \"*\", \"end\", \"of\", \"the\", \"list\", \"has\", \"been\", \"reached\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2015 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n#include \\\"cc_slist.h\\\"\\n\\n\\nstruct cc_slist_s {\\n    size_t  size;\\n    SNode   *head;\\n    SNode   *tail;\\n\\n    void  *(*mem_alloc)  (size_t size);\\n    void  *(*mem_calloc) (size_t blocks, size_t size);\\n    void   (*mem_free)   (void *block);\\n};\\n\\n\\nstatic void* unlinkn             (CC_SList *list, SNode *node, SNode *prev);\\nstatic bool  unlinkn_all         (CC_SList *list, void (*cb) (void*));\\nstatic void  splice_between      (CC_SList *list1, CC_SList *list2, SNode *base, SNode *end);\\nstatic bool  link_all_externally (CC_SList *list, SNode **h, SNode **t);\\nstatic enum cc_stat get_node_at  (CC_SList *list, size_t index, SNode **node, SNode **prev);\\nstatic enum cc_stat get_node     (CC_SList *list, void *element, SNode **node, SNode **prev);\\n\\n\\n/**\\n * Initializes the fields CC_SListConf struct to default values.\\n *\\n * @param[in] conf the CC_SListConf struct that is being initialized.\\n */\\nvoid cc_slist_conf_init(CC_SListConf *conf)\\n{\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Creates a new empty list and returns a status code.\\n *\\n * @param[out] out Pointer to a CC_SList that is being created.\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_SList structure failed.\\n */\\nenum cc_stat cc_slist_new(CC_SList **out)\\n{\\n    CC_SListConf conf;\\n    cc_slist_conf_init(&conf);\\n    return cc_slist_new_conf(&conf, out);\\n}\\n\\n/**\\n * Creates a new empty CC_SList based on the specified CC_SListConf struct and\\n * returns a status code.\\n *\\n * The CC_SList is allocated using the allocators specified in the CC_SListConf\\n * struct. The allocation may fail if the underlying allocator fails.\\n *\\n * @param[in] conf CC_SList configuration struct. All fields must be initialized\\n *            to appropriate values.\\n *\\n * @param[out] out Pointer to a CC_SList that is being createdo\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_SList structure failed.\\n */\\nenum cc_stat cc_slist_new_conf(CC_SListConf const * const conf, CC_SList **out)\\n{\\n    CC_SList *list = conf->mem_calloc(1, sizeof(CC_SList));\\n\\n    if (!list)\\n        return CC_ERR_ALLOC;\\n\\n    list->mem_alloc  = conf->mem_alloc;\\n    list->mem_calloc = conf->mem_calloc;\\n    list->mem_free   = conf->mem_free;\\n\\n    *out = list;\\n    return CC_OK;\\n}\\n\\n/**\\n * Destroys the list structure, but leaves the data that is holds intact.\\n *\\n * @param[in] list CC_SList that is to be destroyed\\n */\\nvoid cc_slist_destroy(CC_SList *list)\\n{\\n    cc_slist_remove_all(list);\\n    list->mem_free(list);\\n}\\n\\n/**\\n * Destroys the list structure along with all the data it holds.\\n *\\n * @note\\n * This function should not be called on a list that has some of it's elements\\n * allocated on the stack.\\n *\\n * @param[in] list CC_SList that is to be destroyed\\n */\\nvoid cc_slist_destroy_cb(CC_SList *list, void (*cb) (void*))\\n{\\n    cc_slist_remove_all_cb(list, cb);\\n    list->mem_free(list);\\n}\\n\\n/**\\n * Adds a new element to the list. The element is appended to the list making it\\n * the last element of the list.\\n *\\n * @param[in] list CC_SList to which the element is being added\\n * @param[in] element element that is being added\\n *\\n * @return CC_OK if the element was successfully added, or CC_ERR_ALLOC if the\\n * memory allocation for the new element has failed.\\n */\\nenum cc_stat cc_slist_add(CC_SList *list, void *element)\\n{\\n    return cc_slist_add_last(list, element);\\n}\\n\\n/**\\n * Prepends a new element to the list (adds a new \\\"head\\\") making it the first\\n * element of the list.\\n *\\n * @param[in] list CC_SList to which the element is being added\\n * @param[in] element element that is being added\\n *\\n * @return CC_OK if the element was successfully added, or CC_ERR_ALLOC if the\\n * memory allocation for the new element has failed.\\n */\\nenum cc_stat cc_slist_add_first(CC_SList *list, void *element)\\n{\\n    SNode *node = list->mem_calloc(1, sizeof(SNode));\\n\\n    if (!node)\\n        return CC_ERR_ALLOC;\\n\\n    node->data = element;\\n\\n    if (list->size == 0) {\\n        list->head = node;\\n        list->tail = node;\\n    } else {\\n        node->next = list->head;\\n        list->head = node;\\n    }\\n    list->size++;\\n    return CC_OK;\\n}\\n\\n/**\\n * Appends a new element to the list (adds a new \\\"tail\\\") making it the last\\n * element of the list.\\n *\\n * @param[in] list CC_SList to which the element is being added\\n * @param[in] element element that is being added\\n *\\n * @return CC_OK if the element was successfully added, or CC_ERR_ALLOC if the\\n * memory allocation for the new element has failed.\\n */\\nenum cc_stat cc_slist_add_last(CC_SList *list, void *element)\\n{\\n    SNode *node = list->mem_calloc(1, sizeof(SNode));\\n\\n    if (!node)\\n        return CC_ERR_ALLOC;\\n\\n    node->data = element;\\n\\n    if (list->size == 0) {\\n        list->head       = node;\\n        list->tail       = node;\\n    } else {\\n        list->tail->next = node;\\n        list->tail       = node;\\n    }\\n    list->size++;\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element at the specified location in the CC_SList and shifts all\\n * subsequent elements by one. The index at which the new element is being\\n * added must be within the bounds of the list.\\n *\\n * @note This operation cannot be performed on an empty list.\\n *\\n * @param[in] list CC_SList to which this element is being added\\n * @param[in] element element that is being added\\n * @param[in] index the position in the list at which the new element is being\\n *                  added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, or CC_ERR_ALLOC if the memory\\n * allocation for the new element failed.\\n */\\nenum cc_stat cc_slist_add_at(CC_SList *list, void *element, size_t index)\\n{\\n    SNode *prev = NULL;\\n    SNode *node = NULL;\\n\\n    enum cc_stat status = get_node_at(list, index, &node, &prev);\\n\\n    if (status != CC_OK)\\n        return status;\\n\\n    SNode *new = list->mem_calloc(1, sizeof(SNode));\\n\\n    if (!new)\\n        return CC_ERR_ALLOC;\\n\\n    new->data = element;\\n\\n    if (!prev) {\\n        new->next  = list->head;\\n        list->head = new;\\n    } else {\\n        SNode *tmp = prev->next;\\n        prev->next = new;\\n        new->next  = tmp;\\n    }\\n\\n    list->size++;\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds all elements from the second list to the first. The elements from the\\n * second list are added after the last element of the first list.\\n *\\n * @param[in] list1 CC_SList to which the elements are being added\\n * @param[in] list2 CC_SList from which the elements are being taken\\n *\\n * @return CC_OK if the elements where successfully added, or CC_ERR_ALLOC if\\n * the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_slist_add_all(CC_SList *list1, CC_SList *list2)\\n{\\n    if (list2->size == 0)\\n        return CC_OK;\\n\\n    SNode *head = NULL;\\n    SNode *tail = NULL;\\n\\n    if (!link_all_externally(list2, &head, &tail))\\n        return CC_ERR_ALLOC;\\n\\n    if (list1->size == 0) {\\n        list1->head = head;\\n        list1->tail = tail;\\n    } else {\\n        list1->tail->next = head;\\n        list1->tail = tail;\\n    }\\n    list1->size += list2->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds all element from the second list to the first at the specified position\\n * by shifting all subsequent elements by the size of the second list. The index\\n * must be within the range of the first list.\\n *\\n * @param[in] list1 CC_SList to which the elements are being added\\n * @param[in] list2 CC_SList from which the elements are being taken\\n * @param[in] index position in the first list at which the elements should be\\n *                  added\\n *\\n * @return CC_OK if the elements were successfully added,\\n * CC_ERR_INDEX_OUT_OF_BOUNDS if the index was out of range, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_slist_add_all_at(CC_SList *list1, CC_SList *list2, size_t index)\\n{\\n    if (list2->size == 0)\\n        return CC_OK;\\n\\n    SNode *prev = NULL;\\n    SNode *node = NULL;\\n\\n    enum cc_stat status = get_node_at(list1, index, &node, &prev);\\n\\n    if (status != CC_OK)\\n        return status;\\n\\n    SNode *head = NULL;\\n    SNode *tail = NULL;\\n\\n    if (!link_all_externally(list2, &head, &tail))\\n        return CC_ERR_ALLOC;\\n\\n    if (!prev) {\\n        tail->next  = node;\\n        list1->head = head;\\n    } else {\\n        prev->next = head;\\n        tail->next = node;\\n    }\\n\\n    list1->size += list2->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Duplicates the structure of the list without directly attaching it to a\\n * specific list. If the operation fails, everything is cleaned up and false\\n * is returned to indicate the failure.\\n *\\n * @param[in] list the list whose structure is being duplicated\\n * @param[in, out] h the pointer to which the new head will be attached\\n * @param[in, out] t the pointer to which the new tail will be attached\\n *\\n * @return true if the operation was successful\\n */\\nstatic bool link_all_externally(CC_SList *list, SNode **h, SNode **t)\\n{\\n    SNode *ins = list->head;\\n\\n    size_t i;\\n    for (i = 0; i < list->size; i++) {\\n        SNode *new = list->mem_calloc(1, sizeof(SNode));\\n\\n        if (!new) {\\n            while (*h) {\\n                SNode *tmp = (*h)->next;\\n                list->mem_free(*h);\\n                *h = tmp;\\n            }\\n            return false;\\n        }\\n\\n        new->data = ins->data;\\n\\n        if (!*h) {\\n            *h = new;\\n            *t = new;\\n        } else {\\n            (*t)->next = new;\\n            *t = new;\\n        }\\n\\n        ins = ins->next;\\n    }\\n    return true;\\n}\\n\\n/**\\n * Splices the two CC_SLists together by appending the second list to the\\n * first. This function moves all the elements from the second list into\\n * the first list, leaving the second list empty.\\n *\\n * @param[in] list1 The consumer list to which the elements are moved.\\n * @param[in] list2 The producer list from which the elements are moved.\\n *\\n * @return CC_OK if the elements were successfully moved\\n */\\nenum cc_stat cc_slist_splice(CC_SList *list1, CC_SList *list2)\\n{\\n    if (list2->size == 0)\\n        return CC_OK;\\n\\n    if (list1->size == 0) {\\n        list1->head = list2->head;\\n        list1->tail = list2->tail;\\n    } else {\\n        list1->tail->next = list2->head;\\n        list1->tail = list2->tail;\\n    }\\n    list1->size += list2->size;\\n\\n    list2->head = NULL;\\n    list2->tail = NULL;\\n    list2->size = 0;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Splices the two CC_SLists together at the specified index of the first list.\\n * this function moves all the elements from the second list into the first\\n * list at the position specified by the <code>index</code> parameter. After\\n * this operation the second list will be left empty.\\n *\\n * @param[in] list1 the consumer list to which the elements are moved\\n * @param[in] list2 the producer list from which the elements are moved\\n * @param[in] index the index in the first list after which the elements\\n *                   from the second list should be inserted\\n *\\n * @return CC_OK if the elements were successfully moved, CC_ERR_OUT_OF_RANGE if\\n * the index was not in range,\\n */\\nenum cc_stat cc_slist_splice_at(CC_SList *list1, CC_SList *list2, size_t index)\\n{\\n    if (list2->size == 0)\\n        return CC_OK;\\n\\n    if (index >= list1->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    SNode *prev = NULL;\\n    SNode *node = NULL;\\n\\n    enum cc_stat status = get_node_at(list1, index, &node, &prev);\\n\\n    if (status != CC_OK)\\n        return status;\\n\\n    splice_between(list1, list2, prev, node);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Inserts the second list between the two nodes of the first list. If the left\\n * node is NULL the head of the second list will be become the head of the first\\n * list. Similarly if the right node is null the tail of the first list will\\n * become the tail of the second list.\\n *\\n * @param[in, out] l1 the consumer list\\n * @param[in, out] l2 the producer list\\n * @param[in] left the node after which the elements are being added\\n * @param[in] right the node behind which the elements are being added\\n */\\nstatic INLINE void splice_between(CC_SList *l1, CC_SList *l2, SNode *base, SNode *end)\\n{\\n    if (!base) {\\n        l2->tail->next = l1->head;\\n        l1->head = l2->head;\\n    } else if (!end) {\\n        l1->tail->next = l2->head;\\n        l1->tail = l2->tail;\\n    } else {\\n        base->next = l2->head;\\n        l2->tail->next = end;\\n    }\\n    l1->size += l2->size;\\n\\n    l2->head = NULL;\\n    l2->tail = NULL;\\n    l2->size = 0;\\n}\\n\\n/**\\n * Removes the first occurrence of the element from the specified CC_SList\\n * and optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] list CC_SList from which the element is being removed\\n * @param[in] element element that is being removed\\n * @param[out] out Pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_slist_remove(CC_SList *list, void *element, void **out)\\n{\\n    SNode *prev = NULL;\\n    SNode *node = NULL;\\n\\n    enum cc_stat status = get_node(list, element, &node, &prev);\\n\\n    if (status != CC_OK)\\n        return status;\\n\\n    void *val = unlinkn(list, node, prev);\\n\\n    if (out)\\n        *out = val;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the element at the specified index and optionally sets\\n * the out parameter to the value of the removed element. The index\\n * must be within the bounds of the list.\\n *\\n * @param[in] list  CC_SList from which the element is being removed\\n * @param[in] index Index of the element that is being removed. Must be be\\n *                  within the index range of the list.\\n * @param[out] out  Pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_slist_remove_at(CC_SList *list, size_t index, void **out)\\n{\\n    SNode *prev = NULL;\\n    SNode *node = NULL;\\n\\n    enum cc_stat status = get_node_at(list, index, &node, &prev);\\n\\n    if (status != CC_OK)\\n        return status;\\n\\n    void *e = unlinkn(list, node, prev);\\n\\n    if (out)\\n        *out = e;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the first (head) element of the list and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @param[in] list CC_SList from which the first element is being removed\\n * @param[out] out Pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_VALUE_NOT_FOUND\\n * if the list is empty.\\n */\\nenum cc_stat cc_slist_remove_first(CC_SList *list, void **out)\\n{\\n    if (list->size == 0)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    void *e = unlinkn(list, list->head, NULL);\\n\\n    if (out)\\n        *out = e;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last (tail) element of the list and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @param[in] list CC_SList from which the last element is being removed\\n * @param[out] out Pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_VALUE_NOT_FOUND\\n * if the list is empty.\\n */\\nenum cc_stat cc_slist_remove_last(CC_SList *list, void **out)\\n{\\n    if (list->size == 0)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    SNode *prev = NULL;\\n    SNode *node = NULL;\\n\\n    enum cc_stat status = get_node_at(list, list->size - 1, &node, &prev);\\n\\n    if (status != CC_OK)\\n        return status;\\n\\n    void *e = unlinkn(list, node, prev);\\n\\n    if (out)\\n        *out = e;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes all elements from the specified list.\\n *\\n * @param[in] list CC_SList from which all elements are being removed\\n *\\n * @return CC_OK if the elements were successfully removed, or CC_ERR_VALUE_NOT_FOUND\\n * if the list was already empty.\\n */\\nenum cc_stat cc_slist_remove_all(CC_SList *list)\\n{\\n    bool unlinked = unlinkn_all(list, NULL);\\n\\n    if (unlinked) {\\n        list->head = NULL;\\n        list->tail = NULL;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Removes and frees all the elements from the specified list.\\n *\\n * @note\\n * This function should not be called on a list that has some of it's elements\\n * allocated on the stack.\\n *\\n * @param[in] list CC_SList from which all the elements are being removed and freed\\n *\\n * @return CC_OK if the element were successfully removed and freed, or\\n * CC_ERR_VALUE_NOT_FOUND if the list was already empty.\\n */\\nenum cc_stat cc_slist_remove_all_cb(CC_SList *list, void (*cb) (void*))\\n{\\n    bool unlinked = unlinkn_all(list, cb);\\n\\n    if (unlinked) {\\n        list->head = NULL;\\n        list->tail = NULL;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Replaces an element at the specified location and optionally sets the out parameter\\n * to the value of the replaced element. The specified index must be within the bounds\\n * of the list.\\n *\\n * @param[in] list    CC_SList on which this operation is performed\\n * @param[in] element the replacement element\\n * @param[in] index   index of the element being replaced\\n * @param[out] out    Pointer to where the replaced element is stored, or NULL if\\n *                    it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_slist_replace_at(CC_SList *list, void *element, size_t index, void **out)\\n{\\n    SNode *prev = NULL;\\n    SNode *node = NULL;\\n\\n    enum cc_stat status = get_node_at(list, index, &node, &prev);\\n\\n    if (status != CC_OK)\\n        return status;\\n\\n    void *old = node->data;\\n    node->data = element;\\n\\n    if (out)\\n        *out = old;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Gets the first element from the specified list and sets the out parameter to\\n * its value.\\n *\\n * @param[in] list CC_SList whose first element is being returned\\n * @param[in] out  Pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if not.\\n */\\nenum cc_stat cc_slist_get_first(CC_SList *list, void **out)\\n{\\n    if (list->size == 0)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    *out = list->head->data;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Gets the last element from the specified list and sets the out parameter to\\n * its value.\\n *\\n * @param[in] list CC_SList whose last element is being returned\\n * @param[out] out Pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if not.\\n */\\nenum cc_stat cc_slist_get_last(CC_SList *list, void **out)\\n{\\n    if (list->size == 0)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    *out = list->tail->data;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Gets the list element from the specified index and sets the out parameter to\\n * its value.\\n *\\n * @param[in] list  CC_SList from which the element is being returned.\\n * @param[in] index The index of a list element being returned. The index must\\n *                  be within the bound of the list.\\n * @param[out] out  Pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_slist_get_at(CC_SList *list, size_t index, void **out)\\n{\\n    SNode *prev = NULL;\\n    SNode *node = NULL;\\n\\n    enum cc_stat status = get_node_at(list, index, &node, &prev);\\n\\n    if (status != CC_OK)\\n        return status;\\n\\n    *out = node->data;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of elements in the specified CC_SList.\\n *\\n * @param[in] list CC_SList whose size is being returned\\n *\\n * @return The number of elements contained in the specified CC_SList.\\n */\\nsize_t cc_slist_size(CC_SList *list)\\n{\\n    return list->size;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified list.\\n *\\n * @param[in] list CC_SList that is being reversed\\n */\\nvoid cc_slist_reverse(CC_SList *list)\\n{\\n    if (list->size == 0 || list->size == 1)\\n        return;\\n\\n    SNode *prev = NULL;\\n    SNode *next = NULL;\\n    SNode *flip = list->head;\\n\\n    list->tail = list->head;\\n\\n    while (flip) {\\n        next = flip->next;\\n        flip->next = prev;\\n        prev = flip;\\n        flip = next;\\n    }\\n    list->head = prev;\\n}\\n\\n/**\\n * Creates a sublist of the specified list. The created sublist contains all\\n * the elements from the list that are contained between the two indices\\n * including the elements at the indices. For example if a list contains 5\\n * elements [5, 6, 7, 8, 9], a sublist from index 1 to 3 will will be a new\\n * list of length 3, containing [6, 7, 8]. The created sublist is only a copy of\\n * the original lists structure, meaning the data it points to is not copied.\\n *\\n * @note The sublist is allocated using the original lists allocators and also\\n *       inherits the configuration of the original list.\\n *\\n * @param[in] list CC_SList from which the sublist is taken\\n * @param[in] from The beginning index, ie., the first element to be included.\\n *                 Must be a positive integer and may not exceed the list size\\n *                 or the end index.\\n * @param[in] to   The ending index, ie., the last element to be included. Must\\n *                 be a positive integer no greater that the list size and no\\n *                 smaller that the beginning index.\\n * @param[out] out Pointer to where the new sublist is stored.\\n *\\n * @return CC_OK if the sublist was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new sublist failed.\\n */\\nenum cc_stat cc_slist_sublist(CC_SList *list, size_t from, size_t to, CC_SList **out)\\n{\\n    if (from > to || to >= list->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    SNode *base = NULL;\\n    SNode *node = NULL;\\n\\n    CC_SList *sub;\\n    enum cc_stat status = cc_slist_new(&sub);\\n\\n    if (status != CC_OK)\\n        return status;\\n\\n    status = get_node_at(list, from, &node, &base);\\n\\n    if (status != CC_OK) {\\n        cc_slist_destroy(sub);\\n        return status;\\n    }\\n\\n    size_t i;\\n    for (i = from; i <= to; i++) {\\n        status = cc_slist_add(sub, node->data);\\n        if (status != CC_OK) {\\n            cc_slist_destroy(sub);\\n            return status;\\n        }\\n        node = node->next;\\n    }\\n    *out = sub;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a shallow copy of the specified list. A shallow copy is a copy of the\\n * list structure. This operation does not copy the actual data that this list\\n * holds.\\n *\\n * @note The new list is allocated using the original lists allocators and also\\n *       inherits the configuration of the original list.\\n *\\n * @param[in] list CC_SList to be copied\\n * @param[out] out Pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_slist_copy_shallow(CC_SList *list, CC_SList **out)\\n{\\n    CC_SList *copy;\\n    enum cc_stat status = cc_slist_new(&copy);\\n\\n    if (status != CC_OK)\\n        return status;\\n\\n    SNode *node = list->head;\\n\\n    while (node) {\\n        status = cc_slist_add(copy, node->data);\\n        if (status != CC_OK) {\\n            cc_slist_destroy(copy);\\n            return status;\\n        }\\n        node = node->next;\\n    }\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a deep copy of the specified list. This function copies the structure\\n * of the list along with all the data it holds. The element copying is done\\n * through the specified copy function that should return a pointer to the copy\\n * of the element passed to it.\\n *\\n * @note The new list is allocated using the original lists allocators and also\\n *       inherits the configuration of the original list.\\n *\\n * @param[in] list CC_SList to be copied\\n * @param[in] cp   the copy function that should return a pointer to the copy of\\n *                 the data.\\n * @param[out] out Pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_slist_copy_deep(CC_SList *list, void *(*cp) (void*), CC_SList **out)\\n{\\n    CC_SList *copy;\\n    enum cc_stat status = cc_slist_new(&copy);\\n\\n    if (status != CC_OK)\\n        return status;\\n\\n    SNode *node = list->head;\\n\\n    while (node) {\\n        status = cc_slist_add(copy, cp(node->data));\\n        if (status != CC_OK) {\\n            cc_slist_destroy(copy);\\n            return status;\\n        }\\n        node = node->next;\\n    }\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns an integer representing the number of occurrences of the specified\\n * element within the CC_SList.\\n *\\n * @param[in] list CC_SList on which the search is performed\\n * @param[in] element element being searched for\\n *\\n * @return number of found matches\\n */\\nsize_t cc_slist_contains(CC_SList *list, void *element)\\n{\\n    SNode *node = list->head;\\n    size_t e_count = 0;\\n\\n    while (node) {\\n        if (node->data == element)\\n            e_count++;\\n        node = node->next;\\n    }\\n    return e_count;\\n}\\n\\n/**\\n * Returns the number of occurrences of the value pointed to by <code>element</code>\\n * within the specified CC_SList.\\n *\\n * @param[in] list CC_SList on which the search is performed\\n * @param[in] element element being searched for\\n * @param[in] cmp Comparator function which returns 0 if the values passed to it are equal\\n *\\n * @return number of occurrences of the value\\n */\\nsize_t cc_slist_contains_value(CC_SList *list, void *element, int (*cmp) (const void*, const void*))\\n{\\n    SNode *node = list->head;\\n    size_t e_count = 0;\\n\\n    while (node) {\\n        if (cmp(node->data, element) == 0)\\n            e_count++;\\n        node = node->next;\\n    }\\n    return e_count;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the list.\\n *\\n * @param[in] list    the CC_SList on which this operation is performed\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  Pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_slist_index_of(CC_SList *list, void *element, size_t *index)\\n{\\n    SNode *node = list->head;\\n\\n    size_t i = 0;\\n    while (node) {\\n        if (node->data == element) {\\n            *index = i;\\n            return CC_OK;\\n        }\\n        i++;\\n        node = node->next;\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates an array representation of the specified list. None of the elements\\n * are copied into the array and thus any modification of the elements within\\n * the array will affect the list elements as well. The size of the created\\n * array is the same as the size of the list from which the array was constructed.\\n *\\n * @param[in] list CC_SList on which this operation is being performed\\n * @param[out] out Pointer to where the newly created array is stored\\n *\\n * @return CC_OK if the array was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the new array failed.\\n */\\nenum cc_stat cc_slist_to_array(CC_SList *list, void ***out)\\n{\\n    void **array = list->mem_alloc(list->size * sizeof(void*));\\n\\n    if (!array)\\n        return CC_ERR_ALLOC;\\n\\n    SNode *node = list->head;\\n\\n    size_t i;\\n    for (i = 0; i < list->size; i++) {\\n        array[i] = node->data;\\n        node = node->next;\\n    }\\n    *out = array;\\n    return CC_OK;\\n}\\n\\n/**\\n * Sorts the specified list. This function makes no guaranties that the\\n * sort will be performed in place or in a stable way.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the list\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @param[in] list CC_SList to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                int cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first.\\n *\\n * @return CC_OK if the sort was performed successfully, or CC_ERR_ALLOC\\n * if the sort could not allocate enough memory to performed the sort.\\n */\\nenum cc_stat cc_slist_sort(CC_SList *list, int (*cmp) (void const *e1, void const *e2))\\n{\\n    if (list->size == 1)\\n        return CC_OK;\\n\\n    void **elements;\\n    enum cc_stat status = cc_slist_to_array(list, &elements);\\n\\n    if (status != CC_OK)\\n        return status;\\n\\n    SNode *node = list->head;\\n\\n    qsort(elements, list->size, sizeof(void*), cmp);\\n\\n    size_t i;\\n    for (i = 0; i < list->size; i++) {\\n        node->data = elements[i];\\n        node       = node->next;\\n    }\\n    list->mem_free(elements);\\n    return CC_OK;\\n}\\n\\n/**\\n * A 'foreach loop' function that invokes the specified function on each element\\n * in the list.\\n *\\n * @param[in] list the list on which this operation is being performed\\n * @param[in] op the operation function that is to be invoked on each list\\n *               element\\n */\\nvoid cc_slist_foreach(CC_SList *list, void (*op) (void *))\\n{\\n    SNode *n = list->head;\\n\\n    while (n) {\\n        op(n->data);\\n        n = n->next;\\n    }\\n}\\n\\n\\n/**\\n * Filters the CC_SList by creating a new CC_SList that contains all elements from the\\n * original CC_SList that return true on pred(element) without modifying the original\\n * CC_SList.\\n *\\n * @param[in] list Slist that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered CC_SList\\n * @param[out] out pointer to where the new filtered CC_SList is to be stored\\n *\\n * @return CC_OK if the CC_SList was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_SList is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_SList failed.\\n */\\nenum cc_stat cc_slist_filter(CC_SList *list, bool (*pred) (const void*), CC_SList **out)\\n{\\n  if (cc_slist_size(list) == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    CC_SList *filtered = NULL;\\n    cc_slist_new(&filtered);\\n\\n    if (!filtered)\\n        return CC_ERR_ALLOC;\\n\\n    SNode *curr = list->head;\\n    while (curr) {\\n        if (pred(curr->data)) {\\n\\t  cc_slist_add(filtered, curr->data);\\n        }\\n\\n        curr = curr->next;\\n    }\\n\\n    *out = filtered;\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Filters the CC_SList by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] list Slist that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the Slist\\n *\\n * @return CC_OK if the Slist was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the Slist is empty.\\n */\\nenum cc_stat cc_slist_filter_mut(CC_SList *list, bool (*pred) (const void*))\\n{\\n    if (cc_slist_size(list) == 0)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    SNode *curr = list->head;\\n    SNode *next = NULL, *prev =NULL;\\n\\n    while (curr) {\\n        next = curr->next;\\n\\n        if (!pred(curr->data)) {\\n            unlinkn(list, curr, prev);\\n        } else {\\n            prev = curr;\\n\\t}\\n        curr = next;\\n    }\\n\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] list CC_SList to iterate over\\n */\\nvoid cc_slist_iter_init(CC_SListIter *iter, CC_SList *list)\\n{\\n    iter->index   = 0;\\n    iter->list    = list;\\n    iter->current = NULL;\\n    iter->prev    = NULL;\\n    iter->next    = list->head;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_slist_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_slist_iter_next()</code>\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out Pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND\\n */\\nenum cc_stat cc_slist_iter_remove(CC_SListIter *iter, void **out)\\n{\\n    if (!iter->current)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    void *e = unlinkn(iter->list, iter->current, iter->prev);\\n    iter->current = NULL;\\n    iter->index--;\\n\\n    if (out)\\n        *out = e;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the list after the last returned element by\\n * <code>cc_slist_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_slist_iter_next()</code>\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, or CC_ERR_ALLOC\\n * if the memory allocation for the new element failed.\\n */\\nenum cc_stat cc_slist_iter_add(CC_SListIter *iter, void *element)\\n{\\n    SNode *new_node = iter->list->mem_calloc(1, sizeof(SNode));\\n\\n    if (!new_node)\\n        return CC_ERR_ALLOC;\\n\\n    new_node->data = element;\\n    new_node->next = iter->next;\\n\\n    iter->current->next = new_node;\\n\\n    if (iter->index == iter->list->size)\\n        iter->list->tail = new_node;\\n\\n    iter->index++;\\n    iter->list->size++;\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_slist_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_slist_iter_next()</code>\\n\\n * @param[in] iter the iterator on which this operation is being preformed\\n * @param[in] element the replacement element\\n * @param[out] out Pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_VALUE_NOT_FOUND\\n */\\nenum cc_stat cc_slist_iter_replace(CC_SListIter *iter, void *element, void **out)\\n{\\n    if (!iter->current)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    void *old = iter->current->data;\\n    iter->current->data = element;\\n\\n    if (out)\\n        *out = old;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the value of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out Pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the list has been reached.\\n */\\nenum cc_stat cc_slist_iter_next(CC_SListIter *iter, void **out)\\n{\\n    if (!iter->next)\\n        return CC_ITER_END;\\n\\n    void *data = iter->next->data;\\n\\n    if (iter->current)\\n        iter->prev = iter->current;\\n\\n    iter->current = iter->next;\\n    iter->next = iter->next->next;\\n    iter->index++;\\n\\n    *out = data;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_slist_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index\\n */\\nsize_t cc_slist_iter_index(CC_SListIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter Iterator that is being initialized\\n * @param[in] l1   First CC_SList\\n * @param[in] l2   Second CC_SList\\n */\\nvoid cc_slist_zip_iter_init(CC_SListZipIter *iter, CC_SList *l1, CC_SList *l2)\\n{\\n    iter->index      = 0;\\n    iter->l1         = l1;\\n    iter->l2         = l2;\\n    iter->l1_current = NULL;\\n    iter->l2_current = NULL;\\n    iter->l1_prev    = NULL;\\n    iter->l2_prev    = NULL;\\n    iter->l1_next    = l1->head;\\n    iter->l2_next    = l2->head;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter Iterator that is being advanced\\n * @param[out] out1 Output of the first CC_SList element\\n * @param[out] out2 Output of the second CC_SList element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the lists has been reached.\\n */\\nenum cc_stat cc_slist_zip_iter_next(CC_SListZipIter *iter, void **out1, void **out2)\\n{\\n    if (!iter->l1_next || !iter->l2_next)\\n        return CC_ITER_END;\\n\\n    void *data1 = iter->l1_next->data;\\n    void *data2 = iter->l2_next->data;\\n\\n    if (iter->l1_current)\\n        iter->l1_prev = iter->l1_current;\\n\\n    if (iter->l2_current)\\n        iter->l2_prev = iter->l2_current;\\n\\n    iter->l1_current = iter->l1_next;\\n    iter->l2_current = iter->l2_next;\\n    iter->l1_next    = iter->l1_next->next;\\n    iter->l2_next    = iter->l2_next->next;\\n\\n    iter->index++;\\n\\n    *out1 = data1;\\n    *out2 = data2;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element pair to the slists after the last returned element pair by\\n * <code>cc_slist_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_slist_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_slist_zip_iter_next()</code>\\n *\\n * @param[in] iter Iterator on which this operation is being performed\\n * @param[in] e1   element added to the first slist\\n * @param[in] e2   element added to the second slist\\n *\\n * @return CC_OK if the element pair was successfully added to the slists, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_slist_zip_iter_add(CC_SListZipIter *iter, void *e1, void *e2)\\n{\\n    SNode *new_node1 = iter->l1->mem_calloc(1, sizeof(SNode));\\n\\n    if (!new_node1)\\n        return CC_ERR_ALLOC;\\n\\n    SNode *new_node2 = iter->l2->mem_calloc(1, sizeof(SNode));\\n\\n    if (!new_node2) {\\n        iter->l1->mem_free(new_node1);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    new_node1->data = e1;\\n    new_node2->data = e2;\\n\\n    new_node1->next = iter->l1_next;\\n    new_node2->next = iter->l2_next;\\n\\n    iter->l1_current->next = new_node1;\\n    iter->l2_current->next = new_node2;\\n\\n    if (iter->index == iter->l1->size)\\n        iter->l1->tail = new_node1;\\n\\n    if (iter->index == iter->l2->size)\\n        iter->l2->tail = new_node2;\\n\\n    iter->index++;\\n    iter->l1->size++;\\n    iter->l2->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_slist_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_slist_zip_iter_next()</code>\\n *\\n * @param[in]  iter Iterator on which this operation is being performed\\n * @param[out] out1 Output of the removed element from the first Slist\\n * @param[out] out2 Output of the removed element from the second Slist\\n *\\n * @return CC_OK of the element was successfully removed, or CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_slist_zip_iter_remove(CC_SListZipIter *iter, void **out1, void **out2)\\n{\\n    if (!iter->l1_current || !iter->l2_current)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    void *e1 = unlinkn(iter->l1, iter->l1_current, iter->l1_prev);\\n    void *e2 = unlinkn(iter->l2, iter->l2_current, iter->l2_prev);\\n\\n    iter->l1_current = NULL;\\n    iter->l2_current = NULL;\\n\\n    iter->index--;\\n\\n    if (out1)\\n        *out1 = e1;\\n\\n    if (out2)\\n        *out2 = e2;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_slist_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_slist_zip_iter_next()</code>\\n *\\n * @param[in]  iter Iterator on which this operation is being performed\\n * @param[in]  e1   First slist's replacement element\\n * @param[in]  e2   Second slist's replacement element\\n * @param[out] out1 Output of the replaced element from the first slist\\n * @param[out] out2 Output of the replaced element from the second slist\\n *\\n * @return CC_OK of the element was successfully replaced, or CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_slist_zip_iter_replace(CC_SListZipIter *iter, void *e1, void *e2, void **out1, void **out2)\\n{\\n    if (!iter->l1_current || !iter->l2_current)\\n        return CC_ERR_VALUE_NOT_FOUND;\\n\\n    void *old1 = iter->l1_current->data;\\n    void *old2 = iter->l2_current->data;\\n\\n    iter->l1_current->data = e1;\\n    iter->l2_current->data = e2;\\n\\n    if (out1)\\n        *out1 = old1;\\n\\n    if (out2)\\n        *out2 = old2;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_slist_zip_iter_next()</code>.\\n *\\n * @param[in] iter Iterator on which this operation is being performed\\n *\\n * @return current iterator index\\n */\\nsize_t cc_slist_zip_iter_index(CC_SListZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Unlinks the node from the list and returns the data that was associated with it and\\n * also adjusts the head / tail of the list if necessary.\\n *\\n * @param[in] list the list from which the node is being unlinked\\n * @parma[in] node the node being unlinked\\n * @param[in] prev the node that immediately precedes the node that is being unlinked\\n *\\n * @return the data that was at this node\\n */\\nstatic void *unlinkn(CC_SList *list, SNode *node, SNode *prev)\\n{\\n    void *data = node->data;\\n\\n    if (prev)\\n        prev->next = node->next;\\n    else\\n        list->head = node->next;\\n\\n    if (!node->next)\\n        list->tail = prev;\\n\\n    list->mem_free(node);\\n    list->size--;\\n\\n    return data;\\n}\\n\\n/**\\n * Unlinks all nodes from the list and optionally frees the data at the nodes.\\n *\\n * @param[in] list the list from which all nodes are being unlinked\\n * @param[in] freed specified whether or not the data at the nodes should also\\n *                  be deallocated.\\n *\\n * @return false if the list is already y empty, otherwise returns true\\n */\\nstatic bool unlinkn_all(CC_SList *list, void (*cb) (void*))\\n{\\n    if (list->size == 0)\\n        return false;\\n\\n    SNode *n = list->head;\\n\\n    while (n) {\\n        SNode *tmp = n->next;\\n\\n        if (cb)\\n            cb(n->data);\\n\\n        list->mem_free(n);\\n        n = tmp;\\n        list->size--;\\n    }\\n    return true;\\n}\\n\\n/**\\n * Finds the node at the specified index. If the index is not in the bounds\\n * of the list, NULL is returned instead.\\n *\\n * @param[in] list the list from which the node is being returned\\n * @param[in] index the index of the node\\n * @param[out] node the node at the specified index\\n * @param[out] prev the node that immediately precedes the node at the\\n *                  specified index\\n *\\n * @return CC_OK if the node was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nstatic enum cc_stat\\nget_node_at(CC_SList *list, size_t index, SNode **node, SNode **prev)\\n{\\n    if (index >= list->size)\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    *node = list->head;\\n    *prev = NULL;\\n\\n    size_t i;\\n    for (i = 0; i < index; i++) {\\n        *prev = *node;\\n        *node = (*node)->next;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Finds the first node from the beginning of the list that is associated\\n * with the specified element. If no node is associated with the element,\\n * NULL is returned instead.\\n *\\n * @param[in] list the list from which the node is being returned\\n * @param[in] element the element whose list node is being returned\\n * @param[out] node the node associated with the data\\n * @param[out] prev the node that immediately precedes the node at the\\n *                  specified index\\n *\\n * @return CC_OK if the node was found, or CC_ERR_VALUE_NOT_FOUND if not.\\n */\\nstatic enum cc_stat\\nget_node(CC_SList *list, void *element, SNode **node, SNode **prev)\\n{\\n   *node = list->head;\\n   *prev = NULL;\\n\\n    while (*node) {\\n        if ((*node)->data == element)\\n            return CC_OK;\\n\\n        *prev = *node;\\n        *node = (*node)->next;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\nsize_t cc_slist_struct_size()\\n{\\n    return sizeof(CC_SList);\\n}\", \"embeddings\": [0.021099679172039032, 0.028913132846355438, 0.028647346422076225, 0.0924910455942154, 0.2897146940231323, -0.15384234488010406, 0.13548821210861206, 0.37323102355003357, -0.033810582011938095, -0.2911776900291443, 0.01300153136253357, -0.11819002777338028, 0.033438295125961304, 0.026865340769290924, -0.02268887311220169, -0.010106205940246582, 0.1724056750535965, -0.01810283213853836, 0.042197246104478836, -0.35641545057296753, -0.16470779478549957, 0.14419963955879211, 0.1912437379360199, 0.14030881226062775, 0.19164657592773438, 0.08439141511917114, 0.19526243209838867, 0.10362275689840317, 0.36193177103996277, -0.19096125662326813, 0.02673134207725525, -0.11688443273305893, 0.06524284929037094, -0.1285575032234192, 0.05252680554986, 0.007627807557582855, 0.048620983958244324, 0.06516403704881668, -0.002107621170580387, 0.025654152035713196, -0.1551397740840912, -0.019619503989815712, 0.10650769621133804, 0.16858892142772675, 0.08889882266521454, -0.03546833246946335, 0.08630044013261795, 0.2225368320941925, -0.07350099086761475, 0.055717963725328445, 0.09951941668987274, -0.03691999986767769, 0.003111777827143669, -0.013543449342250824, -0.03493020310997963, -0.07242788374423981, -0.030657831579446793, 0.35727590322494507, 0.05039162188768387, -0.014279298484325409, -0.013039104640483856, 0.0024531781673431396, -0.144182026386261, 0.18896573781967163, 0.12790924310684204, 0.03085462376475334, -0.09765978157520294, -0.25881099700927734, -0.02763747051358223, -0.029012545943260193, 0.08914424479007721, 0.0780126079916954, 0.08752886950969696, -0.19436538219451904, -0.1733739823102951, -0.14155404269695282, 0.08895794302225113, 0.5946524143218994, -0.009829657152295113, 0.16612036526203156, 0.22913183271884918, -0.06670105457305908, 0.07526668161153793, 0.21601679921150208, 0.2173561304807663, 0.013578047975897789, -0.11008956283330917, 0.08192845433950424, -0.018851161003112793, 0.16364562511444092, 0.049955327063798904, 0.2217261642217636, -0.05927611142396927, -0.03740060701966286, -0.027142703533172607, 0.03212518244981766, 0.11855412274599075, -0.22311413288116455, 0.062213052064180374, 0.3692150413990021, -0.052381303161382675, -0.07844653725624084, -0.30844274163246155, -0.10889311134815216, -0.046160466969013214, 0.04150926694273949, -0.05426669865846634, 0.07455915212631226, 0.05124044790863991, -0.06450171023607254, 0.07239799201488495, 0.03628662973642349, -0.054581351578235626, 0.07391119003295898, 0.02393203228712082, -0.14184734225273132, 0.1502762734889984, -0.03153325617313385, 0.18162888288497925, -0.1294812560081482, 0.17712296545505524, 0.020156659185886383, 0.012930341064929962, -0.13199526071548462, -0.10809803009033203, 0.006932813674211502, -0.006283290684223175, -0.19465044140815735, 0.080523781478405, 0.05293921381235123, -0.003355875611305237, -0.10531551390886307, 0.00946589931845665, -0.01559053361415863, 0.19489270448684692, 0.018679533153772354, 0.1304215043783188, 0.051758021116256714, 0.04245104268193245, -0.0453326478600502, -0.006421409547328949, 0.034906089305877686, 0.24506597220897675, -0.007872525602579117, 0.11727531999349594, -0.2440754622220993, 0.1870144009590149, 0.11649523675441742, -0.35947147011756897, -0.296485036611557, 0.005883201956748962, -0.12891161441802979, -0.012530215084552765, 0.025882892310619354, -0.14369075000286102, 0.7906030416488647, 0.05692940577864647, -0.10166450589895248, -0.09364564716815948, -0.045792751014232635, 0.03904131054878235, -0.3609911799430847, -0.12031811475753784, 0.1672571301460266, 0.05592719092965126, 0.12180274724960327, 0.08900147676467896, 0.1072123721241951, 0.16008996963500977, 0.027011550962924957, 0.09166288375854492, -0.0790185034275055, -0.08581972122192383, 0.1477145105600357, 0.08410673588514328, -0.09109055250883102, -0.17781268060207367, 0.09283600747585297, -0.08205674588680267, 0.05404330790042877, -0.16173812747001648, -0.04827293008565903, -0.18993043899536133, -0.06892448663711548, -0.03726061433553696, -0.018729984760284424, -0.005262870341539383, -0.10833290219306946, 0.07708349823951721, -0.00331014022231102, 0.03369426727294922, 0.033474333584308624, 0.16445507109165192, -0.0672224760055542, -0.09215190261602402, -0.017330780625343323, -0.09593986719846725, -0.024083076044917107, 0.23444119095802307, -0.04371523857116699, -0.0018521081656217575, -0.16436034440994263, 0.20546364784240723, -0.08628733456134796, 0.06488516926765442, 0.12563782930374146, -0.27601346373558044, -0.03614336997270584, -0.01659911498427391, -0.13099274039268494, -0.09728284180164337, 0.11356575787067413, 0.04785367101430893, 0.0007617846131324768, -0.06796351075172424, -0.0791308805346489, 0.11144159734249115, 0.18459531664848328, 0.09470893442630768, -0.06265386939048767, 0.10252542793750763, 0.22269055247306824, -0.09175403416156769, -0.006069667637348175, -0.1700930893421173, 0.17293381690979004, 0.19271886348724365, 0.06820917129516602, -0.06428073346614838, 0.09102978557348251, 0.19096936285495758, 0.2609254717826843, -0.23832623660564423, 0.11324763298034668, -0.0011021420359611511, -0.24793362617492676, -0.024826079607009888, 0.03307648375630379, 0.0020502880215644836, -0.13381026685237885, -0.09386302530765533, 0.18442463874816895, 0.18409967422485352, 0.2910667359828949, 0.018292240798473358, 0.0338367335498333, -0.19712983071804047, 0.0828506201505661, -0.13143578171730042, 0.08229587972164154, 0.017303846776485443, 0.00595425721257925, -0.02023579180240631, -0.14206765592098236, -0.15929964184761047, -0.06246655061841011, -0.17747224867343903, -0.043412040919065475, 0.0610409677028656, 0.1453651338815689, -0.024013519287109375, -0.06981483846902847, 0.0763009712100029, 0.0031569302082061768, -0.08329735696315765, -0.43420520424842834, -0.025709323585033417, 0.11931045353412628, 0.10285191237926483, -0.027115315198898315, 0.06765147298574448, -0.07278057932853699, 0.19696685671806335, 0.12510566413402557, 0.09606713056564331, -0.007733464241027832, -0.053576499223709106, 0.06309781223535538, -0.10782446712255478, -0.0036211609840393066, -0.02283194288611412, 0.0775732547044754, -0.09644516557455063, 0.1526806652545929, 0.05442075803875923, 0.025271208956837654, 0.1659436672925949, 0.044855326414108276, 0.03394266590476036, 0.04216134175658226, 0.05409267544746399, 0.051616355776786804, 0.20761288702487946, 0.12855808436870575, 0.029352203011512756, 0.08791419863700867, 0.24902555346488953, -0.10987900197505951, 0.014413811266422272, -0.3244195878505707, 0.12578389048576355, -0.23674461245536804, 0.04242642596364021, 0.04028975963592529, 0.40350446105003357, -0.025302570313215256, 0.01678111031651497, 0.02937493845820427, 0.2580476999282837, 0.10405414551496506, 0.09264597296714783, 0.1404085010290146, -0.11978264898061752, 0.11294479668140411, -0.13224045932292938, 0.07787932455539703, -0.02801741100847721, -0.06200158968567848, 0.12186157703399658, 0.06145726144313812, -0.0459059439599514, 0.07541684806346893, 0.1738707274198532, 0.18407857418060303, 0.04699414223432541, 0.06883715093135834, 0.11993381381034851, -0.042908575385808945, -0.17230606079101562, 0.6379385590553284, -0.5087084770202637, 0.24358400702476501, -0.19027858972549438, 0.36707639694213867, -0.06979295611381531, 0.30940955877304077, -0.07724473625421524, 0.1537548005580902, 0.11170274764299393, 0.1567496657371521, -0.16759608685970306, -0.08583663403987885, -0.09954427182674408, 0.2516627907752991, 0.19989217817783356, 0.13052362203598022, 0.23735198378562927, -0.037557732313871384, 0.11340613663196564, -0.04605346545577049, -0.11904032528400421, 0.13562534749507904, 0.010648168623447418, -0.13345254957675934, 0.09730864316225052, 0.35006147623062134, -0.16121214628219604, -0.06807075440883636, 0.043949104845523834, 0.028464287519454956, 0.20209810137748718, -0.20666947960853577, 0.15846595168113708, -0.10062333941459656, 0.2950320243835449, -0.44139087200164795, -0.33189889788627625, 0.05199752375483513, -0.14577457308769226, 0.10661525279283524, 0.11695733666419983, 0.21057572960853577, 0.21726396679878235, -0.3012799918651581, 0.05243095010519028, -0.04818371310830116, -0.09374313056468964, 0.0705610141158104, 0.0797179788351059, 0.09917421638965607, 0.10810578614473343, 0.058404769748449326, 0.038017190992832184, 0.05249974504113197, 0.04859882593154907, -0.11881718784570694, 0.21731440722942352, 0.16366568207740784, 0.2650476396083832, -0.11247430741786957, 0.12283109128475189, -0.1808864027261734, 0.13416358828544617, -0.056443627923727036, 0.043298423290252686, -0.018748734146356583, -0.07300081104040146, 0.11483809351921082, -0.14863744378089905, -0.08774316310882568, 0.1603463590145111, 0.2488079071044922, -0.06553429365158081, 0.1786891371011734, 0.09956628084182739, 0.07337979227304459, 0.15115362405776978, -0.10011191666126251, -0.13235409557819366, -0.16131140291690826, 0.08291187882423401, 0.06769450008869171, 0.06419055163860321, 0.043907634913921356, 0.16246670484542847, -0.13719865679740906, 0.0403539314866066, -0.4384962320327759, -0.10610631853342056, 0.17142143845558167, 0.12029729038476944, 0.1059727668762207, 0.00674925372004509, -0.22471404075622559, -0.026241205632686615, 0.011287585832178593, -0.026550233364105225, -0.13774946331977844, 0.04333607107400894, -0.18317130208015442, 0.08172615617513657, 0.24742352962493896, 0.08738042414188385, 0.0690225288271904, 0.12058579176664352, -0.07858812808990479, -0.09405900537967682, 0.002424348145723343, 0.018933599814772606, 0.06660192459821701, -0.11550092697143555, 0.08546718955039978, 0.057453714311122894, 0.1361539214849472, 0.009763666428625584, -0.0716460719704628, 0.3710220754146576, 0.11237756907939911, -0.15863925218582153, 0.0556611493229866, -0.1902935951948166, 0.011659875512123108, -0.034073177725076675, -0.4097926914691925, 0.1110384464263916, 0.22757482528686523, 0.08382219076156616, 0.035373471677303314, 0.09000974893569946, 0.01301845908164978, 0.053895581513643265, 0.09680785238742828, -0.06267225742340088, -0.17715325951576233, 0.02674153447151184, -0.06417789310216904, 0.09143383800983429, 0.056297317147254944, 0.21154692769050598, 0.09470055997371674, 0.09492582082748413, 0.158913716673851, 0.08380809426307678, -0.07546146959066391, 0.07016277313232422, 0.0001847296953201294, -0.08946587145328522, -0.1827056109905243, 0.08973769843578339, -0.13952159881591797, -0.027489788830280304, 0.11172400414943695, 0.1814185082912445, 0.014029465615749359, -0.01786302961409092, -0.1431277096271515, 0.25125575065612793, 0.14263220131397247, -0.1351882666349411, 0.02398785576224327, -0.09292107820510864, 0.1195218414068222, 0.027832642197608948, 0.14501461386680603, 0.2643204927444458, 0.17866992950439453, 0.07945914566516876, 0.14970794320106506, 0.3136250674724579, -0.13982076942920685, -0.004110217094421387, 0.1099712997674942, 0.0505794882774353, -0.11865794658660889, -0.16770446300506592, -0.14250540733337402, -0.05368070304393768, 0.06936157494783401, 0.20468126237392426, -0.14730623364448547, -0.021061819046735764, -0.010694481432437897, 0.1820189356803894, -0.028101846575737, 0.06470110267400742, 0.11387698352336884, 0.014579720795154572, 0.018122700974345207, -0.1466950923204422, 0.2505206763744354, -0.19755421578884125, -0.11312265694141388, -0.07456892728805542, 0.005416989326477051, -0.09582681953907013, 0.07412660121917725, 0.11180365085601807, 0.04274760186672211, 0.12312371283769608, 0.04445268586277962, -0.04775909334421158, -0.002514077350497246, 0.09199334681034088, 0.19125016033649445, -0.12963642179965973, 0.03170682489871979, 0.0996614545583725, 0.06497904658317566, 0.2481442093849182, -0.07337041944265366, -0.23696230351924896, -0.1208941861987114, 0.21113836765289307, -0.05635029450058937, 0.20882001519203186, -0.01152799278497696, 0.17801806330680847, 0.11409994214773178, -0.05915486067533493, 0.04883190616965294, -0.05436265841126442, -0.8213629126548767, -0.05863772705197334, 0.15241356194019318, -0.004867378622293472, 0.04947058856487274, 0.14442065358161926, 0.049851447343826294, 0.07936491817235947, 0.12678547203540802, 0.05480106174945831, 0.0038694851100444794, 0.21196362376213074, 0.18159987032413483, -0.14415843784809113, -0.18908725678920746, 0.10198748111724854, 0.11164701730012894, -0.24255597591400146, 0.2283441722393036, -0.09001857042312622, -0.1256560981273651, 0.036084674298763275, 0.3321654498577118, -0.07023554295301437, 0.05289658159017563, 0.25105783343315125, 0.09890235960483551, 0.23295029997825623, -0.1131415069103241, 0.06768108904361725, 0.2699386775493622, 0.13888846337795258, -0.3127799332141876, 0.03317716717720032, 0.0427311509847641, 0.1453283727169037, 0.07413464784622192, 13.757286071777344, -0.08808474242687225, 0.23828013241291046, -0.19558605551719666, -0.11139728873968124, -0.03151080757379532, -0.06435949355363846, 0.04845675453543663, 0.01969853788614273, -0.0017079636454582214, 0.04659249633550644, -0.09953532367944717, 0.06258104741573334, 0.014455046504735947, -0.05610029399394989, -0.04567217826843262, -0.08622390031814575, -0.08816280215978622, 0.15608161687850952, 0.03730393946170807, -0.20430722832679749, -0.14496827125549316, -0.0572299063205719, -0.3771290183067322, -0.05404616519808769, -0.02111879736185074, 0.15399357676506042, 0.009765148162841797, 0.03004458174109459, 0.056998442858457565, 0.27375760674476624, 0.12531697750091553, 0.12764419615268707, -0.026914678514003754, 0.0720810666680336, -0.00026141898706555367, -0.43783605098724365, -0.19091126322746277, 0.0535195991396904, 0.02240068092942238, 0.008840285241603851, 0.06460541486740112, 0.1784714311361313, -0.09146369248628616, 0.10065655410289764, 0.09243393689393997, -0.2581944167613983, 0.1607881486415863, -0.1774643063545227, -0.07225847244262695, 0.21471768617630005, 0.09680050611495972, 0.2986140251159668, -0.0029030032455921173, -0.13907721638679504, -0.22588402032852173, 0.3057255148887634, 0.002580437809228897, -0.052211225032806396, 0.42554739117622375, -0.007128309458494186, -0.08592536300420761, -0.0719955712556839, 0.034855879843235016, -0.015391278080642223, 0.04911884292960167, 0.08575871586799622, 0.06039919704198837, -0.2310413271188736, 0.09868858754634857, 0.21552732586860657, -0.19961464405059814, 0.14467400312423706, -0.019836515188217163, 0.003716167062520981, 0.05774657428264618, 0.023781798779964447, -0.0367417074739933, 0.036107540130615234, -0.10619185864925385, 0.01605706289410591, 0.0807541236281395, -0.21657012403011322, -0.14343950152397156, -0.33193325996398926, 0.08674617111682892, -0.11201384663581848, 0.14235669374465942, 0.24866971373558044, -0.04461558163166046, -0.03543669730424881, 0.05097062140703201, -0.024380147457122803, -0.1672183871269226, 0.20484411716461182, -0.014168940484523773, -0.10088294744491577, -0.1389644742012024, 0.08188298344612122, 0.17539864778518677, -0.03851071745157242, -0.10269148647785187, -0.011638123542070389, -0.029057607054710388, -0.052083179354667664, 0.0410415381193161, -0.04325658828020096, 0.01428636908531189, -0.04044707119464874, 0.01034570299088955, 0.04957710579037666, 0.066649429500103, 0.13151635229587555, -0.16623662412166595, -0.12642914056777954, -0.022392604500055313, 0.02906983159482479, -0.0005309619009494781, 0.2695392966270447, 0.06790164858102798, 0.15973857045173645, 0.04480789601802826, -0.15947693586349487, -0.024848420172929764, 0.07906559109687805, -0.1697884202003479, 0.02982739917933941, 0.2205064594745636, 0.10056423395872116, -0.032785724848508835, 0.04278036579489708, -0.0539495125412941, 0.37558513879776, 0.11834404617547989, 0.019926846027374268, -0.06558428704738617, 0.026790723204612732, 0.05267428979277611, 0.07337026298046112, 0.21013934910297394, 0.07127521932125092, -0.017646171152591705, 0.2072765976190567, -0.1795835644006729, -0.0224606916308403, 0.2921369671821594, 0.21160078048706055, 0.017378870397806168, -0.10501624643802643, 0.20564177632331848, 0.14484304189682007, 0.1615428626537323, -0.19577960669994354, -0.09299655258655548, -0.05632892623543739, -0.13024111092090607, -0.1491236537694931, 0.025323521345853806, -0.04070845991373062, -0.01015335600823164, 0.1615315079689026, -0.3506202697753906, 0.11039435863494873, -0.2574158310890198, -0.009399116039276123, 0.02649744600057602, 0.04200409725308418, 0.13209980726242065, 0.05172558128833771, -0.13419368863105774, 0.04718366265296936, 0.10016816109418869, -0.17966414988040924, 0.012284575030207634, -0.017774198204278946, 0.11156699061393738, 0.23301509022712708, -0.49311184883117676, -0.17987607419490814, 0.09101460874080658]}"
"{\"sha\": \"8490a88f377d8fed802e4f3b2d1d87a0d6cb81b2\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/sized/cc_array_sized.c\", \"func_name\": \"cc_array_sized_contains\", \"original_string\": \"size_t cc_array_sized_contains(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t o = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) {\\n            // Mismatching byte, skip block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            // Last byte is equal, match found\\n            if (j == ar->data_length - 1) {\\n                o++;\\n            }\\n        }\\n    }\\n    return o;\\n}\", \"code_tokens\": [\"size_t\", \"cc_array_sized_contains\", \"(\", \"CC_ArraySized\", \"*\", \"ar\", \",\", \"uint8_t\", \"*\", \"element\", \")\", \"{\", \"size_t\", \"o\", \"=\", \"0\", \";\", \"for\", \"(\", \"size_t\", \"i\", \"=\", \"0\", \";\", \"i\", \"<\", \"ar\", \"->\", \"size\", \";\", \"i\", \"++\", \")\", \"{\", \"for\", \"(\", \"size_t\", \"j\", \"=\", \"0\", \";\", \"j\", \"<\", \"ar\", \"->\", \"data_length\", \";\", \"j\", \"++\", \")\", \"{\", \"if\", \"(\", \"ar\", \"->\", \"buffer\", \"[\", \"INDEX\", \"(\", \"ar\", \",\", \"i\", \"+\", \"j\", \")\", \"]\", \"!=\", \"*\", \"(\", \"element\", \"+\", \"j\", \")\", \")\", \"{\", \"break\", \";\", \"}\", \"if\", \"(\", \"j\", \"==\", \"ar\", \"->\", \"data_length\", \"-\", \"1\", \")\", \"{\", \"o\", \"++\", \";\", \"}\", \"}\", \"}\", \"return\", \"o\", \";\", \"}\"], \"docstring\": \"/**\\n * Returns the number of occurrences of the element within the specified CC_ArraySized.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Returns\", \"the\", \"number\", \"of\", \"occurrences\", \"of\", \"the\", \"element\", \"within\", \"the\", \"specified\", \"CC_ArraySized\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"ar\", \"array\", \"that\", \"is\", \"being\", \"searched\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"element\", \"the\", \"element\", \"that\", \"is\", \"being\", \"searched\", \"for\", \"*\", \"*\", \"@return\", \"the\", \"number\", \"of\", \"occurrences\", \"of\", \"the\", \"element\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2024 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n\\n#include \\\"sized/cc_array_sized.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\n#define INDEX(a, i) a->data_length * i\\n#define BUF_ADDR(a, i) &a->buffer[a->data_length * i]\\n\\n\\nstruct cc_array_sized_s {\\n    size_t   data_length;\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    uint8_t *buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[in] Size of the array element in bytes\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new(size_t element_size, CC_ArraySized **out)\\n{\\n    CC_ArraySizedConf c;\\n    cc_array_sized_conf_init(&c);\\n    return cc_array_sized_new_conf(element_size, &c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_ArraySized based on the specified CC_ArraySizedConf struct \\n * and returns a status code.\\n *\\n * The CC_ArraySized is allocated using the allocators specified in the CC_ArraySizedConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArraySizedConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] element_size the size of the data being stored in bytes\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new_conf(\\n    size_t element_size, \\n    CC_ArraySizedConf const * const conf, \\n    CC_ArraySized **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_ArraySized *ar = conf->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    uint8_t *buff = conf->mem_alloc(conf->capacity * element_size);\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->data_length = element_size;\\n    ar->buffer      = buff;\\n    ar->exp_factor  = ex;\\n    ar->capacity    = conf->capacity;\\n    ar->mem_alloc   = conf->mem_alloc;\\n    ar->mem_calloc  = conf->mem_calloc;\\n    ar->mem_free    = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArraySizedConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArraySizedConf structure that is being initialized\\n */\\nvoid cc_array_sized_conf_init(CC_ArraySizedConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_ArraySized structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_sized_destroy(CC_ArraySized *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n\\n/**\\n * Adds a new element to the CC_ArraySized. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_ArraySized.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add(CC_ArraySized *ar, uint8_t *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    memcpy(BUF_ADDR(ar, ar->size), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add_at(CC_ArraySized *ar, uint8_t *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_sized_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * ar->data_length;\\n\\n    memmove(BUF_ADDR(ar, (index + 1)),\\n            BUF_ADDR(ar, index),\\n            shift);\\n\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_ArraySized.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_replace_at(CC_ArraySized *ar, uint8_t *element, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n* Swaps the values at the specified indices.\\n*\\n* @param[in] ar array whose elements are being swapped\\n* @param[in] index1 first position\\n* @param[in] index2 second position\\n* \\n* @return CC_OK if the operation was successful, or CC_ERR_OUT_OF_RANGE if \\n* one of the indices was out of range.\\n*/\\nenum cc_stat cc_array_sized_swap_at(CC_ArraySized *ar, size_t index1, size_t index2)\\n{\\n    if (index1 >= ar->size || index2 >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n\\n    for (size_t i = 0; i < ar->data_length; i++) {\\n        uint8_t tmp = ar->buffer[INDEX(ar, index1 + i)];\\n        ar->buffer[INDEX(ar, index1 + i)] = ar->buffer[INDEX(ar, index2 + i)];\\n        ar->buffer[INDEX(ar, index2 + i)] = tmp;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_ArraySized if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_sized_remove(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_sized_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n \\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_remove_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_sized_remove_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    return cc_array_sized_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_sized_remove_all(CC_ArraySized *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Copies an CC_ArraySized element from the specified index to the out pointer.\\n * The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] source index of the array element\\n * @param[out] destination address\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_sized_get_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_sized_get_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n    return cc_array_sized_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n* Returns the pointer to the element at the specified index\\n*/\\nenum cc_stat cc_array_sized_peek(CC_ArraySized* ar, size_t index, uint8_t** out)\\n{\\n    if (index > ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    *out = BUF_ADDR(ar, index);\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst uint8_t * const* cc_array_sized_get_buffer(CC_ArraySized *ar)\\n{\\n    return (const uint8_t* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_ArraySized.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_sized_index_of(CC_ArraySized *ar, uint8_t *element, size_t *index)\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) { \\n            // Mismatching byte, skip to next block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            if (j == ar->data_length - 1) {\\n                *index = i;\\n                return CC_OK;\\n            }\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_ArraySized, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_ArraySized, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's allocators\\n *       and it also inherits the configuration of the original CC_ArraySized.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_sized_subarray(CC_ArraySized *ar, size_t b, size_t e, CC_ArraySized **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_ArraySized *sub_ar = ar->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * ar->data_length))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc   = ar->mem_alloc;\\n    sub_ar->mem_calloc  = ar->mem_calloc;\\n    sub_ar->mem_free    = ar->mem_free;\\n    sub_ar->size        = e - b + 1;\\n    sub_ar->capacity    = sub_ar->size;\\n    sub_ar->data_length = ar->data_length;\\n\\n    memcpy(sub_ar->buffer,\\n           BUF_ADDR(ar, b),\\n           sub_ar->size * ar->data_length);\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a copy of the specified CC_ArraySized. \\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's\\n *       allocators and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_sized_copy(CC_ArraySized *ar, CC_ArraySized **out)\\n{\\n    CC_ArraySized *copy = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->data_length = ar->data_length;\\n    copy->exp_factor  = ar->exp_factor;\\n    copy->size        = ar->size;\\n    copy->capacity    = ar->capacity;\\n    copy->mem_alloc   = ar->mem_alloc;\\n    copy->mem_calloc  = ar->mem_calloc;\\n    copy->mem_free    = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * ar->data_length);\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_ArraySized was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_ArraySized is empty.\\n */\\nenum cc_stat cc_array_sized_filter_mut(CC_ArraySized *ar, bool (*pred) (const uint8_t*))\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(BUF_ADDR(ar, i))) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * ar->data_length;\\n                memmove(BUF_ADDR(ar, (i + 1)),\\n                        BUF_ADDR(ar, (i + 1 + rm)),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * ar->data_length;\\n        memmove(BUF_ADDR(ar, 0),\\n                BUF_ADDR(ar, rm),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by creating a new CC_ArraySized that contains all elements\\n * from the original CC_ArraySized that return true on pred(element) without modifying \\n * the original CC_ArraySized.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_sized_filter(CC_ArraySized *ar, bool (*pred) (const uint8_t*), CC_ArraySized **out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    CC_ArraySized *filtered = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!filtered) {\\n        return CC_ERR_ALLOC;\\n    }\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->data_length = ar->data_length;\\n    filtered->exp_factor  = ar->exp_factor;\\n    filtered->size        = 0;\\n    filtered->capacity    = ar->capacity;\\n    filtered->mem_alloc   = ar->mem_alloc;\\n    filtered->mem_calloc  = ar->mem_calloc;\\n    filtered->mem_free    = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(BUF_ADDR(ar, i))) {\\n            memcpy(BUF_ADDR(filtered, f++), \\n                   BUF_ADDR(ar, i),\\n                   ar->data_length);\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_sized_reverse(CC_ArraySized *ar, uint8_t *tmp)\\n{\\n    if (ar->size == 0) {\\n        return;\\n    }\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        memcpy(tmp, BUF_ADDR(ar, i), ar->data_length);\\n        memcpy(BUF_ADDR(ar, i), BUF_ADDR(ar, j), ar->data_length);\\n        memcpy(BUF_ADDR(ar, j), tmp, ar->data_length);\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_ArraySized, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_sized_trim_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->size == ar->capacity) {\\n        return CC_OK;\\n    }\\n    uint8_t *new_buff = ar->mem_calloc(ar->size, ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * ar->data_length);\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_ArraySized.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_sized_contains(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t o = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) {\\n            // Mismatching byte, skip block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            // Last byte is equal, match found\\n            if (j == ar->data_length - 1) {\\n                o++;\\n            }\\n        }\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_ArraySized. The size of the array is the\\n * number of elements contained within the CC_ArraySized.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_ArraySized.\\n */\\nsize_t cc_array_sized_size(CC_ArraySized *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_ArraySized. The capacity of the CC_ArraySized is\\n * the maximum number of elements an CC_ArraySized can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_ArraySized.\\n */\\nsize_t cc_array_sized_capacity(CC_ArraySized *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sized_sort(CC_ArraySized *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, ar->data_length, cmp);\\n}\\n\\n/**\\n * Expands the CC_ArraySized capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS) {\\n        return CC_ERR_MAX_CAPACITY;\\n    }\\n\\n    size_t new_capacity = (size_t) (ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity) {\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    } else {\\n        ar->capacity = new_capacity;\\n    }\\n    uint8_t *new_buff = ar->mem_alloc(ar->capacity * ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    memcpy(new_buff, ar->buffer, ar->size * ar->data_length);\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_sized_map(CC_ArraySized *ar, void (*fn) (uint8_t *e))\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        fn(BUF_ADDR(ar, i));\\n    }\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_sized_reduce(CC_ArraySized *ar, void (*fn) (uint8_t*, uint8_t*, uint8_t*), uint8_t *result)\\n{\\n    if (ar->size == 1) {\\n        fn(BUF_ADDR(ar, 0), NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1) {\\n        fn(BUF_ADDR(ar, 0), BUF_ADDR(ar, 1), result);\\n    }\\n    for (size_t i = 2; i < ar->size; i++) {\\n        fn(result, BUF_ADDR(ar, i), result);\\n    }\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_sized_iter_init(CC_ArraySizedIter *iter, CC_ArraySized *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the reference of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_sized_iter_next(CC_ArraySizedIter *iter, uint8_t **out)\\n{\\n    if (iter->index >= iter->ar->size) {\\n        return CC_ITER_END;\\n    }\\n    *out = BUF_ADDR(iter->ar, iter->index);\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_sized_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_sized_iter_remove(CC_ArraySizedIter *iter, uint8_t *out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_sized_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK) {\\n            iter->last_removed = true;\\n        }\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_ArraySized after the last returned element by\\n * <code>cc_array_sized_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_iter_add(CC_ArraySizedIter *iter, uint8_t *element)\\n{\\n    return cc_array_sized_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_sized_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_iter_replace(CC_ArraySizedIter *iter, uint8_t *element, uint8_t *out)\\n{\\n    return cc_array_sized_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_sized_iter_index(CC_ArraySizedIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_sized_zip_iter_init(CC_ArraySizedZipIter *iter, CC_ArraySized *ar1, CC_ArraySized *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_sized_zip_iter_next(CC_ArraySizedZipIter *iter, uint8_t **out1, uint8_t **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size) {\\n        return CC_ITER_END;\\n    }\\n    *out1 = BUF_ADDR(iter->ar1, iter->index);\\n    *out2 = BUF_ADDR(iter->ar2, iter->index);\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_sized_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_remove(CC_ArraySizedZipIter *iter, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (!iter->last_removed) {\\n        cc_array_sized_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_sized_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_sized_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_sized_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_add(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_ArraySized  *ar1  = iter->ar1;\\n    CC_ArraySized  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n        (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK))) {\\n        return CC_ERR_ALLOC;\\n    }\\n    cc_array_sized_add_at(ar1, e1, index);\\n    cc_array_sized_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_zip_iter_replace(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    cc_array_sized_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_sized_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_sized_zip_iter_index(CC_ArraySizedZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_sized_struct_size()\\n{\\n    return sizeof(CC_ArraySized);\\n}\", \"embeddings\": [0.06727702170610428, 0.025916047394275665, -0.013042669743299484, 0.11858218908309937, 0.3664698600769043, -0.12508544325828552, 0.12346018850803375, 0.425760418176651, 0.059919215738773346, -0.2688642740249634, 0.022020354866981506, -0.12224382907152176, -0.009566543623805046, 0.05579818785190582, 0.007574133574962616, 0.09225732088088989, -0.013086185790598392, -0.018239885568618774, 0.12101614475250244, -0.3414638936519623, -0.19093438982963562, 0.07893670350313187, 0.16658377647399902, 0.15530137717723846, 0.20781460404396057, 0.0664743185043335, 0.26249876618385315, 0.1090245172381401, 0.33902543783187866, -0.15061762928962708, 0.018420733511447906, -0.1289619505405426, 0.04911337047815323, -0.1656906008720398, 0.08267414569854736, -0.012330397963523865, 0.07888805866241455, 0.04120086506009102, 0.0702100619673729, 0.047162868082523346, -0.2145169973373413, -0.024288158863782883, 0.0648249015212059, 0.19396944344043732, 0.10884802788496017, -0.011503033339977264, 0.039711661636829376, 0.23459593951702118, -0.0847795307636261, 0.03864794224500656, 0.03390482813119888, -0.02096523717045784, -0.056476250290870667, -0.0567687526345253, -0.10216480493545532, 0.011616287752985954, 0.02324141189455986, 0.28487929701805115, 0.036063261330127716, 0.0015890896320343018, -0.13014070689678192, -0.07097534835338593, -0.17116519808769226, 0.11086466163396835, 0.0862211138010025, 0.10144467651844025, -0.12437382340431213, -0.1409226506948471, 0.036152347922325134, 0.006065793335437775, 0.09412425756454468, 0.0710269957780838, 0.1146649718284607, -0.12469720095396042, -0.16751709580421448, 0.007222753018140793, 0.08683810383081436, 0.540585994720459, -0.018205275759100914, 0.16755293309688568, 0.24106204509735107, -0.043350014835596085, 0.18488666415214539, 0.1570216417312622, 0.11564213037490845, -0.07114624977111816, -0.09977596253156662, 0.08144298195838928, -0.02799375355243683, 0.15025906264781952, 0.07030484080314636, 0.11091563105583191, -0.07772030681371689, -0.041402947157621384, 0.02103630267083645, 0.013002913445234299, 0.03982892259955406, -0.17461484670639038, 0.061490099877119064, 0.37173992395401, -0.11807338893413544, -0.12194082140922546, -0.3217879831790924, -0.07159501314163208, -0.030109524726867676, 0.09062278270721436, -0.005341373383998871, 0.037737976759672165, 0.10123488306999207, -0.00824371725320816, 0.14856502413749695, 0.016745813190937042, 0.013249339535832405, -0.001348651945590973, -0.031820833683013916, -0.14093881845474243, 0.03757396712899208, -0.030537784099578857, 0.1689707338809967, -0.0999186709523201, 0.13909851014614105, -0.011254161596298218, -0.011687494814395905, -0.10488453507423401, -0.006566748023033142, 0.038392774760723114, -0.01527075469493866, -0.20204412937164307, 0.08291041851043701, 0.09402364492416382, 0.014575839042663574, -0.09959954023361206, 0.023334752768278122, 0.008868254721164703, 0.15292109549045563, -0.024410244077444077, 0.023737557232379913, -0.00018256157636642456, 0.08644481748342514, -0.06113200634717941, -0.06159248203039169, 0.07239874452352524, 0.31722718477249146, -0.07299837470054626, 0.1633089780807495, -0.16265535354614258, 0.08790786564350128, 0.12059547007083893, -0.3269103765487671, -0.19144129753112793, 0.023019179701805115, -0.13598573207855225, 0.0010840417817234993, 0.017939522862434387, -0.16711433231830597, 0.881838321685791, 0.09974830597639084, -0.12072069197893143, -0.0494101345539093, 0.045233167707920074, 0.10232433676719666, -0.26341333985328674, -0.057176798582077026, 0.09967686235904694, 0.06829419732093811, 0.14169283211231232, 0.051399871706962585, 0.06807631254196167, 0.13358336687088013, -0.016695257276296616, 0.04793810844421387, -0.16067157685756683, -0.14361776411533356, 0.1829993724822998, 0.023824382573366165, -0.10874148458242416, -0.12069593369960785, 0.051679253578186035, -0.04455169290304184, 0.05288577079772949, -0.045726530253887177, 0.04915273189544678, -0.21736575663089752, -0.029471606016159058, -0.11736337095499039, 0.06733326613903046, 0.026448320597410202, -0.07609784603118896, 0.014212839305400848, 0.02017064392566681, 0.013094812631607056, 0.06319751590490341, 0.17270179092884064, -0.08748722076416016, -0.07479984313249588, 0.11007174104452133, -0.1495380699634552, -0.08715038001537323, 0.24383941292762756, -0.046762190759181976, 0.0391043946146965, -0.20898473262786865, 0.2238616645336151, -0.0591934435069561, 0.14945243299007416, 0.13949187099933624, -0.19654567539691925, -0.01361197978258133, -0.03683791682124138, -0.164607435464859, -0.07323004305362701, 0.11728890985250473, 0.11117580533027649, 0.06886526197195053, -0.1413877159357071, -0.054141826927661896, 0.027977410703897476, 0.13678961992263794, 0.08268189430236816, -0.07170584052801132, 0.1859404742717743, 0.2555895745754242, -0.10036130994558334, -0.06708665192127228, -0.1750408113002777, 0.2082509696483612, 0.20198309421539307, 0.025386754423379898, 0.05233893543481827, 0.060557957738637924, 0.156444251537323, 0.2158103585243225, -0.2750130891799927, 0.07023260742425919, -0.019377604126930237, -0.14439330995082855, -0.07676874101161957, -0.02195851504802704, -0.02543327957391739, -0.12538078427314758, 0.032166361808776855, 0.14122676849365234, 0.1230757087469101, 0.2629639506340027, 0.02253565937280655, -0.02520117163658142, -0.1321304738521576, 0.04473645240068436, -0.08416489511728287, 0.05152602866292, -0.03505568951368332, -0.034644246101379395, 0.04905501753091812, -0.13081710040569305, -0.11020196974277496, -0.11795780062675476, -0.21245209872722626, 0.010143473744392395, 0.03386477008461952, 0.15777136385440826, -0.020437292754650116, -0.12739603221416473, 0.12278269976377487, -0.04732789099216461, -0.17768728733062744, -0.3631078004837036, -0.06600262969732285, 0.11661796271800995, 0.04406752437353134, -0.015014957636594772, 0.09414984285831451, -0.019946258515119553, 0.22215956449508667, 0.11417471617460251, 0.06195010989904404, -0.06713218986988068, -0.04066179692745209, 0.03462657332420349, -0.1195303201675415, -0.009923718869686127, -0.08839176595211029, 0.09410927444696426, -0.06469135731458664, 0.02267194539308548, 0.029138389974832535, 0.0310650747269392, 0.16178186237812042, -0.06869552284479141, 0.019932547584176064, 0.06889214366674423, 0.07456089556217194, 0.009243030101060867, 0.1107703372836113, 0.12063664942979813, 0.002225857228040695, 0.06034078449010849, 0.2405695617198944, -0.06054382026195526, 0.014750659465789795, -0.37082141637802124, 0.12037459760904312, -0.2048642635345459, 0.01709207519888878, -0.025345448404550552, 0.3958783745765686, -0.052145447582006454, -0.024594753980636597, 0.03311717137694359, 0.28464916348457336, 0.041617706418037415, 0.052970364689826965, 0.03810684382915497, -0.1724769026041031, 0.200640469789505, -0.142647385597229, 0.06143190339207649, -0.09587967395782471, -0.0932995080947876, 0.1027144342660904, -0.029407091438770294, -0.10073930025100708, 0.10157856345176697, 0.23615875840187073, 0.13204707205295563, -0.04971001669764519, 0.10748720169067383, 0.181192547082901, -0.036074548959732056, -0.11300816386938095, 0.6922139525413513, -0.5404394268989563, 0.23009036481380463, -0.2014887034893036, 0.34416985511779785, -0.05238260328769684, 0.3112338185310364, -0.059717461466789246, 0.09588710218667984, 0.16254626214504242, 0.13647133111953735, -0.15427275002002716, -0.1076144427061081, -0.12266789376735687, 0.30191561579704285, 0.1573021411895752, 0.2183612883090973, 0.18559908866882324, -0.05370360240340233, 0.1166095957159996, -0.05260869860649109, -0.13019338250160217, 0.15444225072860718, 0.09945861995220184, -0.10088124871253967, 0.0816592425107956, 0.3439216911792755, -0.09624484926462173, -0.09487304091453552, -0.0015234574675559998, 0.12708376348018646, 0.1978016197681427, -0.22493234276771545, 0.1156529039144516, -0.04891452193260193, 0.21619465947151184, -0.34466859698295593, -0.3556174337863922, 0.05314919352531433, -0.02869103103876114, 0.06672629714012146, 0.1358489990234375, 0.20261350274085999, 0.10977645963430405, -0.179474338889122, 0.04741965979337692, -0.10395239293575287, -0.06471826881170273, -0.03655082732439041, -0.0028616338968276978, 0.13391610980033875, 0.05997840315103531, 0.05473508685827255, 0.09468907117843628, -0.003614630550146103, 0.04790673404932022, -0.19829154014587402, 0.1848500519990921, 0.16713657975196838, 0.24819022417068481, -0.13958939909934998, 0.04407152161002159, -0.19938310980796814, 0.026680277660489082, -0.09691789746284485, 0.05216330289840698, 0.046771712601184845, -0.04780150577425957, 0.1605946570634842, -0.1009911447763443, -0.12648212909698486, 0.1077975332736969, 0.13869741559028625, 0.0030930936336517334, 0.17250171303749084, 0.09229452162981033, 0.04956188425421715, 0.19349364936351776, -0.11122557520866394, -0.16702693700790405, -0.11365865170955658, 0.0726369172334671, 0.02877955511212349, 0.08061346411705017, 0.025103367865085602, 0.14316897094249725, -0.15163667500019073, 0.025212887674570084, -0.2837876081466675, -0.14071032404899597, 0.20011302828788757, 0.22303181886672974, 0.14475172758102417, 0.04917430505156517, -0.12701699137687683, 0.005512606352567673, -0.11446242034435272, 0.02975287288427353, -0.0734507143497467, 0.12369464337825775, -0.1529158502817154, 0.060247115790843964, 0.27411186695098877, 0.1717989444732666, 0.11977772414684296, 0.10736487060785294, -0.02367926761507988, -0.08909973502159119, 0.01752505451440811, -0.016038160771131516, 0.04618580639362335, 0.01194746047258377, 0.07186274975538254, 0.08134692162275314, 0.07183966785669327, -0.04388195648789406, -0.09869804233312607, 0.4076218008995056, 0.09760802984237671, -0.1255132108926773, 0.0517149418592453, -0.10617217421531677, 0.04796851798892021, -0.17314423620700836, -0.35319018363952637, 0.14126932621002197, 0.21416157484054565, 0.08698761463165283, 0.0561734102666378, 0.05854296684265137, 0.07225438952445984, 0.02497861534357071, 0.0329485759139061, -0.10234862565994263, -0.1013965830206871, -0.006354168057441711, -0.03640531003475189, 0.09779693186283112, 0.13843640685081482, 0.17765288054943085, 0.0787893533706665, 0.08266806602478027, 0.21417200565338135, -0.00727209635078907, -0.18533973395824432, 0.07368341088294983, 0.08046238124370575, -0.0802743211388588, -0.23056991398334503, 0.1223922073841095, -0.17437294125556946, -0.035896528512239456, 0.1254417449235916, 0.11955329775810242, 0.0540752112865448, 0.020534245297312737, -0.12563061714172363, 0.2930944561958313, 0.024411864578723907, -0.17449980974197388, -0.034092847257852554, -0.05659673735499382, 0.15470348298549652, 0.05330638960003853, 0.11053019762039185, 0.2597944736480713, 0.15809831023216248, 0.05635342746973038, 0.10238541662693024, 0.2781376242637634, -0.12024843692779541, -0.015761293470859528, 0.15370407700538635, 0.005280360579490662, -0.054477836936712265, -0.09445366263389587, -0.02454620599746704, -0.06473127007484436, 0.16940619051456451, 0.1375347226858139, -0.19574251770973206, -0.07193337380886078, -0.09703782945871353, 0.11716322600841522, -0.045557230710983276, 0.024755481630563736, 0.026475291699171066, -0.05414842069149017, 0.013090327382087708, -0.07658164203166962, 0.3584822416305542, -0.12288454174995422, -0.09840242564678192, -0.103056401014328, 0.03423067182302475, -0.0971406102180481, 0.014890382066369057, 0.17788581550121307, 0.003610987216234207, 0.10809854418039322, 0.07743131369352341, 0.03412393853068352, 0.0686948299407959, 0.11057087779045105, 0.2061346471309662, -0.180027037858963, 0.07991980016231537, 0.1202554702758789, 0.02103840745985508, 0.23119524121284485, -0.05061699077486992, -0.2557346820831299, -0.06561139971017838, 0.14644671976566315, -0.03557317331433296, 0.25933846831321716, 0.025772301480174065, 0.23254913091659546, 0.047548629343509674, -0.0008559040725231171, 0.03362125903367996, -0.09184594452381134, -0.7473500370979309, -0.025311294943094254, 0.12133419513702393, -0.07358606159687042, 0.08222955465316772, 0.18352222442626953, 0.06922413408756256, 0.07276183366775513, 0.063117116689682, 0.08025043457746506, 0.03426258638501167, 0.18933475017547607, 0.19966094195842743, -0.0465487539768219, -0.10522155463695526, 0.07238374650478363, 0.11230860650539398, -0.23663471639156342, 0.1983242630958557, -0.028847267851233482, -0.10075844079256058, -0.01796530932188034, 0.3493192195892334, 0.023645155131816864, 0.0464664064347744, 0.21185916662216187, 0.05730380117893219, 0.19785913825035095, 0.012099891901016235, 0.08824169635772705, 0.3078925311565399, 0.1652979552745819, -0.2966149151325226, 0.03410967439413071, 0.17569582164287567, 0.23464523255825043, 0.047162048518657684, 14.175163269042969, -0.05529851093888283, 0.2553037703037262, -0.1524229347705841, -0.020033802837133408, -0.031590528786182404, -0.05543737858533859, 0.08617804944515228, -0.07967901229858398, -0.05695915222167969, 0.05551633983850479, -0.08432544022798538, -0.011201703920960426, 0.03482096642255783, -0.04852405935525894, -0.09341324865818024, -0.023478776216506958, -0.08143743127584457, 0.14959952235221863, 0.033689048141241074, -0.1718769669532776, -0.12679754197597504, -0.019760392606258392, -0.403065025806427, -0.017265556380152702, -0.026886500418186188, 0.18369144201278687, 0.07373210787773132, 0.012746565975248814, 0.0926220491528511, 0.15989768505096436, 0.08859394490718842, 0.16244953870773315, 0.04342876002192497, -0.006209611892700195, -0.06766995042562485, -0.43203431367874146, -0.19082343578338623, 0.11989271640777588, 0.004930995404720306, -0.0121002197265625, 0.0795619860291481, 0.2167956829071045, -0.07303857803344727, 0.09417761117219925, 0.12433753907680511, -0.2386617660522461, 0.16059479117393494, -0.08819717913866043, -0.06365019828081131, 0.12602534890174866, 0.13386182487010956, 0.283828467130661, 0.13776127994060516, -0.1495654582977295, -0.2316928505897522, 0.21523913741111755, -0.01435311883687973, -0.06213533878326416, 0.28053268790245056, -0.037248075008392334, -0.10316172987222672, -0.038281213492155075, -0.028540823608636856, -0.027528051286935806, -0.03582695871591568, 0.12306621670722961, -0.004991471767425537, -0.16043497622013092, 0.05539965257048607, 0.1946224868297577, -0.17854876816272736, 0.13515828549861908, 0.01977670192718506, 0.009148120880126953, 0.05582909658551216, -0.034847743809223175, -0.019269000738859177, 0.04105199873447418, -0.1297723352909088, -0.03159199655056, 0.052653227001428604, -0.2566222846508026, -0.09472179412841797, -0.2740097641944885, 0.10722479224205017, -0.12729330360889435, 0.2808375358581543, 0.21865665912628174, -0.07559268176555634, -0.10637016594409943, 0.1512514352798462, 0.03554330766201019, -0.18920934200286865, 0.2039753794670105, 0.011518832296133041, -0.07794308662414551, -0.17404063045978546, 0.005691312253475189, 0.13717876374721527, -0.07383342832326889, -0.08480943739414215, 0.023025745525956154, 0.04894821345806122, -0.1340235471725464, 0.003227151930332184, -0.10698547959327698, 0.0024092569947242737, 0.0023197419941425323, 0.05722317472100258, 0.059437889605760574, 0.06143371760845184, 0.15695618093013763, -0.19855450093746185, -0.05632635951042175, -0.008322801440954208, 0.06538981199264526, 0.025283083319664, 0.2438758909702301, 0.11323200166225433, 0.1881628930568695, 0.0327119417488575, -0.15477606654167175, -0.036328453570604324, 0.07207154482603073, -0.11878756433725357, -0.020015627145767212, 0.20499518513679504, 0.013569824397563934, -0.07552750408649445, 0.06396792829036713, -0.10267341881990433, 0.4042428731918335, 0.1405903398990631, 0.048180047422647476, -0.0010524466633796692, -0.001981310546398163, 0.033518049865961075, 0.11824528872966766, 0.1623038798570633, 0.07577100396156311, -0.025447219610214233, 0.15656736493110657, -0.15700866281986237, -0.10406334698200226, 0.25305572152137756, 0.13215525448322296, 0.012673475779592991, -0.04863692447543144, 0.1402328610420227, 0.1381864994764328, 0.21780464053153992, -0.11428611725568771, -0.10517227649688721, -0.0917639434337616, -0.17110073566436768, -0.14713145792484283, 0.0368659645318985, -0.07818230241537094, -0.051516544073820114, 0.13318033516407013, -0.39977484941482544, 0.17072853446006775, -0.3509097993373871, 0.05015575513243675, 0.08620275557041168, 0.04802776873111725, 0.12562614679336548, 0.14680390059947968, -0.09779567271471024, 0.07311331480741501, 0.08735436201095581, -0.14278079569339752, 0.005169250071048737, -0.0670127123594284, 0.09926961362361908, 0.17008842527866364, -0.28812965750694275, -0.19897805154323578, 0.06887373328208923]}"
"{\"sha\": \"8490a88f377d8fed802e4f3b2d1d87a0d6cb81b2\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/sized/cc_array_sized.c\", \"func_name\": \"expand_capacity\", \"original_string\": \"static enum cc_stat expand_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS) {\\n        return CC_ERR_MAX_CAPACITY;\\n    }\\n\\n    size_t new_capacity = (size_t) (ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity) {\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    } else {\\n        ar->capacity = new_capacity;\\n    }\\n    uint8_t *new_buff = ar->mem_alloc(ar->capacity * ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    memcpy(new_buff, ar->buffer, ar->size * ar->data_length);\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\", \"code_tokens\": [\"static\", \"enum\", \"cc_stat\", \"expand_capacity\", \"(\", \"CC_ArraySized\", \"*\", \"ar\", \")\", \"{\", \"if\", \"(\", \"ar\", \"->\", \"capacity\", \"==\", \"CC_MAX_ELEMENTS\", \")\", \"{\", \"return\", \"CC_ERR_MAX_CAPACITY\", \";\", \"}\", \"size_t\", \"new_capacity\", \"=\", \"(\", \"size_t\", \")\", \"(\", \"ar\", \"->\", \"capacity\", \"*\", \"ar\", \"->\", \"exp_factor\", \")\", \";\", \"if\", \"(\", \"new_capacity\", \"<=\", \"ar\", \"->\", \"capacity\", \")\", \"{\", \"ar\", \"->\", \"capacity\", \"=\", \"CC_MAX_ELEMENTS\", \";\", \"}\", \"else\", \"{\", \"ar\", \"->\", \"capacity\", \"=\", \"new_capacity\", \";\", \"}\", \"uint8_t\", \"*\", \"new_buff\", \"=\", \"ar\", \"->\", \"mem_alloc\", \"(\", \"ar\", \"->\", \"capacity\", \"*\", \"ar\", \"->\", \"data_length\", \")\", \";\", \"if\", \"(\", \"!\", \"new_buff\", \")\", \"{\", \"return\", \"CC_ERR_ALLOC\", \";\", \"}\", \"memcpy\", \"(\", \"new_buff\", \",\", \"ar\", \"->\", \"buffer\", \",\", \"ar\", \"->\", \"size\", \"*\", \"ar\", \"->\", \"data_length\", \")\", \";\", \"ar\", \"->\", \"mem_free\", \"(\", \"ar\", \"->\", \"buffer\", \")\", \";\", \"ar\", \"->\", \"buffer\", \"=\", \"new_buff\", \";\", \"return\", \"CC_OK\", \";\", \"}\"], \"docstring\": \"/**\\n * Expands the CC_ArraySized capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Expands\", \"the\", \"CC_ArraySized\", \"capacity\", \".\", \"This\", \"might\", \"fail\", \"if\", \"the\", \"the\", \"new\", \"buffer\", \"*\", \"cannot\", \"be\", \"allocated\", \".\", \"In\", \"case\", \"the\", \"expansion\", \"would\", \"overflow\", \"the\", \"index\", \"*\", \"range\", \"a\", \"maximum\", \"capacity\", \"buffer\", \"is\", \"allocated\", \"instead\", \".\", \"If\", \"the\", \"capacity\", \"*\", \"is\", \"already\", \"at\", \"the\", \"maximum\", \"capacity\", \"no\", \"new\", \"buffer\", \"is\", \"allocated\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"ar\", \"array\", \"whose\", \"capacity\", \"is\", \"being\", \"expanded\", \"*\", \"*\", \"@return\", \"CC_OK\", \"if\", \"the\", \"buffer\", \"was\", \"expanded\", \"successfully\", \"CC_ERR_ALLOC\", \"if\", \"*\", \"the\", \"memory\", \"allocation\", \"for\", \"the\", \"new\", \"buffer\", \"failed\", \"or\", \"CC_ERR_MAX_CAPACITY\", \"*\", \"if\", \"the\", \"array\", \"is\", \"already\", \"at\", \"maximum\", \"capacity\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2024 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n\\n#include \\\"sized/cc_array_sized.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\n#define INDEX(a, i) a->data_length * i\\n#define BUF_ADDR(a, i) &a->buffer[a->data_length * i]\\n\\n\\nstruct cc_array_sized_s {\\n    size_t   data_length;\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    uint8_t *buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[in] Size of the array element in bytes\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new(size_t element_size, CC_ArraySized **out)\\n{\\n    CC_ArraySizedConf c;\\n    cc_array_sized_conf_init(&c);\\n    return cc_array_sized_new_conf(element_size, &c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_ArraySized based on the specified CC_ArraySizedConf struct \\n * and returns a status code.\\n *\\n * The CC_ArraySized is allocated using the allocators specified in the CC_ArraySizedConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArraySizedConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] element_size the size of the data being stored in bytes\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new_conf(\\n    size_t element_size, \\n    CC_ArraySizedConf const * const conf, \\n    CC_ArraySized **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_ArraySized *ar = conf->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    uint8_t *buff = conf->mem_alloc(conf->capacity * element_size);\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->data_length = element_size;\\n    ar->buffer      = buff;\\n    ar->exp_factor  = ex;\\n    ar->capacity    = conf->capacity;\\n    ar->mem_alloc   = conf->mem_alloc;\\n    ar->mem_calloc  = conf->mem_calloc;\\n    ar->mem_free    = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArraySizedConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArraySizedConf structure that is being initialized\\n */\\nvoid cc_array_sized_conf_init(CC_ArraySizedConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_ArraySized structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_sized_destroy(CC_ArraySized *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n\\n/**\\n * Adds a new element to the CC_ArraySized. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_ArraySized.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add(CC_ArraySized *ar, uint8_t *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    memcpy(BUF_ADDR(ar, ar->size), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add_at(CC_ArraySized *ar, uint8_t *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_sized_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * ar->data_length;\\n\\n    memmove(BUF_ADDR(ar, (index + 1)),\\n            BUF_ADDR(ar, index),\\n            shift);\\n\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_ArraySized.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_replace_at(CC_ArraySized *ar, uint8_t *element, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n* Swaps the values at the specified indices.\\n*\\n* @param[in] ar array whose elements are being swapped\\n* @param[in] index1 first position\\n* @param[in] index2 second position\\n* \\n* @return CC_OK if the operation was successful, or CC_ERR_OUT_OF_RANGE if \\n* one of the indices was out of range.\\n*/\\nenum cc_stat cc_array_sized_swap_at(CC_ArraySized *ar, size_t index1, size_t index2)\\n{\\n    if (index1 >= ar->size || index2 >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n\\n    for (size_t i = 0; i < ar->data_length; i++) {\\n        uint8_t tmp = ar->buffer[INDEX(ar, index1 + i)];\\n        ar->buffer[INDEX(ar, index1 + i)] = ar->buffer[INDEX(ar, index2 + i)];\\n        ar->buffer[INDEX(ar, index2 + i)] = tmp;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_ArraySized if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_sized_remove(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_sized_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n \\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_remove_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_sized_remove_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    return cc_array_sized_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_sized_remove_all(CC_ArraySized *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Copies an CC_ArraySized element from the specified index to the out pointer.\\n * The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] source index of the array element\\n * @param[out] destination address\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_sized_get_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_sized_get_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n    return cc_array_sized_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n* Returns the pointer to the element at the specified index\\n*/\\nenum cc_stat cc_array_sized_peek(CC_ArraySized* ar, size_t index, uint8_t** out)\\n{\\n    if (index > ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    *out = BUF_ADDR(ar, index);\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst uint8_t * const* cc_array_sized_get_buffer(CC_ArraySized *ar)\\n{\\n    return (const uint8_t* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_ArraySized.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_sized_index_of(CC_ArraySized *ar, uint8_t *element, size_t *index)\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) { \\n            // Mismatching byte, skip to next block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            if (j == ar->data_length - 1) {\\n                *index = i;\\n                return CC_OK;\\n            }\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_ArraySized, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_ArraySized, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's allocators\\n *       and it also inherits the configuration of the original CC_ArraySized.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_sized_subarray(CC_ArraySized *ar, size_t b, size_t e, CC_ArraySized **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_ArraySized *sub_ar = ar->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * ar->data_length))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc   = ar->mem_alloc;\\n    sub_ar->mem_calloc  = ar->mem_calloc;\\n    sub_ar->mem_free    = ar->mem_free;\\n    sub_ar->size        = e - b + 1;\\n    sub_ar->capacity    = sub_ar->size;\\n    sub_ar->data_length = ar->data_length;\\n\\n    memcpy(sub_ar->buffer,\\n           BUF_ADDR(ar, b),\\n           sub_ar->size * ar->data_length);\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a copy of the specified CC_ArraySized. \\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's\\n *       allocators and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_sized_copy(CC_ArraySized *ar, CC_ArraySized **out)\\n{\\n    CC_ArraySized *copy = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->data_length = ar->data_length;\\n    copy->exp_factor  = ar->exp_factor;\\n    copy->size        = ar->size;\\n    copy->capacity    = ar->capacity;\\n    copy->mem_alloc   = ar->mem_alloc;\\n    copy->mem_calloc  = ar->mem_calloc;\\n    copy->mem_free    = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * ar->data_length);\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_ArraySized was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_ArraySized is empty.\\n */\\nenum cc_stat cc_array_sized_filter_mut(CC_ArraySized *ar, bool (*pred) (const uint8_t*))\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(BUF_ADDR(ar, i))) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * ar->data_length;\\n                memmove(BUF_ADDR(ar, (i + 1)),\\n                        BUF_ADDR(ar, (i + 1 + rm)),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * ar->data_length;\\n        memmove(BUF_ADDR(ar, 0),\\n                BUF_ADDR(ar, rm),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by creating a new CC_ArraySized that contains all elements\\n * from the original CC_ArraySized that return true on pred(element) without modifying \\n * the original CC_ArraySized.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_sized_filter(CC_ArraySized *ar, bool (*pred) (const uint8_t*), CC_ArraySized **out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    CC_ArraySized *filtered = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!filtered) {\\n        return CC_ERR_ALLOC;\\n    }\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->data_length = ar->data_length;\\n    filtered->exp_factor  = ar->exp_factor;\\n    filtered->size        = 0;\\n    filtered->capacity    = ar->capacity;\\n    filtered->mem_alloc   = ar->mem_alloc;\\n    filtered->mem_calloc  = ar->mem_calloc;\\n    filtered->mem_free    = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(BUF_ADDR(ar, i))) {\\n            memcpy(BUF_ADDR(filtered, f++), \\n                   BUF_ADDR(ar, i),\\n                   ar->data_length);\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_sized_reverse(CC_ArraySized *ar, uint8_t *tmp)\\n{\\n    if (ar->size == 0) {\\n        return;\\n    }\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        memcpy(tmp, BUF_ADDR(ar, i), ar->data_length);\\n        memcpy(BUF_ADDR(ar, i), BUF_ADDR(ar, j), ar->data_length);\\n        memcpy(BUF_ADDR(ar, j), tmp, ar->data_length);\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_ArraySized, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_sized_trim_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->size == ar->capacity) {\\n        return CC_OK;\\n    }\\n    uint8_t *new_buff = ar->mem_calloc(ar->size, ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * ar->data_length);\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_ArraySized.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_sized_contains(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t o = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) {\\n            // Mismatching byte, skip block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            // Last byte is equal, match found\\n            if (j == ar->data_length - 1) {\\n                o++;\\n            }\\n        }\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_ArraySized. The size of the array is the\\n * number of elements contained within the CC_ArraySized.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_ArraySized.\\n */\\nsize_t cc_array_sized_size(CC_ArraySized *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_ArraySized. The capacity of the CC_ArraySized is\\n * the maximum number of elements an CC_ArraySized can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_ArraySized.\\n */\\nsize_t cc_array_sized_capacity(CC_ArraySized *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sized_sort(CC_ArraySized *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, ar->data_length, cmp);\\n}\\n\\n/**\\n * Expands the CC_ArraySized capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS) {\\n        return CC_ERR_MAX_CAPACITY;\\n    }\\n\\n    size_t new_capacity = (size_t) (ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity) {\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    } else {\\n        ar->capacity = new_capacity;\\n    }\\n    uint8_t *new_buff = ar->mem_alloc(ar->capacity * ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    memcpy(new_buff, ar->buffer, ar->size * ar->data_length);\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_sized_map(CC_ArraySized *ar, void (*fn) (uint8_t *e))\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        fn(BUF_ADDR(ar, i));\\n    }\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_sized_reduce(CC_ArraySized *ar, void (*fn) (uint8_t*, uint8_t*, uint8_t*), uint8_t *result)\\n{\\n    if (ar->size == 1) {\\n        fn(BUF_ADDR(ar, 0), NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1) {\\n        fn(BUF_ADDR(ar, 0), BUF_ADDR(ar, 1), result);\\n    }\\n    for (size_t i = 2; i < ar->size; i++) {\\n        fn(result, BUF_ADDR(ar, i), result);\\n    }\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_sized_iter_init(CC_ArraySizedIter *iter, CC_ArraySized *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the reference of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_sized_iter_next(CC_ArraySizedIter *iter, uint8_t **out)\\n{\\n    if (iter->index >= iter->ar->size) {\\n        return CC_ITER_END;\\n    }\\n    *out = BUF_ADDR(iter->ar, iter->index);\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_sized_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_sized_iter_remove(CC_ArraySizedIter *iter, uint8_t *out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_sized_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK) {\\n            iter->last_removed = true;\\n        }\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_ArraySized after the last returned element by\\n * <code>cc_array_sized_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_iter_add(CC_ArraySizedIter *iter, uint8_t *element)\\n{\\n    return cc_array_sized_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_sized_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_iter_replace(CC_ArraySizedIter *iter, uint8_t *element, uint8_t *out)\\n{\\n    return cc_array_sized_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_sized_iter_index(CC_ArraySizedIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_sized_zip_iter_init(CC_ArraySizedZipIter *iter, CC_ArraySized *ar1, CC_ArraySized *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_sized_zip_iter_next(CC_ArraySizedZipIter *iter, uint8_t **out1, uint8_t **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size) {\\n        return CC_ITER_END;\\n    }\\n    *out1 = BUF_ADDR(iter->ar1, iter->index);\\n    *out2 = BUF_ADDR(iter->ar2, iter->index);\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_sized_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_remove(CC_ArraySizedZipIter *iter, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (!iter->last_removed) {\\n        cc_array_sized_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_sized_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_sized_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_sized_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_add(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_ArraySized  *ar1  = iter->ar1;\\n    CC_ArraySized  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n        (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK))) {\\n        return CC_ERR_ALLOC;\\n    }\\n    cc_array_sized_add_at(ar1, e1, index);\\n    cc_array_sized_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_zip_iter_replace(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    cc_array_sized_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_sized_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_sized_zip_iter_index(CC_ArraySizedZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_sized_struct_size()\\n{\\n    return sizeof(CC_ArraySized);\\n}\", \"embeddings\": [0.028813645243644714, 0.06579151004552841, -0.012842763215303421, 0.1292562186717987, 0.4179626703262329, -0.18585467338562012, 0.06825585663318634, 0.36760565638542175, 0.026531502604484558, -0.2815411686897278, 0.03381727263331413, -0.07013071328401566, 0.030015990138053894, 0.0903049185872078, -0.03817272186279297, 0.006018884479999542, 0.11133167147636414, -0.048379771411418915, 0.048722948879003525, -0.47854524850845337, -0.1482992321252823, 0.11161293834447861, 0.18558597564697266, 0.19176951050758362, 0.24975119531154633, 0.10861580073833466, 0.23462806642055511, 0.04364907741546631, 0.43505045771598816, -0.1616545021533966, 0.025784187018871307, -0.07218492776155472, 0.06677044928073883, -0.2244700789451599, 0.02634921297430992, -0.049572981894016266, -0.003190174698829651, 0.11361284554004669, -0.09974882751703262, -0.01813364028930664, -0.2444368600845337, 0.0971759706735611, 0.15937750041484833, 0.09521646797657013, 0.1513957977294922, -0.03743090480566025, 0.09791103005409241, 0.1356547772884369, -0.018434468656778336, 0.10969793796539307, 0.051343634724617004, -0.12194544076919556, -0.03812595456838608, -0.05430009216070175, -0.0592312254011631, -0.1001899465918541, -0.02551347017288208, 0.3626311123371124, -0.008597157895565033, 0.01797698438167572, -0.10060414671897888, -0.17551808059215546, -0.20394183695316315, 0.1461491733789444, 0.188099667429924, 0.045783791691064835, -0.0569223128259182, -0.16382519900798798, 0.027338407933712006, -0.034702740609645844, 0.10389796644449234, 0.1534123420715332, 0.1569000482559204, -0.1607048660516739, -0.1085466593503952, -0.0779239684343338, -0.03160620480775833, 0.4775080680847168, -0.07415229082107544, 0.19528183341026306, 0.1980033665895462, -0.08932225406169891, 0.20432570576667786, 0.1450057476758957, 0.12851805984973907, 0.036029890179634094, -0.13783666491508484, 0.19447985291481018, -0.054975301027297974, 0.23321761190891266, 0.03425410017371178, 0.13852784037590027, -0.07207588106393814, -0.07760609686374664, -0.025693394243717194, -0.025512564927339554, 0.037010662257671356, -0.12944087386131287, 0.08008433878421783, 0.4560081958770752, -0.08152446150779724, -0.1317683458328247, -0.3687310814857483, -0.0715765506029129, -0.037481725215911865, 0.03928491473197937, -0.055622778832912445, 0.04061063751578331, 0.07851643860340118, -0.009707503020763397, 0.19053028523921967, 0.07426530122756958, 0.07376859337091446, 0.02784910798072815, -0.04954908788204193, -0.1283293068408966, 0.033584073185920715, 0.01736980304121971, 0.2655008137226105, -0.1752132773399353, 0.11028154194355011, -0.024120204150676727, 0.040813133120536804, -0.030142851173877716, -0.1748795062303543, 0.056827984750270844, 0.06423211097717285, -0.3194938004016876, 0.18823018670082092, 0.06091614067554474, -0.06085076183080673, -0.08159612864255905, -0.03549990803003311, 0.04416856914758682, 0.1140192449092865, 0.009883224964141846, 0.15318498015403748, -0.025607071816921234, 0.08922991901636124, -0.07760036736726761, -0.0235053151845932, 0.030228540301322937, 0.3321024775505066, -0.02642427757382393, 0.2700730264186859, -0.11556470394134521, 0.25324106216430664, 0.07983861118555069, -0.36875492334365845, -0.16968576610088348, 0.07063309103250504, -0.13403284549713135, 0.045085418969392776, 0.0853927880525589, -0.1513274908065796, 0.706441342830658, 0.1545754373073578, -0.17766129970550537, -0.013064209371805191, -0.041094131767749786, 0.035075701773166656, -0.25004926323890686, -0.0275108739733696, 0.20672136545181274, 0.09869205206632614, 0.1280534416437149, 0.0977150946855545, 0.06045626848936081, 0.13722848892211914, 0.06847745925188065, 0.09393614530563354, -0.17521269619464874, -0.018058691173791885, 0.1502842903137207, -0.02663474529981613, -0.14895352721214294, -0.1032027155160904, 0.09224317222833633, -0.017507772892713547, 0.036061450839042664, -0.06721540540456772, 0.04987257719039917, -0.15023118257522583, 0.02790781483054161, -0.08602964133024216, 0.011770907789468765, 0.047885674983263016, -0.10025101900100708, 0.07355335354804993, -0.057428546249866486, 0.1884501576423645, 0.048892244696617126, 0.16817685961723328, -0.1056956946849823, -0.14091169834136963, 0.18399935960769653, -0.1939360797405243, -0.05365743488073349, 0.28223755955696106, -0.040303848683834076, -0.012672828510403633, -0.2267816960811615, 0.24143080413341522, -0.10200294852256775, -0.020567625761032104, 0.1910424381494522, -0.2228240817785263, -0.0536750927567482, -0.03737327829003334, -0.1308198869228363, -0.03132079169154167, 0.13052022457122803, 0.1034344881772995, 0.05534712225198746, 0.0007943920791149139, -0.2223244607448578, 0.06348953396081924, 0.17769351601600647, 0.16455501317977905, -0.083188496530056, 0.10762664675712585, 0.17906394600868225, -0.0614972859621048, -0.13086466491222382, -0.10748903453350067, 0.1720718890428543, 0.19376647472381592, 0.14943955838680267, 0.024158257991075516, 0.09849007427692413, 0.14447903633117676, 0.22279314696788788, -0.2428295761346817, 0.1754050850868225, 0.041742149740457535, -0.15085700154304504, -0.05741174519062042, 0.08075080811977386, -0.00757715106010437, -0.14654332399368286, -0.06616266816854477, 0.18963970243930817, 0.18088966608047485, 0.3217354416847229, -0.005436748266220093, 0.10722567141056061, -0.11648936569690704, 0.07716105878353119, -0.09645946323871613, 0.18894118070602417, -0.043069027364254, -0.04098580405116081, 0.04389110952615738, -0.11877554655075073, -0.09256787598133087, -0.0009757503867149353, -0.0959235280752182, -0.022160854190587997, 0.047524772584438324, 0.34207242727279663, -0.039662159979343414, -0.05295844376087189, 0.105383962392807, -0.10082925856113434, -0.1325027346611023, -0.46985575556755066, -0.0326879546046257, 0.09872999787330627, -0.0028127282857894897, -0.011285211890935898, 0.12454468011856079, -0.1026727631688118, 0.24723690748214722, 0.1945320963859558, 0.0625625029206276, -0.06228822469711304, 0.0031424276530742645, -0.039969753473997116, -0.14814968407154083, 0.020095452666282654, -0.002727571874856949, 0.17775282263755798, -0.23130248486995697, 0.005154609680175781, 0.04045099765062332, 0.08622362464666367, 0.13261039555072784, 0.003172788769006729, 0.03239607810974121, -0.0365690141916275, 0.023884644731879234, 0.04821266978979111, 0.09465983510017395, 0.13072992861270905, 0.057219892740249634, 0.08811387419700623, 0.24435029923915863, -0.042622774839401245, 0.048410363495349884, -0.2631661593914032, 0.221638485789299, -0.30076491832733154, 0.07749892771244049, -0.07920165359973907, 0.38478413224220276, -0.09155163168907166, 0.05418187379837036, 0.11505042016506195, 0.22678111493587494, 0.041846953332424164, 0.10869567841291428, 0.053306642919778824, -0.18872983753681183, 0.08204805105924606, -0.12733444571495056, 0.13477301597595215, -0.10783643275499344, -0.052057866007089615, 0.06513359397649765, 0.0040120407938957214, -0.010941646993160248, 0.13088089227676392, 0.2764817178249359, 0.13212957978248596, 0.05393537878990173, 0.07449959963560104, 0.14305946230888367, -0.07346495240926743, -0.26873573660850525, 0.5498061776161194, -0.46050816774368286, 0.20353472232818604, -0.21837946772575378, 0.34212398529052734, -0.11365699768066406, 0.30173903703689575, 0.011430501937866211, 0.07099940627813339, 0.046498171985149384, 0.13537827134132385, -0.1746729165315628, -0.14633312821388245, -0.18312565982341766, 0.30227208137512207, 0.09135866165161133, 0.21777856349945068, 0.2057833969593048, -0.01829719915986061, 0.12364576011896133, -0.05358022078871727, -0.08463896811008453, 0.17585250735282898, 0.05052713304758072, -0.037866607308387756, 0.074859619140625, 0.40897077322006226, -0.14885857701301575, -0.07260790467262268, -0.0670449286699295, 0.03580578789114952, 0.18763327598571777, -0.2842113971710205, 0.12646982073783875, -0.11267078667879105, 0.2769685685634613, -0.438873291015625, -0.3935592472553253, 0.008344875648617744, -0.13785281777381897, 0.025220178067684174, 0.1505698561668396, 0.14104841649532318, 0.12701933085918427, -0.2174859195947647, 0.06394510716199875, -0.06484538316726685, -0.12178201973438263, -0.08054716140031815, -0.06098717451095581, 0.13356629014015198, 0.05782062187790871, 0.0685916543006897, -0.0038979053497314453, 0.03898194432258606, 0.07771328091621399, -0.1917579174041748, 0.19075791537761688, 0.14649514853954315, 0.2672012150287628, -0.08530621230602264, 0.10802032798528671, -0.16149850189685822, 0.10750832408666611, -0.09927822649478912, 0.027431592345237732, 0.019988644868135452, -0.05909932032227516, 0.1800774782896042, -0.1452840119600296, -0.16003763675689697, 0.10760048776865005, 0.2857547998428345, -0.046637531369924545, 0.18401870131492615, 0.15173742175102234, 0.09279344230890274, 0.09654594957828522, -0.21777822077274323, -0.0815034806728363, -0.23068460822105408, 0.10860368609428406, -0.0022955983877182007, 0.0757213830947876, 0.06895408034324646, 0.14133012294769287, -0.14813366532325745, 0.10928265005350113, -0.3100760579109192, -0.15886014699935913, 0.1405923217535019, 0.21807214617729187, 0.14812490344047546, 0.035344190895557404, -0.17328765988349915, -0.05941402167081833, 0.02860233560204506, -0.12230244278907776, -0.14733465015888214, 0.10767386853694916, -0.20645299553871155, 0.010552965104579926, 0.29204463958740234, 0.07982996106147766, 0.14635567367076874, 0.06234513223171234, -0.03334983438253403, -0.12143431603908539, -0.006296273320913315, 0.05582161247730255, 0.07963985204696655, 0.06802821159362793, 0.050788842141628265, 0.044370342046022415, 0.03584893047809601, -0.012566134333610535, -0.14156046509742737, 0.43886175751686096, 0.13445265591144562, -0.0676906481385231, 0.13884547352790833, -0.212856262922287, 0.013212241232395172, -0.03947826102375984, -0.38022902607917786, 0.1897013783454895, 0.22875747084617615, 0.0929587185382843, 0.03633400797843933, 0.15377682447433472, 0.04211913421750069, -0.021049916744232178, 0.09518220275640488, -0.11386355757713318, -0.11214282363653183, 0.039342865347862244, -0.13591140508651733, 0.1812901645898819, 0.02167409099638462, 0.21606643497943878, 0.06740383058786392, 0.16728901863098145, 0.24209094047546387, -0.022372538223862648, -0.11167752742767334, -0.0011741481721401215, -0.022634297609329224, -0.010958663187921047, -0.29874515533447266, 0.03487025946378708, -0.10882561653852463, 0.017573434859514236, 0.06270064413547516, 0.11146745085716248, 0.02334589883685112, 0.09107004106044769, -0.20657381415367126, 0.24963831901550293, 0.07003253698348999, -0.14261260628700256, 0.02825958840548992, -0.18107955157756805, 0.1456754356622696, 0.08568694442510605, 0.1739305853843689, 0.26067614555358887, 0.1363978385925293, 0.0608377531170845, 0.11893883347511292, 0.426872193813324, -0.1203124076128006, 0.03787963464856148, 0.11771155893802643, -0.016224868595600128, -0.12095645070075989, -0.12784050405025482, -0.16735026240348816, -0.05683550983667374, 0.081117182970047, 0.13088646531105042, -0.22746917605400085, -0.037985265254974365, -0.19549128413200378, 0.07393711805343628, 0.00958886370062828, 0.048076286911964417, 0.07245922088623047, 0.02138003706932068, -0.011105116456747055, -0.05191659927368164, 0.25215575098991394, -0.16490131616592407, -0.16894109547138214, -0.08740806579589844, -0.014256017282605171, -0.07271263003349304, 0.050460003316402435, 0.10270514339208603, 0.010252788662910461, 0.07260406017303467, -0.024370472878217697, 0.06609778851270676, 0.00406444538384676, 0.09241246432065964, 0.24920788407325745, -0.2202150821685791, 0.015110360458493233, 0.12043426930904388, 0.030629925429821014, 0.17960011959075928, -0.1067071184515953, -0.23722533881664276, -0.02123963087797165, 0.17634797096252441, -0.08345265686511993, 0.1153455376625061, 0.056027039885520935, 0.17981866002082825, 0.07473720610141754, -0.023927759379148483, 0.09272537380456924, -0.028369445353746414, -0.6715766191482544, -0.012113600969314575, 0.13326752185821533, -0.026889193803071976, 0.08700239658355713, 0.20161086320877075, 0.03659507632255554, 0.03221195936203003, 0.166237011551857, 0.014324506744742393, 0.1575947403907776, 0.16301588714122772, 0.23150642216205597, -0.11318552494049072, -0.1959170252084732, 0.1143636554479599, 0.111801378428936, -0.2501329481601715, 0.24722805619239807, -0.05989275500178337, -0.14012867212295532, 0.03989526256918907, 0.35075080394744873, -0.017219066619873047, 0.05907386168837547, 0.16594025492668152, 0.04528176784515381, 0.2505907714366913, -0.0567048043012619, 0.0803212895989418, 0.31659796833992004, 0.1525874137878418, -0.3107905387878418, 0.012604497373104095, 0.10820382833480835, 0.09741071611642838, 0.008847564458847046, 13.86307430267334, -0.027650505304336548, 0.2714676856994629, -0.19651588797569275, -0.08731787651777267, 0.033861540257930756, -0.04470647871494293, -0.09588766098022461, -0.053324148058891296, -0.036302439868450165, 0.09080831706523895, -0.03459273278713226, 0.00010101310908794403, -0.05441231653094292, -0.10158824920654297, -0.07553395628929138, 0.04830530658364296, -0.12292949855327606, 0.19378185272216797, -0.01607649028301239, -0.18451976776123047, -0.10219267010688782, -0.06868106126785278, -0.47698524594306946, -0.007383234798908234, -0.005622856318950653, 0.11625000089406967, 0.047693997621536255, -0.04333445429801941, 0.06775462627410889, 0.16728410124778748, 0.16432993113994598, 0.09318544715642929, 0.0014617815613746643, 0.08258207142353058, -0.07655570656061172, -0.3389524817466736, -0.17204482853412628, 0.16953960061073303, -0.014013707637786865, 0.0037919357419013977, -0.012241937220096588, 0.20246858894824982, -0.05852667987346649, 0.12944452464580536, 0.09875435382127762, -0.25269800424575806, 0.1498866081237793, -0.14891189336776733, -0.02972491830587387, 0.23801018297672272, 0.1796286404132843, 0.3950614929199219, 0.043948762118816376, -0.21703878045082092, -0.2770039439201355, 0.24220344424247742, -0.08635151386260986, -0.05791075527667999, 0.4662013053894043, -0.008649542927742004, -0.1162215992808342, 0.005577757954597473, 0.16885195672512054, 0.06283781677484512, 0.006480984389781952, 0.10054058581590652, 0.05077517032623291, -0.29816192388534546, 0.08727702498435974, 0.2412491738796234, -0.17616033554077148, 0.22032859921455383, 0.028839226812124252, 0.025718048214912415, 0.035807330161333084, 0.035506799817085266, -0.053806934505701065, 0.11611998081207275, -0.1424400508403778, -0.024991638958454132, 0.08432059735059738, -0.2453194558620453, -0.15954209864139557, -0.3881492018699646, 0.001307956874370575, 0.01213046908378601, 0.2584475576877594, 0.3190452456474304, -0.1378319263458252, -0.05382239446043968, 0.10100384801626205, -0.01515108346939087, -0.29860585927963257, 0.21293675899505615, 0.030032042413949966, -0.05737318843603134, -0.18450704216957092, -0.019106023013591766, 0.1031755805015564, -0.10823454707860947, -0.08684249222278595, -0.0055880434811115265, -0.008477479219436646, -0.10133805871009827, 0.041839681565761566, -0.04615583270788193, 0.007259249687194824, 0.044782254844903946, 0.061616845428943634, 0.06898210197687149, 0.16859179735183716, 0.19719897210597992, -0.2617863416671753, -0.1227838546037674, 0.010605230927467346, 0.02381858043372631, 0.002891555428504944, 0.22008395195007324, 0.10695364326238632, 0.20808611810207367, 0.08807289600372314, -0.15505145490169525, -0.02042798325419426, 0.11507213860750198, -0.271322637796402, -0.00914502888917923, 0.12486784160137177, 0.0729752629995346, -0.037547025829553604, -0.02412787452340126, -0.03714772313833237, 0.5717856884002686, 0.10154065489768982, 0.11270871758460999, -0.13920865952968597, -0.0076101794838905334, 0.08614369481801987, 0.09644560515880585, 0.2615298628807068, 0.09295381605625153, -0.017665624618530273, 0.21217532455921173, -0.11484558880329132, -0.13906225562095642, 0.35946357250213623, 0.11701113730669022, -0.01910407841205597, -0.1643284559249878, 0.1603265404701233, 0.11531881242990494, 0.24381716549396515, -0.2693690359592438, -0.09854459762573242, -0.10087960958480835, -0.1631644070148468, -0.19089847803115845, 0.02313351258635521, -0.07825016230344772, -0.05198867246508598, 0.05857487767934799, -0.3195885121822357, 0.14456623792648315, -0.43255701661109924, -0.04353170841932297, 0.0680251345038414, 0.05418337136507034, 0.14465069770812988, 0.19892127811908722, -0.11486402899026871, 0.12472252547740936, 0.07603093236684799, -0.10894941538572311, -0.03875001519918442, -0.1053265929222107, 0.0615985132753849, 0.3301459550857544, -0.4352758526802063, -0.19171194732189178, 0.09768293797969818]}"
"{\"sha\": \"8490a88f377d8fed802e4f3b2d1d87a0d6cb81b2\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/sized/cc_array_sized.c\", \"func_name\": \"cc_array_sized_map\", \"original_string\": \"void cc_array_sized_map(CC_ArraySized *ar, void (*fn) (uint8_t *e))\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        fn(BUF_ADDR(ar, i));\\n    }\\n}\", \"code_tokens\": [\"void\", \"cc_array_sized_map\", \"(\", \"CC_ArraySized\", \"*\", \"ar\", \",\", \"void\", \"(\", \"*\", \"fn\", \")\", \"(\", \"uint8_t\", \"*\", \"e\", \")\", \")\", \"{\", \"for\", \"(\", \"size_t\", \"i\", \"=\", \"0\", \";\", \"i\", \"<\", \"ar\", \"->\", \"size\", \";\", \"i\", \"++\", \")\", \"{\", \"fn\", \"(\", \"BUF_ADDR\", \"(\", \"ar\", \",\", \"i\", \")\", \")\", \";\", \"}\", \"}\"], \"docstring\": \"/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Applies\", \"the\", \"function\", \"fn\", \"to\", \"each\", \"element\", \"of\", \"the\", \"CC_Array\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"ar\", \"array\", \"on\", \"which\", \"this\", \"operation\", \"is\", \"performed\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"fn\", \"operation\", \"function\", \"that\", \"is\", \"to\", \"be\", \"invoked\", \"on\", \"each\", \"CC_Array\", \"*\", \"element\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2024 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n\\n#include \\\"sized/cc_array_sized.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\n#define INDEX(a, i) a->data_length * i\\n#define BUF_ADDR(a, i) &a->buffer[a->data_length * i]\\n\\n\\nstruct cc_array_sized_s {\\n    size_t   data_length;\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    uint8_t *buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[in] Size of the array element in bytes\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new(size_t element_size, CC_ArraySized **out)\\n{\\n    CC_ArraySizedConf c;\\n    cc_array_sized_conf_init(&c);\\n    return cc_array_sized_new_conf(element_size, &c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_ArraySized based on the specified CC_ArraySizedConf struct \\n * and returns a status code.\\n *\\n * The CC_ArraySized is allocated using the allocators specified in the CC_ArraySizedConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArraySizedConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] element_size the size of the data being stored in bytes\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new_conf(\\n    size_t element_size, \\n    CC_ArraySizedConf const * const conf, \\n    CC_ArraySized **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_ArraySized *ar = conf->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    uint8_t *buff = conf->mem_alloc(conf->capacity * element_size);\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->data_length = element_size;\\n    ar->buffer      = buff;\\n    ar->exp_factor  = ex;\\n    ar->capacity    = conf->capacity;\\n    ar->mem_alloc   = conf->mem_alloc;\\n    ar->mem_calloc  = conf->mem_calloc;\\n    ar->mem_free    = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArraySizedConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArraySizedConf structure that is being initialized\\n */\\nvoid cc_array_sized_conf_init(CC_ArraySizedConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_ArraySized structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_sized_destroy(CC_ArraySized *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n\\n/**\\n * Adds a new element to the CC_ArraySized. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_ArraySized.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add(CC_ArraySized *ar, uint8_t *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    memcpy(BUF_ADDR(ar, ar->size), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add_at(CC_ArraySized *ar, uint8_t *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_sized_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * ar->data_length;\\n\\n    memmove(BUF_ADDR(ar, (index + 1)),\\n            BUF_ADDR(ar, index),\\n            shift);\\n\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_ArraySized.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_replace_at(CC_ArraySized *ar, uint8_t *element, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n* Swaps the values at the specified indices.\\n*\\n* @param[in] ar array whose elements are being swapped\\n* @param[in] index1 first position\\n* @param[in] index2 second position\\n* \\n* @return CC_OK if the operation was successful, or CC_ERR_OUT_OF_RANGE if \\n* one of the indices was out of range.\\n*/\\nenum cc_stat cc_array_sized_swap_at(CC_ArraySized *ar, size_t index1, size_t index2)\\n{\\n    if (index1 >= ar->size || index2 >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n\\n    for (size_t i = 0; i < ar->data_length; i++) {\\n        uint8_t tmp = ar->buffer[INDEX(ar, index1 + i)];\\n        ar->buffer[INDEX(ar, index1 + i)] = ar->buffer[INDEX(ar, index2 + i)];\\n        ar->buffer[INDEX(ar, index2 + i)] = tmp;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_ArraySized if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_sized_remove(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_sized_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n \\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_remove_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_sized_remove_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    return cc_array_sized_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_sized_remove_all(CC_ArraySized *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Copies an CC_ArraySized element from the specified index to the out pointer.\\n * The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] source index of the array element\\n * @param[out] destination address\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_sized_get_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_sized_get_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n    return cc_array_sized_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n* Returns the pointer to the element at the specified index\\n*/\\nenum cc_stat cc_array_sized_peek(CC_ArraySized* ar, size_t index, uint8_t** out)\\n{\\n    if (index > ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    *out = BUF_ADDR(ar, index);\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst uint8_t * const* cc_array_sized_get_buffer(CC_ArraySized *ar)\\n{\\n    return (const uint8_t* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_ArraySized.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_sized_index_of(CC_ArraySized *ar, uint8_t *element, size_t *index)\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) { \\n            // Mismatching byte, skip to next block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            if (j == ar->data_length - 1) {\\n                *index = i;\\n                return CC_OK;\\n            }\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_ArraySized, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_ArraySized, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's allocators\\n *       and it also inherits the configuration of the original CC_ArraySized.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_sized_subarray(CC_ArraySized *ar, size_t b, size_t e, CC_ArraySized **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_ArraySized *sub_ar = ar->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * ar->data_length))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc   = ar->mem_alloc;\\n    sub_ar->mem_calloc  = ar->mem_calloc;\\n    sub_ar->mem_free    = ar->mem_free;\\n    sub_ar->size        = e - b + 1;\\n    sub_ar->capacity    = sub_ar->size;\\n    sub_ar->data_length = ar->data_length;\\n\\n    memcpy(sub_ar->buffer,\\n           BUF_ADDR(ar, b),\\n           sub_ar->size * ar->data_length);\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a copy of the specified CC_ArraySized. \\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's\\n *       allocators and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_sized_copy(CC_ArraySized *ar, CC_ArraySized **out)\\n{\\n    CC_ArraySized *copy = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->data_length = ar->data_length;\\n    copy->exp_factor  = ar->exp_factor;\\n    copy->size        = ar->size;\\n    copy->capacity    = ar->capacity;\\n    copy->mem_alloc   = ar->mem_alloc;\\n    copy->mem_calloc  = ar->mem_calloc;\\n    copy->mem_free    = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * ar->data_length);\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_ArraySized was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_ArraySized is empty.\\n */\\nenum cc_stat cc_array_sized_filter_mut(CC_ArraySized *ar, bool (*pred) (const uint8_t*))\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(BUF_ADDR(ar, i))) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * ar->data_length;\\n                memmove(BUF_ADDR(ar, (i + 1)),\\n                        BUF_ADDR(ar, (i + 1 + rm)),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * ar->data_length;\\n        memmove(BUF_ADDR(ar, 0),\\n                BUF_ADDR(ar, rm),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by creating a new CC_ArraySized that contains all elements\\n * from the original CC_ArraySized that return true on pred(element) without modifying \\n * the original CC_ArraySized.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_sized_filter(CC_ArraySized *ar, bool (*pred) (const uint8_t*), CC_ArraySized **out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    CC_ArraySized *filtered = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!filtered) {\\n        return CC_ERR_ALLOC;\\n    }\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->data_length = ar->data_length;\\n    filtered->exp_factor  = ar->exp_factor;\\n    filtered->size        = 0;\\n    filtered->capacity    = ar->capacity;\\n    filtered->mem_alloc   = ar->mem_alloc;\\n    filtered->mem_calloc  = ar->mem_calloc;\\n    filtered->mem_free    = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(BUF_ADDR(ar, i))) {\\n            memcpy(BUF_ADDR(filtered, f++), \\n                   BUF_ADDR(ar, i),\\n                   ar->data_length);\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_sized_reverse(CC_ArraySized *ar, uint8_t *tmp)\\n{\\n    if (ar->size == 0) {\\n        return;\\n    }\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        memcpy(tmp, BUF_ADDR(ar, i), ar->data_length);\\n        memcpy(BUF_ADDR(ar, i), BUF_ADDR(ar, j), ar->data_length);\\n        memcpy(BUF_ADDR(ar, j), tmp, ar->data_length);\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_ArraySized, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_sized_trim_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->size == ar->capacity) {\\n        return CC_OK;\\n    }\\n    uint8_t *new_buff = ar->mem_calloc(ar->size, ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * ar->data_length);\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_ArraySized.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_sized_contains(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t o = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) {\\n            // Mismatching byte, skip block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            // Last byte is equal, match found\\n            if (j == ar->data_length - 1) {\\n                o++;\\n            }\\n        }\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_ArraySized. The size of the array is the\\n * number of elements contained within the CC_ArraySized.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_ArraySized.\\n */\\nsize_t cc_array_sized_size(CC_ArraySized *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_ArraySized. The capacity of the CC_ArraySized is\\n * the maximum number of elements an CC_ArraySized can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_ArraySized.\\n */\\nsize_t cc_array_sized_capacity(CC_ArraySized *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sized_sort(CC_ArraySized *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, ar->data_length, cmp);\\n}\\n\\n/**\\n * Expands the CC_ArraySized capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS) {\\n        return CC_ERR_MAX_CAPACITY;\\n    }\\n\\n    size_t new_capacity = (size_t) (ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity) {\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    } else {\\n        ar->capacity = new_capacity;\\n    }\\n    uint8_t *new_buff = ar->mem_alloc(ar->capacity * ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    memcpy(new_buff, ar->buffer, ar->size * ar->data_length);\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_sized_map(CC_ArraySized *ar, void (*fn) (uint8_t *e))\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        fn(BUF_ADDR(ar, i));\\n    }\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_sized_reduce(CC_ArraySized *ar, void (*fn) (uint8_t*, uint8_t*, uint8_t*), uint8_t *result)\\n{\\n    if (ar->size == 1) {\\n        fn(BUF_ADDR(ar, 0), NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1) {\\n        fn(BUF_ADDR(ar, 0), BUF_ADDR(ar, 1), result);\\n    }\\n    for (size_t i = 2; i < ar->size; i++) {\\n        fn(result, BUF_ADDR(ar, i), result);\\n    }\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_sized_iter_init(CC_ArraySizedIter *iter, CC_ArraySized *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the reference of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_sized_iter_next(CC_ArraySizedIter *iter, uint8_t **out)\\n{\\n    if (iter->index >= iter->ar->size) {\\n        return CC_ITER_END;\\n    }\\n    *out = BUF_ADDR(iter->ar, iter->index);\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_sized_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_sized_iter_remove(CC_ArraySizedIter *iter, uint8_t *out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_sized_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK) {\\n            iter->last_removed = true;\\n        }\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_ArraySized after the last returned element by\\n * <code>cc_array_sized_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_iter_add(CC_ArraySizedIter *iter, uint8_t *element)\\n{\\n    return cc_array_sized_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_sized_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_iter_replace(CC_ArraySizedIter *iter, uint8_t *element, uint8_t *out)\\n{\\n    return cc_array_sized_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_sized_iter_index(CC_ArraySizedIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_sized_zip_iter_init(CC_ArraySizedZipIter *iter, CC_ArraySized *ar1, CC_ArraySized *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_sized_zip_iter_next(CC_ArraySizedZipIter *iter, uint8_t **out1, uint8_t **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size) {\\n        return CC_ITER_END;\\n    }\\n    *out1 = BUF_ADDR(iter->ar1, iter->index);\\n    *out2 = BUF_ADDR(iter->ar2, iter->index);\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_sized_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_remove(CC_ArraySizedZipIter *iter, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (!iter->last_removed) {\\n        cc_array_sized_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_sized_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_sized_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_sized_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_add(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_ArraySized  *ar1  = iter->ar1;\\n    CC_ArraySized  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n        (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK))) {\\n        return CC_ERR_ALLOC;\\n    }\\n    cc_array_sized_add_at(ar1, e1, index);\\n    cc_array_sized_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_zip_iter_replace(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    cc_array_sized_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_sized_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_sized_zip_iter_index(CC_ArraySizedZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_sized_struct_size()\\n{\\n    return sizeof(CC_ArraySized);\\n}\", \"embeddings\": [0.018326789140701294, 0.00040868669748306274, -0.0060018859803676605, 0.07220053672790527, 0.30963200330734253, -0.11970095336437225, 0.15079595148563385, 0.40562954545021057, -0.0030549950897693634, -0.20272421836853027, 0.02815302647650242, -0.04541976749897003, 0.012288609519600868, 0.03833114728331566, 0.01934884488582611, 0.10310088098049164, -0.009303838945925236, -0.028130389750003815, 0.0334308035671711, -0.20392438769340515, -0.17615069448947906, 0.0398385263979435, 0.22039315104484558, 0.1192820593714714, 0.1394381821155548, 0.026306170970201492, 0.2520814836025238, 0.17186219990253448, 0.2966987192630768, -0.12380428612232208, 0.04713321477174759, -0.0829804465174675, 0.11353029310703278, -0.15351763367652893, 0.04941720888018608, -0.013759054243564606, 0.016832832247018814, 0.0402006059885025, 0.04971354827284813, 0.013745885342359543, -0.1487831473350525, -0.05876554548740387, 0.06696358323097229, 0.20159974694252014, 0.09804068505764008, 0.02218669466674328, 0.06591371446847916, 0.18756556510925293, -0.11194297671318054, 0.03358863666653633, 0.1120290607213974, 0.051376987248659134, -0.041479796171188354, -0.08409148454666138, -0.08800444006919861, 0.026530031114816666, 0.026672054082155228, 0.30638062953948975, 0.080718494951725, 0.009905502200126648, -0.026966892182826996, -0.01651054620742798, -0.1894061118364334, 0.14327123761177063, 0.16544432938098907, 0.050040844827890396, -0.10617886483669281, -0.1588468849658966, -0.0311075821518898, -0.05748908966779709, 0.13610047101974487, 0.042106591165065765, 0.05311362445354462, -0.1405281126499176, -0.17201033234596252, -0.0716840922832489, 0.15104398131370544, 0.5616332292556763, -0.05856747925281525, 0.17174746096134186, 0.26475730538368225, -0.09185905754566193, 0.023069433867931366, 0.20814460515975952, 0.08684767782688141, -0.043311603367328644, -0.04913146048784256, 0.07018201798200607, -0.013929340988397598, 0.10176722705364227, 0.09930595010519028, 0.1157674789428711, -0.0975877121090889, -0.040871959179639816, 0.013221988454461098, 0.003612518310546875, 0.07169847190380096, -0.30897706747055054, 0.033892594277858734, 0.32725024223327637, -0.045322272926568985, -0.0785425454378128, -0.22163993120193481, -0.10638664662837982, -0.015047803521156311, -0.02052057906985283, -0.02263379842042923, 0.06861657649278641, 0.09432952105998993, -0.07474774867296219, 0.12257392704486847, 0.05775900557637215, -0.055622830986976624, 0.03391642868518829, 0.0882529765367508, -0.19001692533493042, 0.034917183220386505, 0.010255381464958191, 0.12912797927856445, -0.08958473056554794, 0.05545724928379059, -0.014354631304740906, -0.051545776426792145, -0.018031463027000427, -0.02370789647102356, 0.12191087007522583, 0.018273688852787018, -0.2137400507926941, 0.07294544577598572, 0.08006776124238968, 0.03850147873163223, -0.16957102715969086, -0.018106549978256226, 0.08989247679710388, 0.126716747879982, -0.03681068494915962, 0.06226155906915665, 0.0642615407705307, 0.03242427855730057, -0.01938065141439438, -0.03023061901330948, 0.10691563785076141, 0.26024699211120605, -0.07973992824554443, 0.21688216924667358, -0.1668751984834671, 0.11746817827224731, 0.10402898490428925, -0.2723134160041809, -0.13317006826400757, 0.006266608834266663, -0.114145427942276, 0.03160563111305237, 0.010639561340212822, -0.12887006998062134, 0.8221960663795471, 0.19332373142242432, -0.1387447714805603, -0.08311442285776138, -0.02413332462310791, 0.03812215477228165, -0.24929529428482056, -0.03880666196346283, 0.11152645945549011, 0.022216714918613434, 0.09716556966304779, 0.016097385436296463, 0.1391458958387375, 0.12875370681285858, 0.07906166464090347, 0.05999375134706497, -0.059925854206085205, -0.1451895534992218, 0.2009233981370926, 0.05689084529876709, -0.04260854423046112, -0.11766214668750763, 0.09867306053638458, -0.049640823155641556, 0.07762371748685837, -0.12394234538078308, -0.02141447365283966, -0.17439867556095123, -0.04981306195259094, 0.000862855464220047, 0.07218770682811737, 0.06534262746572495, -0.06841991096735, 0.0750921368598938, 0.018195290118455887, -0.05238289386034012, 0.052337437868118286, 0.15398193895816803, -0.08632631599903107, -0.07911468297243118, 0.036675818264484406, -0.10301487892866135, -0.06568477302789688, 0.20771759748458862, -0.08367043733596802, -0.006024032831192017, -0.15713420510292053, 0.21316802501678467, -0.046685706824064255, 0.1703382432460785, 0.09105278551578522, -0.17005544900894165, 0.022159546613693237, -0.030472729355096817, -0.08127740025520325, -0.09825694561004639, 0.03187807649374008, 0.12490303814411163, -0.003071306273341179, -0.07294602692127228, -0.043159376829862595, -0.049677204340696335, 0.028551828116178513, 0.060277361422777176, -0.14059431850910187, 0.14895205199718475, 0.18821406364440918, -0.05318722873926163, -0.02876099944114685, -0.09137295186519623, 0.23457199335098267, 0.20854884386062622, 0.06108914315700531, 0.07761499285697937, 0.012371495366096497, 0.18190892040729523, 0.15510274469852448, -0.13505330681800842, 0.15783463418483734, -0.03852004557847977, -0.09662804007530212, -0.07044655084609985, 0.0305820032954216, -0.047405146062374115, -0.14162856340408325, -0.009039033204317093, 0.12592050433158875, 0.1483667492866516, 0.24361664056777954, 0.08762246370315552, -0.04392600804567337, -0.2072712928056717, 0.11569643020629883, -0.12346042692661285, 0.05622471496462822, -0.005774613469839096, -0.04730750247836113, 0.0674821138381958, -0.027054790407419205, -0.12589769065380096, -0.06070801243185997, -0.19382387399673462, 0.028323687613010406, 0.10705406963825226, 0.06940990686416626, -0.05386233329772949, -0.0974067971110344, 0.080359548330307, -0.04618799686431885, -0.09073999524116516, -0.35877013206481934, 0.0041972920298576355, 0.0456794872879982, 0.07781323045492172, -0.004001924768090248, 0.04878237470984459, -0.06496825069189072, 0.25307634472846985, 0.12221571058034897, 0.0766068622469902, 0.05662322789430618, 0.04645705223083496, 0.023556523025035858, -0.15030835568904877, -0.036951400339603424, -0.029631439596414566, 0.07201725244522095, -0.04254838451743126, 0.042151279747486115, -0.04462852329015732, 0.04836968332529068, 0.10237541794776917, 0.04655234515666962, -0.007685452699661255, 0.08204154670238495, 0.05333385616540909, -0.02520880103111267, 0.056379079818725586, 0.14872358739376068, 0.025910871103405952, 0.13906285166740417, 0.2186785191297531, -0.09234067797660828, 0.018714431673288345, -0.2569742500782013, 0.11158658564090729, -0.09080096334218979, -0.01874507963657379, -0.08694198727607727, 0.33522284030914307, -0.09325891733169556, 0.02356395684182644, -0.001541033387184143, 0.260972797870636, 0.05720154196023941, 0.054884400218725204, 0.10778369009494781, -0.11359120160341263, 0.11962541937828064, -0.11495880782604218, 0.04410487785935402, -0.0945127084851265, -0.018614191561937332, 0.10057450830936432, 0.0008508488535881042, -0.08574458956718445, 0.14815036952495575, 0.13853482902050018, 0.1451846957206726, -0.045983847230672836, 0.1346525400876999, 0.17723631858825684, -0.06959859281778336, -0.10764982551336288, 0.6834275126457214, -0.4407510757446289, 0.17893044650554657, -0.1676187962293625, 0.31149762868881226, -0.04497118294239044, 0.2580735683441162, -0.08506802469491959, 0.06236138939857483, 0.12316377460956573, 0.13966962695121765, -0.09929712116718292, -0.037969768047332764, -0.10282956063747406, 0.19856862723827362, 0.07494815438985825, 0.2217596471309662, 0.09903275221586227, -0.05408528074622154, 0.1537991464138031, -0.015786929056048393, -0.15666376054286957, 0.10075536370277405, -0.02185332030057907, -0.10853733867406845, 0.11943970620632172, 0.39106854796409607, -0.13479632139205933, -0.06552591919898987, -0.03876498341560364, 0.00542020658031106, 0.12684014439582825, -0.10114812105894089, 0.16389474272727966, -0.07694775611162186, 0.2349131852388382, -0.34705081582069397, -0.35284915566444397, 0.0016878154128789902, -0.048541199415922165, 0.053107596933841705, 0.10332834720611572, 0.20654326677322388, 0.1143723875284195, -0.18247641623020172, 0.01721048727631569, -0.012122072279453278, -0.08433476090431213, 0.04433903098106384, 0.13995936512947083, 0.16834600269794464, 0.0304877832531929, 0.07442599534988403, 0.08503657579421997, 0.0262364000082016, 0.017472028732299805, -0.12826278805732727, 0.23986326158046722, 0.2009677290916443, 0.2317059487104416, -0.10119107365608215, 0.13020509481430054, -0.12023019790649414, 0.08833923935890198, 0.06618250161409378, 0.0360601544380188, -0.02177644893527031, -0.0745481625199318, 0.12799721956253052, -0.08700413256883621, -0.09086014330387115, 0.13382990658283234, 0.1833823323249817, -0.06496895849704742, 0.13935214281082153, 0.13192428648471832, 0.10900640487670898, 0.13185405731201172, -0.11028259992599487, -0.1703314334154129, -0.11066265404224396, 0.11602603644132614, 0.028848525136709213, 0.07168641686439514, 0.04210975766181946, 0.14730404317378998, -0.05590254068374634, -0.015862591564655304, -0.24432022869586945, -0.10909869521856308, 0.20729920268058777, 0.17305967211723328, 0.08963488042354584, -0.014089219272136688, -0.11716557294130325, -0.034083619713783264, -0.07785481214523315, -0.05330254137516022, -0.06810499727725983, 0.09164609014987946, -0.10362023115158081, 0.11404138803482056, 0.23150359094142914, 0.111551433801651, 0.1208084374666214, 0.09428083896636963, -0.06736143678426743, -0.10082468390464783, -0.041022349148988724, -0.015196301974356174, 0.11699950695037842, -0.051230017095804214, 0.03972303494811058, -0.02674996107816696, 0.03848041594028473, -0.07919842004776001, -0.1291593611240387, 0.46439847350120544, 0.08599448204040527, -0.08556392788887024, 0.01725395768880844, -0.19349226355552673, 0.06026717647910118, -0.08372054994106293, -0.4091459810733795, 0.11609891802072525, 0.27986598014831543, 0.10784093290567398, -0.012147437781095505, 0.0859689936041832, 0.008027404546737671, 0.03159626945853233, 0.07437984645366669, -0.004686344414949417, -0.0818449929356575, 0.015408352017402649, -0.06229054182767868, 0.11145919561386108, 0.08174261450767517, 0.12400221824645996, 0.07616415619850159, 0.01777707040309906, 0.15416789054870605, 0.028004376217722893, -0.10308955609798431, -0.002988021820783615, 0.05158526450395584, -0.06146428361535072, -0.20620077848434448, 0.11639465391635895, -0.19408199191093445, -0.055413518100976944, 0.09999094903469086, 0.16263622045516968, -0.02223246544599533, -0.035454005002975464, -0.09745632857084274, 0.27867841720581055, 0.09115134179592133, -0.16990926861763, -0.025574449449777603, 0.008984585292637348, 0.12111662328243256, -0.02655055746436119, 0.1406284123659134, 0.26786863803863525, 0.14091932773590088, 0.10574646294116974, 0.06638778746128082, 0.24084541201591492, -0.08934538066387177, 0.02189849689602852, 0.1676243543624878, 0.05632289871573448, -0.002717074006795883, -0.16914339363574982, -0.11278440803289413, -0.03404931351542473, 0.07617838680744171, 0.11826185882091522, -0.15199267864227295, -0.05949044227600098, -0.0549679771065712, 0.15194350481033325, 0.002597130835056305, 0.037430278956890106, 0.010367527604103088, 0.04965592175722122, 0.061340950429439545, -0.07669027894735336, 0.22575241327285767, -0.10101351141929626, -0.12544716894626617, -0.03685959801077843, 0.021009553223848343, -0.011819040402770042, 0.03003031387925148, 0.09925004839897156, -0.07910924404859543, 0.13814568519592285, -0.012748893350362778, 0.009565722197294235, 0.03031427040696144, 0.060569681227207184, 0.14921002089977264, -0.06203040853142738, 0.053921982645988464, 0.07923980057239532, -0.029984716325998306, 0.16238950192928314, -0.12088702619075775, -0.2167980819940567, -0.07783288508653641, 0.1308489739894867, -0.09015421569347382, 0.16024520993232727, 0.008086703717708588, 0.2092008888721466, 0.058352693915367126, 0.02041388861835003, -0.024258583784103394, -0.11117060482501984, -0.8190872073173523, 0.006301769986748695, 0.12878447771072388, -0.05400277301669121, 0.05758151039481163, 0.1154181957244873, 0.10445214807987213, 0.07750783860683441, 0.10681171715259552, 0.10023323446512222, -0.04179917275905609, 0.11886972934007645, 0.11330749839544296, -0.14634256064891815, -0.08225643634796143, 0.050023067742586136, 0.0784262865781784, -0.1674533635377884, 0.15307167172431946, 0.029619717970490456, -0.13451078534126282, -0.004721753299236298, 0.3284263610839844, 0.026880301535129547, -0.010122563689947128, 0.23933961987495422, 0.059125930070877075, 0.20807968080043793, -0.08644798398017883, 0.09041696041822433, 0.24427685141563416, 0.15556395053863525, -0.27695199847221375, 0.07560562342405319, 0.10948498547077179, 0.14562851190567017, 0.1290961354970932, 13.706263542175293, -0.08357661962509155, 0.2157653421163559, -0.03690636157989502, -0.028849124908447266, -0.005949251353740692, -0.06846898049116135, 0.08900222182273865, 0.010719925165176392, -0.03553050756454468, 0.03173483535647392, 0.010646991431713104, -0.08387657254934311, -0.013972114771604538, 0.011522538959980011, -0.0967794805765152, 0.016453908756375313, -0.06956855207681656, 0.1367606222629547, -0.0006277710199356079, -0.14973048865795135, -0.14706923067569733, 0.009854510426521301, -0.4393558204174042, -0.055124230682849884, 0.05211719870567322, 0.15308335423469543, 0.09606549888849258, 0.07428502291440964, 0.10637301951646805, 0.16026157140731812, 0.10842856019735336, 0.060752153396606445, -0.04280637204647064, -0.0980226919054985, -0.11942557245492935, -0.42551189661026, -0.2047695815563202, 0.07932276278734207, -0.027005895972251892, -0.013018496334552765, 0.03662955388426781, 0.18555176258087158, -0.0766574963927269, 0.10600176453590393, 0.10032624006271362, -0.2109222114086151, 0.08853702992200851, -0.04580330103635788, -0.06564383208751678, 0.1394132375717163, 0.10031624138355255, 0.30707961320877075, 0.02990565448999405, -0.12492074817419052, -0.264972984790802, 0.21550408005714417, 0.05101443827152252, -0.05500832200050354, 0.3868119716644287, -0.05955478549003601, -0.13800105452537537, -0.027383919805288315, -0.11452730000019073, -0.06267649680376053, -0.00259409099817276, 0.127111554145813, 0.031030789017677307, -0.06389029324054718, 0.1330927312374115, 0.22222189605236053, -0.1833183318376541, 0.15476110577583313, 0.04286986216902733, -0.08627444505691528, 0.07034507393836975, -0.0618770495057106, -0.01741696149110794, 0.045136019587516785, -0.14633992314338684, 0.013428747653961182, 0.03794189542531967, -0.20110952854156494, -0.12949201464653015, -0.1687808781862259, 0.1306091845035553, -0.09114433825016022, 0.2054925262928009, 0.2317696213722229, -0.0359744057059288, -0.08508116006851196, 0.06932249665260315, -0.07145696878433228, -0.11326155811548233, 0.21551477909088135, -0.04645142704248428, -0.03789924830198288, -0.14276085793972015, 0.03324282914400101, 0.13308210670948029, -0.039328478276729584, -0.14258690178394318, 0.03001953661441803, 0.03780597448348999, -0.14048925042152405, -0.004871062934398651, 0.06588580459356308, 0.016497783362865448, -0.0553097128868103, 0.0037385616451501846, -0.002240702509880066, 0.11779884994029999, 0.14933229982852936, -0.15396149456501007, -0.1035834401845932, -0.0216546431183815, 0.013877974823117256, -0.00952959805727005, 0.2494620978832245, 0.07987948507070541, 0.18348845839500427, 0.09837900847196579, -0.14299504458904266, -0.04785213991999626, 0.09653826057910919, -0.1513257473707199, 0.04981723055243492, 0.18280650675296783, 0.10123851895332336, 0.0026155859231948853, 0.12456756830215454, -0.09625167399644852, 0.39384692907333374, 0.12313008308410645, -0.023723073303699493, -0.045271530747413635, -0.07028871029615402, 0.07523834705352783, 0.1625117063522339, 0.17797458171844482, 0.043470047414302826, 0.0019466951489448547, 0.15455567836761475, -0.1539190262556076, 0.01735142059624195, 0.2646818459033966, 0.2400394082069397, 0.000864783301949501, -0.0658138245344162, 0.16972437500953674, 0.16672351956367493, 0.2305651605129242, -0.11343417316675186, -0.10525193810462952, -0.09431266784667969, -0.1420937478542328, -0.12201812863349915, -0.025512386113405228, -0.029683254659175873, 0.013561512343585491, 0.20583751797676086, -0.43460318446159363, 0.04811372980475426, -0.28462332487106323, -0.04942898079752922, 0.0009293109178543091, 0.053344301879405975, 0.08675223588943481, 0.09668421000242233, -0.04718507081270218, 0.06651265174150467, 0.11646632850170135, -0.21451453864574432, -0.027366764843463898, -0.07126207649707794, 0.09703488647937775, 0.24299395084381104, -0.29866331815719604, -0.17728374898433685, 0.01934516802430153]}"
"{\"sha\": \"8490a88f377d8fed802e4f3b2d1d87a0d6cb81b2\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/sized/cc_array_sized.c\", \"func_name\": \"cc_array_sized_reduce\", \"original_string\": \"void cc_array_sized_reduce(CC_ArraySized *ar, void (*fn) (uint8_t*, uint8_t*, uint8_t*), uint8_t *result)\\n{\\n    if (ar->size == 1) {\\n        fn(BUF_ADDR(ar, 0), NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1) {\\n        fn(BUF_ADDR(ar, 0), BUF_ADDR(ar, 1), result);\\n    }\\n    for (size_t i = 2; i < ar->size; i++) {\\n        fn(result, BUF_ADDR(ar, i), result);\\n    }\\n}\", \"code_tokens\": [\"void\", \"cc_array_sized_reduce\", \"(\", \"CC_ArraySized\", \"*\", \"ar\", \",\", \"void\", \"(\", \"*\", \"fn\", \")\", \"(\", \"uint8_t\", \"*\", \",\", \"uint8_t\", \"*\", \",\", \"uint8_t\", \"*\", \")\", \",\", \"uint8_t\", \"*\", \"result\", \")\", \"{\", \"if\", \"(\", \"ar\", \"->\", \"size\", \"==\", \"1\", \")\", \"{\", \"fn\", \"(\", \"BUF_ADDR\", \"(\", \"ar\", \",\", \"0\", \")\", \",\", \"NULL\", \",\", \"result\", \")\", \";\", \"return\", \";\", \"}\", \"if\", \"(\", \"ar\", \"->\", \"size\", \">\", \"1\", \")\", \"{\", \"fn\", \"(\", \"BUF_ADDR\", \"(\", \"ar\", \",\", \"0\", \")\", \",\", \"BUF_ADDR\", \"(\", \"ar\", \",\", \"1\", \")\", \",\", \"result\", \")\", \";\", \"}\", \"for\", \"(\", \"size_t\", \"i\", \"=\", \"2\", \";\", \"i\", \"<\", \"ar\", \"->\", \"size\", \";\", \"i\", \"++\", \")\", \"{\", \"fn\", \"(\", \"result\", \",\", \"BUF_ADDR\", \"(\", \"ar\", \",\", \"i\", \")\", \",\", \"result\", \")\", \";\", \"}\", \"}\"], \"docstring\": \"/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"A\", \"fold\", \"/\", \"reduce\", \"function\", \"that\", \"collects\", \"all\", \"of\", \"the\", \"elements\", \"in\", \"the\", \"array\", \"*\", \"together\", \".\", \"For\", \"example\", \"if\", \"we\", \"have\", \"an\", \"array\", \"of\", \"[\", \"a\", \"b\", \"c\", \"...\", \"]\", \"the\", \"end\", \"result\", \"*\", \"will\", \"be\", \"(\", \"...\", \"((\", \"a\", \"+\", \"b\", \")\", \"+\", \"c\", \")\", \"+\", \"...\", \")\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"ar\", \"the\", \"array\", \"on\", \"which\", \"this\", \"operation\", \"is\", \"performed\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"fn\", \"the\", \"operation\", \"function\", \"that\", \"is\", \"to\", \"be\", \"invoked\", \"on\", \"each\", \"array\", \"*\", \"element\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"result\", \"the\", \"pointer\", \"which\", \"will\", \"collect\", \"the\", \"end\", \"result\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2024 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n\\n#include \\\"sized/cc_array_sized.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\n#define INDEX(a, i) a->data_length * i\\n#define BUF_ADDR(a, i) &a->buffer[a->data_length * i]\\n\\n\\nstruct cc_array_sized_s {\\n    size_t   data_length;\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    uint8_t *buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[in] Size of the array element in bytes\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new(size_t element_size, CC_ArraySized **out)\\n{\\n    CC_ArraySizedConf c;\\n    cc_array_sized_conf_init(&c);\\n    return cc_array_sized_new_conf(element_size, &c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_ArraySized based on the specified CC_ArraySizedConf struct \\n * and returns a status code.\\n *\\n * The CC_ArraySized is allocated using the allocators specified in the CC_ArraySizedConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArraySizedConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] element_size the size of the data being stored in bytes\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new_conf(\\n    size_t element_size, \\n    CC_ArraySizedConf const * const conf, \\n    CC_ArraySized **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_ArraySized *ar = conf->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    uint8_t *buff = conf->mem_alloc(conf->capacity * element_size);\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->data_length = element_size;\\n    ar->buffer      = buff;\\n    ar->exp_factor  = ex;\\n    ar->capacity    = conf->capacity;\\n    ar->mem_alloc   = conf->mem_alloc;\\n    ar->mem_calloc  = conf->mem_calloc;\\n    ar->mem_free    = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArraySizedConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArraySizedConf structure that is being initialized\\n */\\nvoid cc_array_sized_conf_init(CC_ArraySizedConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_ArraySized structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_sized_destroy(CC_ArraySized *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n\\n/**\\n * Adds a new element to the CC_ArraySized. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_ArraySized.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add(CC_ArraySized *ar, uint8_t *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    memcpy(BUF_ADDR(ar, ar->size), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add_at(CC_ArraySized *ar, uint8_t *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_sized_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * ar->data_length;\\n\\n    memmove(BUF_ADDR(ar, (index + 1)),\\n            BUF_ADDR(ar, index),\\n            shift);\\n\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_ArraySized.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_replace_at(CC_ArraySized *ar, uint8_t *element, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n* Swaps the values at the specified indices.\\n*\\n* @param[in] ar array whose elements are being swapped\\n* @param[in] index1 first position\\n* @param[in] index2 second position\\n* \\n* @return CC_OK if the operation was successful, or CC_ERR_OUT_OF_RANGE if \\n* one of the indices was out of range.\\n*/\\nenum cc_stat cc_array_sized_swap_at(CC_ArraySized *ar, size_t index1, size_t index2)\\n{\\n    if (index1 >= ar->size || index2 >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n\\n    for (size_t i = 0; i < ar->data_length; i++) {\\n        uint8_t tmp = ar->buffer[INDEX(ar, index1 + i)];\\n        ar->buffer[INDEX(ar, index1 + i)] = ar->buffer[INDEX(ar, index2 + i)];\\n        ar->buffer[INDEX(ar, index2 + i)] = tmp;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_ArraySized if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_sized_remove(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_sized_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n \\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_remove_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_sized_remove_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    return cc_array_sized_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_sized_remove_all(CC_ArraySized *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Copies an CC_ArraySized element from the specified index to the out pointer.\\n * The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] source index of the array element\\n * @param[out] destination address\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_sized_get_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_sized_get_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n    return cc_array_sized_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n* Returns the pointer to the element at the specified index\\n*/\\nenum cc_stat cc_array_sized_peek(CC_ArraySized* ar, size_t index, uint8_t** out)\\n{\\n    if (index > ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    *out = BUF_ADDR(ar, index);\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst uint8_t * const* cc_array_sized_get_buffer(CC_ArraySized *ar)\\n{\\n    return (const uint8_t* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_ArraySized.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_sized_index_of(CC_ArraySized *ar, uint8_t *element, size_t *index)\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) { \\n            // Mismatching byte, skip to next block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            if (j == ar->data_length - 1) {\\n                *index = i;\\n                return CC_OK;\\n            }\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_ArraySized, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_ArraySized, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's allocators\\n *       and it also inherits the configuration of the original CC_ArraySized.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_sized_subarray(CC_ArraySized *ar, size_t b, size_t e, CC_ArraySized **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_ArraySized *sub_ar = ar->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * ar->data_length))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc   = ar->mem_alloc;\\n    sub_ar->mem_calloc  = ar->mem_calloc;\\n    sub_ar->mem_free    = ar->mem_free;\\n    sub_ar->size        = e - b + 1;\\n    sub_ar->capacity    = sub_ar->size;\\n    sub_ar->data_length = ar->data_length;\\n\\n    memcpy(sub_ar->buffer,\\n           BUF_ADDR(ar, b),\\n           sub_ar->size * ar->data_length);\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a copy of the specified CC_ArraySized. \\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's\\n *       allocators and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_sized_copy(CC_ArraySized *ar, CC_ArraySized **out)\\n{\\n    CC_ArraySized *copy = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->data_length = ar->data_length;\\n    copy->exp_factor  = ar->exp_factor;\\n    copy->size        = ar->size;\\n    copy->capacity    = ar->capacity;\\n    copy->mem_alloc   = ar->mem_alloc;\\n    copy->mem_calloc  = ar->mem_calloc;\\n    copy->mem_free    = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * ar->data_length);\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_ArraySized was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_ArraySized is empty.\\n */\\nenum cc_stat cc_array_sized_filter_mut(CC_ArraySized *ar, bool (*pred) (const uint8_t*))\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(BUF_ADDR(ar, i))) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * ar->data_length;\\n                memmove(BUF_ADDR(ar, (i + 1)),\\n                        BUF_ADDR(ar, (i + 1 + rm)),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * ar->data_length;\\n        memmove(BUF_ADDR(ar, 0),\\n                BUF_ADDR(ar, rm),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by creating a new CC_ArraySized that contains all elements\\n * from the original CC_ArraySized that return true on pred(element) without modifying \\n * the original CC_ArraySized.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_sized_filter(CC_ArraySized *ar, bool (*pred) (const uint8_t*), CC_ArraySized **out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    CC_ArraySized *filtered = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!filtered) {\\n        return CC_ERR_ALLOC;\\n    }\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->data_length = ar->data_length;\\n    filtered->exp_factor  = ar->exp_factor;\\n    filtered->size        = 0;\\n    filtered->capacity    = ar->capacity;\\n    filtered->mem_alloc   = ar->mem_alloc;\\n    filtered->mem_calloc  = ar->mem_calloc;\\n    filtered->mem_free    = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(BUF_ADDR(ar, i))) {\\n            memcpy(BUF_ADDR(filtered, f++), \\n                   BUF_ADDR(ar, i),\\n                   ar->data_length);\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_sized_reverse(CC_ArraySized *ar, uint8_t *tmp)\\n{\\n    if (ar->size == 0) {\\n        return;\\n    }\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        memcpy(tmp, BUF_ADDR(ar, i), ar->data_length);\\n        memcpy(BUF_ADDR(ar, i), BUF_ADDR(ar, j), ar->data_length);\\n        memcpy(BUF_ADDR(ar, j), tmp, ar->data_length);\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_ArraySized, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_sized_trim_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->size == ar->capacity) {\\n        return CC_OK;\\n    }\\n    uint8_t *new_buff = ar->mem_calloc(ar->size, ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * ar->data_length);\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_ArraySized.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_sized_contains(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t o = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) {\\n            // Mismatching byte, skip block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            // Last byte is equal, match found\\n            if (j == ar->data_length - 1) {\\n                o++;\\n            }\\n        }\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_ArraySized. The size of the array is the\\n * number of elements contained within the CC_ArraySized.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_ArraySized.\\n */\\nsize_t cc_array_sized_size(CC_ArraySized *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_ArraySized. The capacity of the CC_ArraySized is\\n * the maximum number of elements an CC_ArraySized can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_ArraySized.\\n */\\nsize_t cc_array_sized_capacity(CC_ArraySized *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sized_sort(CC_ArraySized *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, ar->data_length, cmp);\\n}\\n\\n/**\\n * Expands the CC_ArraySized capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS) {\\n        return CC_ERR_MAX_CAPACITY;\\n    }\\n\\n    size_t new_capacity = (size_t) (ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity) {\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    } else {\\n        ar->capacity = new_capacity;\\n    }\\n    uint8_t *new_buff = ar->mem_alloc(ar->capacity * ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    memcpy(new_buff, ar->buffer, ar->size * ar->data_length);\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_sized_map(CC_ArraySized *ar, void (*fn) (uint8_t *e))\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        fn(BUF_ADDR(ar, i));\\n    }\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_sized_reduce(CC_ArraySized *ar, void (*fn) (uint8_t*, uint8_t*, uint8_t*), uint8_t *result)\\n{\\n    if (ar->size == 1) {\\n        fn(BUF_ADDR(ar, 0), NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1) {\\n        fn(BUF_ADDR(ar, 0), BUF_ADDR(ar, 1), result);\\n    }\\n    for (size_t i = 2; i < ar->size; i++) {\\n        fn(result, BUF_ADDR(ar, i), result);\\n    }\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_sized_iter_init(CC_ArraySizedIter *iter, CC_ArraySized *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the reference of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_sized_iter_next(CC_ArraySizedIter *iter, uint8_t **out)\\n{\\n    if (iter->index >= iter->ar->size) {\\n        return CC_ITER_END;\\n    }\\n    *out = BUF_ADDR(iter->ar, iter->index);\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_sized_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_sized_iter_remove(CC_ArraySizedIter *iter, uint8_t *out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_sized_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK) {\\n            iter->last_removed = true;\\n        }\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_ArraySized after the last returned element by\\n * <code>cc_array_sized_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_iter_add(CC_ArraySizedIter *iter, uint8_t *element)\\n{\\n    return cc_array_sized_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_sized_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_iter_replace(CC_ArraySizedIter *iter, uint8_t *element, uint8_t *out)\\n{\\n    return cc_array_sized_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_sized_iter_index(CC_ArraySizedIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_sized_zip_iter_init(CC_ArraySizedZipIter *iter, CC_ArraySized *ar1, CC_ArraySized *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_sized_zip_iter_next(CC_ArraySizedZipIter *iter, uint8_t **out1, uint8_t **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size) {\\n        return CC_ITER_END;\\n    }\\n    *out1 = BUF_ADDR(iter->ar1, iter->index);\\n    *out2 = BUF_ADDR(iter->ar2, iter->index);\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_sized_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_remove(CC_ArraySizedZipIter *iter, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (!iter->last_removed) {\\n        cc_array_sized_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_sized_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_sized_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_sized_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_add(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_ArraySized  *ar1  = iter->ar1;\\n    CC_ArraySized  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n        (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK))) {\\n        return CC_ERR_ALLOC;\\n    }\\n    cc_array_sized_add_at(ar1, e1, index);\\n    cc_array_sized_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_zip_iter_replace(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    cc_array_sized_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_sized_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_sized_zip_iter_index(CC_ArraySizedZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_sized_struct_size()\\n{\\n    return sizeof(CC_ArraySized);\\n}\", \"embeddings\": [0.05151715129613876, 0.1287212371826172, 0.04387984424829483, 0.08430197834968567, 0.4503750801086426, -0.15875908732414246, 0.09497379511594772, 0.4825676381587982, 0.0009562261402606964, -0.30577972531318665, 6.655976176261902e-05, -0.110260508954525, 0.065841443836689, 0.09760475158691406, 0.061910420656204224, 0.11910834908485413, 0.038494210690259933, -0.12310834974050522, 0.05887684226036072, -0.2842399775981903, -0.18573352694511414, 0.0964144915342331, 0.17258422076702118, 0.10258308798074722, 0.10648234188556671, 0.127192884683609, 0.30019617080688477, 0.20079462230205536, 0.3916817605495453, -0.16656328737735748, -0.006896518170833588, -0.084780253469944, 0.0577964149415493, -0.18460023403167725, -0.02508445456624031, -0.04035893827676773, -0.02855023741722107, 0.04596728831529617, -0.0014912476763129234, 0.04138531908392906, -0.20572082698345184, -0.014603675343096256, 0.10491923987865448, 0.15078100562095642, 0.12523521482944489, -0.02936309576034546, 0.09243057668209076, 0.1870007961988449, -0.023312274366617203, 0.049667514860630035, 0.10820223391056061, -0.0989249050617218, 0.008741333149373531, -0.059285201132297516, 0.004331108182668686, -0.0623619481921196, -0.01956888660788536, 0.295986533164978, -0.010527249425649643, -0.03499428182840347, -0.02642769366502762, -0.24154897034168243, -0.2639959156513214, 0.05366095155477524, 0.10326346755027771, -0.0065036192536354065, -0.142435684800148, -0.22945648431777954, -0.01352393627166748, -0.033136412501335144, 0.07647107541561127, 0.16712656617164612, 0.06200838088989258, -0.09090235084295273, -0.20616509020328522, -0.04745350778102875, 0.046696122735738754, 0.5507068634033203, -0.09321833401918411, 0.1689988374710083, 0.26130834221839905, -0.11125202476978302, 0.23609659075737, 0.14195957779884338, 0.14097434282302856, -0.03297417610883713, -0.10177851468324661, 0.17576545476913452, -0.07390879094600677, 0.09786004573106766, 0.09626400470733643, 0.1688322126865387, -0.10112521797418594, -0.10124264657497406, -0.01558474451303482, 0.005418408662080765, 0.1740691363811493, -0.1760942041873932, 0.07554544508457184, 0.4509836435317993, -0.07771295309066772, -0.04512818530201912, -0.28070661425590515, -0.1335185021162033, -0.02174239605665207, -0.04228750243782997, -0.07264503091573715, 0.05495813488960266, 0.07908042520284653, -0.01277092844247818, 0.21254880726337433, -0.005708128213882446, -0.052856504917144775, -0.02657194435596466, 0.013832096010446548, -0.2013430893421173, 0.10509755462408066, -0.017120324075222015, 0.18904542922973633, -0.10181102901697159, 0.08732106536626816, -0.0490557923913002, -0.021634772419929504, 0.02235732227563858, -0.10436838865280151, 0.08910545706748962, -0.020805448293685913, -0.2605053186416626, 0.11012424528598785, 0.015731260180473328, -0.04735960811376572, -0.13925577700138092, -0.010872535407543182, 0.09543025493621826, 0.16063246130943298, -0.060290027409791946, 0.09220743924379349, 0.03941396623849869, -0.015889078378677368, -0.00956553965806961, -0.015315704047679901, 0.06004062294960022, 0.2793687582015991, -0.02423590049147606, 0.0776059627532959, -0.13880883157253265, 0.14324027299880981, 0.07387595623731613, -0.3222420811653137, -0.16853414475917816, -0.056433744728565216, -0.1317848265171051, 0.04329460859298706, 0.07856030017137527, -0.154336616396904, 0.7620262503623962, 0.09387217462062836, -0.1272137463092804, -0.044887833297252655, -0.061693452298641205, 0.05574965849518776, -0.27278146147727966, 0.010103218257427216, 0.19283682107925415, 0.08888024091720581, 0.05820668861269951, 0.05271415784955025, 0.12027448415756226, 0.24063950777053833, 0.039980705827474594, 0.0910443514585495, -0.14466463029384613, -0.09615078568458557, 0.16714385151863098, 0.051297783851623535, -0.08303198963403702, -0.02432984486222267, 0.07961657643318176, -0.029343105852603912, 0.07552468776702881, -0.14433851838111877, -0.06179510056972504, -0.18820831179618835, -0.07922482490539551, -0.03261805325746536, 0.006692331284284592, 0.03740737587213516, -0.016569703817367554, 0.05718130245804787, -0.03430502861738205, 0.12864276766777039, 0.054967813193798065, 0.20260556042194366, -0.07857750356197357, -0.07481395453214645, 0.03652052581310272, -0.1582033932209015, -0.02156916819512844, 0.2571924924850464, -0.07853586971759796, -0.04583039879798889, -0.25147899985313416, 0.18691639602184296, -0.06969025731086731, 0.08326345682144165, 0.15030565857887268, -0.24886874854564667, -0.009128078818321228, -0.041506264358758926, -0.0015708401333540678, -0.17723879218101501, -0.04717110097408295, 0.08931702375411987, 0.07063869386911392, -0.07220074534416199, -0.09698209911584854, 0.09548082947731018, 0.15108400583267212, 0.08600988239049911, -0.08136539161205292, 0.15859729051589966, 0.23650294542312622, -0.10017070174217224, -0.043882012367248535, -0.11046092212200165, 0.28003689646720886, 0.20684176683425903, 0.10703565180301666, -0.022620130330324173, 0.04603663831949234, 0.1450302004814148, 0.19168990850448608, -0.1426047682762146, 0.17506816983222961, -0.0802362784743309, -0.16268372535705566, -0.13331258296966553, 0.005416005849838257, -0.055271245539188385, -0.1953471601009369, -0.01568371057510376, 0.2101651281118393, 0.20366708934307098, 0.30382779240608215, 0.1276811957359314, -0.0027911290526390076, -0.24729742109775543, -0.005991283804178238, -0.10488152503967285, 0.01855558156967163, -0.0003060232847929001, -0.03877352550625801, 0.007915034890174866, -0.06334173679351807, -0.12990190088748932, -0.08413717150688171, -0.2844398617744446, -0.012667644768953323, 0.05259903520345688, 0.16433721780776978, 0.009576890617609024, -0.10147853195667267, 0.16194939613342285, -0.055749401450157166, -0.15155646204948425, -0.48875683546066284, -0.05813059210777283, 0.0280280914157629, 0.09539692103862762, -0.0029023606330156326, 0.17752863466739655, -0.06876281648874283, 0.2540552318096161, 0.13634784519672394, -0.0022041387856006622, 0.011949136853218079, 0.07635271549224854, -0.013827715069055557, -0.2612021863460541, 0.0029875971376895905, 0.02488815225660801, -0.03306276351213455, -0.11461334675550461, -0.012469887733459473, -8.870381861925125e-05, 0.1124439612030983, 0.18555887043476105, 0.04539717733860016, 0.0832865983247757, 0.032643526792526245, 0.12233148515224457, 0.03274313732981682, -0.0066726310178637505, 0.17252318561077118, 0.08686185628175735, 0.07734880596399307, 0.30830174684524536, -0.051229774951934814, 0.014863662421703339, -0.24571731686592102, 0.17086920142173767, -0.22661137580871582, 0.008873636834323406, -0.03483470901846886, 0.28065791726112366, -0.005855299532413483, -0.005680404603481293, 0.022987961769104004, 0.20862944424152374, 0.07713343948125839, 0.0547112375497818, 0.10038420557975769, -0.11246710270643234, 0.05014888197183609, -0.06563390791416168, 0.08933570981025696, -0.0857756957411766, 0.000706896185874939, 0.11476583778858185, -0.008591830730438232, -0.07790021598339081, 0.14313875138759613, 0.2837022840976715, 0.19484984874725342, 0.03543603792786598, 0.05045170336961746, 0.03088127076625824, -0.11150723695755005, -0.25037702918052673, 0.5561584830284119, -0.4997131824493408, 0.20437514781951904, -0.1549229770898819, 0.2710528075695038, -0.08295093476772308, 0.28176575899124146, -0.015580587089061737, 0.15584436058998108, 0.15191909670829773, 0.1909668743610382, -0.14255639910697937, -0.04265857860445976, -0.20908792316913605, 0.27293431758880615, 0.17968440055847168, 0.23819571733474731, 0.12464666366577148, -0.09925243258476257, 0.12108837068080902, 0.00700691994279623, -0.09230014681816101, 0.23564240336418152, 0.0002674274146556854, -0.14107631146907806, 0.1363205462694168, 0.49066951870918274, -0.2456490397453308, -0.07415029406547546, -0.13719743490219116, 0.024183858186006546, 0.21169710159301758, -0.1782090663909912, 0.11269288510084152, -0.10997661203145981, 0.28986674547195435, -0.42008471488952637, -0.4651396870613098, 0.012850301340222359, -0.10617512464523315, 0.007393188774585724, 0.20786511898040771, 0.17153291404247284, 0.15819576382637024, -0.19087474048137665, 0.09139911830425262, -0.0006346777081489563, -0.0333528146147728, 0.06560909748077393, 0.17682087421417236, 0.21433128416538239, 0.047375909984111786, 0.07115370035171509, 0.08819128572940826, 0.030842375010252, 0.07743991911411285, -0.13212239742279053, 0.21368443965911865, 0.25015369057655334, 0.21682223677635193, -0.07948008179664612, 0.11644747108221054, -0.15041278302669525, 0.14464157819747925, 0.054858628660440445, -0.00037994980812072754, 0.012290474027395248, -0.04648742452263832, 0.2455616295337677, -0.061090365052223206, -0.14623640477657318, 0.141549751162529, 0.2361704409122467, -0.10294950008392334, 0.15351314842700958, 0.24060410261154175, -0.007876843214035034, 0.19128039479255676, -0.1832694411277771, -0.14038662612438202, -0.1071140319108963, 0.1331893503665924, 0.09940002113580704, 0.07813826203346252, 0.0007458366453647614, 0.19362285733222961, -0.06861263513565063, -0.03941881284117699, -0.21833449602127075, -0.15655845403671265, 0.13620564341545105, 0.16746345162391663, 0.07956715673208237, 0.06759874522686005, -0.19826024770736694, -0.10066694021224976, -0.025164183229207993, 0.00920538604259491, -0.10962734371423721, -0.038670264184474945, -0.148624449968338, 0.1383061707019806, 0.24266687035560608, 0.06588953733444214, 0.09349481761455536, 0.07549941539764404, -0.016916140913963318, -0.12730664014816284, -0.053777556866407394, 0.14940141141414642, 0.0409679040312767, -0.14660082757472992, 0.06998885422945023, 0.02927253395318985, 0.1539197415113449, -0.019660338759422302, -0.15055841207504272, 0.503990650177002, 0.07847313582897186, -0.13629525899887085, 0.17172476649284363, -0.23558712005615234, 0.028659187257289886, -0.04054610803723335, -0.19721560180187225, 0.10295230895280838, 0.3094700872898102, 0.10255949944257736, 0.03235040232539177, 0.2095579206943512, -0.0001239776611328125, 0.06163915991783142, 0.012273967266082764, -0.06479021906852722, -0.10687857121229172, 0.08202521502971649, -0.08757589012384415, 0.07066415995359421, 0.09587544202804565, 0.17665718495845795, 0.059448711574077606, 0.07062035799026489, 0.17982983589172363, 0.02531987428665161, -0.21588043868541718, 0.03368816524744034, -0.043151743710041046, 0.012369310483336449, -0.28803926706314087, 0.08667715638875961, -0.1703588366508484, -0.047569889575242996, 0.10578325390815735, 0.13569146394729614, 0.0730554461479187, 0.003005644306540489, -0.12053818255662918, 0.21098867058753967, 0.08595245331525803, -0.18921461701393127, -0.04052368924021721, -0.1443071961402893, 0.1619163602590561, 0.02621150203049183, 0.22156964242458344, 0.257831871509552, 0.24926863610744476, 0.011371947824954987, 0.1248982697725296, 0.34543371200561523, -0.10472261905670166, 0.039580054581165314, 0.1518843024969101, 0.017262279987335205, -0.03495422378182411, -0.15327312052249908, -0.05850253999233246, -0.10470518469810486, 0.060394175350666046, 0.14648966491222382, -0.15734311938285828, -0.0933113768696785, -0.14011693000793457, 0.13988809287548065, 0.06124209240078926, 0.012591637670993805, 0.006042018532752991, 0.009786166250705719, 0.031200602650642395, -0.16172833740711212, 0.32466572523117065, -0.0854310542345047, -0.15412719547748566, -0.021766752004623413, 0.01041577197611332, -0.07397062331438065, 0.02997603453695774, 0.024049062281847, -0.05556861311197281, 0.16193220019340515, -0.07053805142641068, -0.02860157936811447, -0.06252875924110413, 0.12135810405015945, 0.19005319476127625, -0.039811212569475174, 0.03138651326298714, 0.024238836020231247, 0.07227340340614319, 0.2588348984718323, -0.004202704411000013, -0.23264504969120026, -0.03392820060253143, 0.14328543841838837, -0.1429043561220169, 0.08293302357196808, 0.02969028800725937, 0.1772187054157257, 0.01542116329073906, 0.012427374720573425, 0.04594513773918152, -0.07449053227901459, -0.7468257546424866, 0.030322125181555748, 0.17167159914970398, 0.002468980848789215, 0.05803874880075455, 0.2232445329427719, 0.14245779812335968, 0.046520039439201355, 0.18440906703472137, 0.12268578261137009, 0.1259865164756775, 0.1439875364303589, 0.15534543991088867, -0.1170707419514656, -0.14199532568454742, -0.00484023243188858, 0.08867569267749786, -0.21871218085289001, 0.19909271597862244, -0.05535484477877617, -0.09759088605642319, 0.09902654588222504, 0.38145706057548523, 0.0616619735956192, -0.0620046965777874, 0.2306925654411316, 0.07809099555015564, 0.3008189797401428, -0.10343441367149353, 0.12583541870117188, 0.31449440121650696, 0.1802777498960495, -0.3461715579032898, 0.105405792593956, 0.06490883976221085, 0.11568471789360046, 0.09537957608699799, 14.09985065460205, -0.010500378906726837, 0.29010143876075745, -0.10147327929735184, -0.1251271665096283, 0.0026339683681726456, -0.13735637068748474, -0.009393967688083649, -0.013550281524658203, -0.03875381499528885, 0.055542826652526855, -0.061027511954307556, -0.011576535180211067, -0.07754959166049957, -0.008097052574157715, -0.17526096105575562, -0.11714673042297363, -0.11629675328731537, 0.22074994444847107, 0.060806646943092346, -0.17097055912017822, -0.15255185961723328, -0.034110695123672485, -0.5233279466629028, -0.054698359221220016, 0.01854296773672104, 0.19875898957252502, 0.00014700740575790405, 0.06324020028114319, 0.11010806262493134, 0.2168777585029602, 0.12926843762397766, 0.05945618078112602, -0.035895124077796936, 0.014938592910766602, -0.08345719426870346, -0.45197153091430664, -0.22059933841228485, 0.07973397523164749, 0.08150572329759598, -0.0561334490776062, 0.053679779171943665, 0.2877475619316101, -0.13326308131217957, 0.10828797519207001, 0.1419937163591385, -0.12436938285827637, 0.1487140953540802, -0.13252317905426025, -0.09416963160037994, 0.18391913175582886, 0.17701271176338196, 0.3440288305282593, 0.019504686817526817, -0.175616055727005, -0.30730774998664856, 0.31866419315338135, -0.058514535427093506, -0.058724164962768555, 0.4067753851413727, -0.06803923845291138, -0.17775952816009521, -0.09802363812923431, -0.04151725396513939, -0.006709090434014797, 0.04960235580801964, 0.1511123925447464, 0.045019298791885376, -0.23449085652828217, 0.11570293456315994, 0.30807843804359436, -0.19500888884067535, 0.31120938062667847, 0.05799264833331108, -0.1064053475856781, 0.046849753707647324, -0.1348131000995636, 0.000534404069185257, 0.02805115282535553, -0.11034800112247467, 0.03500804677605629, -0.012818649411201477, -0.2181311696767807, -0.17374707758426666, -0.3430251479148865, 0.061998989433050156, -0.09212838113307953, 0.17363284528255463, 0.30633455514907837, -0.15330466628074646, -0.06227264925837517, 0.12295544147491455, -0.0227610245347023, -0.25753769278526306, 0.24710685014724731, -0.030333250761032104, -0.08529882878065109, -0.22411517798900604, 0.025078099220991135, 0.21429648995399475, 0.03025251254439354, -0.03328174725174904, -0.06785447895526886, -0.026327520608901978, -0.11787818372249603, 0.037984102964401245, -0.021225906908512115, -0.04405677318572998, 0.02558494731783867, 0.05829640477895737, 0.034883543848991394, 0.08546258509159088, 0.12725120782852173, -0.15898093581199646, -0.1582951843738556, -0.009005535393953323, -0.03097008541226387, -0.05793878808617592, 0.2773635685443878, 0.08752785623073578, 0.2306988686323166, 0.10342966020107269, -0.1476125568151474, -0.02865523472428322, 0.1470760852098465, -0.2240748554468155, -0.0022883079946041107, 0.16620108485221863, 0.039761755615472794, -0.04165210202336311, 0.0024376511573791504, -0.04212356358766556, 0.45430055260658264, 0.14587292075157166, 0.02898876741528511, -0.17881838977336884, -0.03230356425046921, 0.028360411524772644, 0.1365956962108612, 0.25557979941368103, 0.11070096492767334, 0.06270860135555267, 0.1753891259431839, -0.156528502702713, -0.01207856833934784, 0.40026015043258667, 0.24580392241477966, 0.015280787833034992, -0.019128095358610153, 0.18733398616313934, 0.04430640488862991, 0.1493389904499054, -0.23924222588539124, -0.07659119367599487, -0.06441013514995575, -0.1844230741262436, -0.20356808602809906, -0.019788946956396103, -0.007934391498565674, -0.02998698130249977, 0.12258853763341904, -0.319424569606781, 0.082792729139328, -0.31249648332595825, -0.06142116338014603, 0.00634976290166378, 0.1786762923002243, 0.07991617172956467, 0.12736177444458008, -0.11784752458333969, 0.066451296210289, 0.14973501861095428, -0.08807966113090515, -0.05669066309928894, -0.097388356924057, 0.15968045592308044, 0.2522812485694885, -0.3431479036808014, -0.2164800614118576, 0.00225849449634552]}"
"{\"sha\": \"8490a88f377d8fed802e4f3b2d1d87a0d6cb81b2\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/sized/cc_array_sized.c\", \"func_name\": \"cc_array_sized_iter_init\", \"original_string\": \"void cc_array_sized_iter_init(CC_ArraySizedIter *iter, CC_ArraySized *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\", \"code_tokens\": [\"void\", \"cc_array_sized_iter_init\", \"(\", \"CC_ArraySizedIter\", \"*\", \"iter\", \",\", \"CC_ArraySized\", \"*\", \"ar\", \")\", \"{\", \"iter\", \"->\", \"ar\", \"=\", \"ar\", \";\", \"iter\", \"->\", \"index\", \"=\", \"0\", \";\", \"iter\", \"->\", \"last_removed\", \"=\", \"false\", \";\", \"}\"], \"docstring\": \"/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Initializes\", \"the\", \"iterator\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"iter\", \"the\", \"iterator\", \"that\", \"is\", \"being\", \"initialized\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"ar\", \"the\", \"array\", \"to\", \"iterate\", \"over\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2024 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n\\n#include \\\"sized/cc_array_sized.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\n#define INDEX(a, i) a->data_length * i\\n#define BUF_ADDR(a, i) &a->buffer[a->data_length * i]\\n\\n\\nstruct cc_array_sized_s {\\n    size_t   data_length;\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    uint8_t *buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[in] Size of the array element in bytes\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new(size_t element_size, CC_ArraySized **out)\\n{\\n    CC_ArraySizedConf c;\\n    cc_array_sized_conf_init(&c);\\n    return cc_array_sized_new_conf(element_size, &c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_ArraySized based on the specified CC_ArraySizedConf struct \\n * and returns a status code.\\n *\\n * The CC_ArraySized is allocated using the allocators specified in the CC_ArraySizedConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArraySizedConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] element_size the size of the data being stored in bytes\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new_conf(\\n    size_t element_size, \\n    CC_ArraySizedConf const * const conf, \\n    CC_ArraySized **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_ArraySized *ar = conf->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    uint8_t *buff = conf->mem_alloc(conf->capacity * element_size);\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->data_length = element_size;\\n    ar->buffer      = buff;\\n    ar->exp_factor  = ex;\\n    ar->capacity    = conf->capacity;\\n    ar->mem_alloc   = conf->mem_alloc;\\n    ar->mem_calloc  = conf->mem_calloc;\\n    ar->mem_free    = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArraySizedConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArraySizedConf structure that is being initialized\\n */\\nvoid cc_array_sized_conf_init(CC_ArraySizedConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_ArraySized structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_sized_destroy(CC_ArraySized *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n\\n/**\\n * Adds a new element to the CC_ArraySized. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_ArraySized.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add(CC_ArraySized *ar, uint8_t *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    memcpy(BUF_ADDR(ar, ar->size), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add_at(CC_ArraySized *ar, uint8_t *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_sized_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * ar->data_length;\\n\\n    memmove(BUF_ADDR(ar, (index + 1)),\\n            BUF_ADDR(ar, index),\\n            shift);\\n\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_ArraySized.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_replace_at(CC_ArraySized *ar, uint8_t *element, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n* Swaps the values at the specified indices.\\n*\\n* @param[in] ar array whose elements are being swapped\\n* @param[in] index1 first position\\n* @param[in] index2 second position\\n* \\n* @return CC_OK if the operation was successful, or CC_ERR_OUT_OF_RANGE if \\n* one of the indices was out of range.\\n*/\\nenum cc_stat cc_array_sized_swap_at(CC_ArraySized *ar, size_t index1, size_t index2)\\n{\\n    if (index1 >= ar->size || index2 >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n\\n    for (size_t i = 0; i < ar->data_length; i++) {\\n        uint8_t tmp = ar->buffer[INDEX(ar, index1 + i)];\\n        ar->buffer[INDEX(ar, index1 + i)] = ar->buffer[INDEX(ar, index2 + i)];\\n        ar->buffer[INDEX(ar, index2 + i)] = tmp;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_ArraySized if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_sized_remove(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_sized_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n \\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_remove_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_sized_remove_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    return cc_array_sized_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_sized_remove_all(CC_ArraySized *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Copies an CC_ArraySized element from the specified index to the out pointer.\\n * The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] source index of the array element\\n * @param[out] destination address\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_sized_get_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_sized_get_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n    return cc_array_sized_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n* Returns the pointer to the element at the specified index\\n*/\\nenum cc_stat cc_array_sized_peek(CC_ArraySized* ar, size_t index, uint8_t** out)\\n{\\n    if (index > ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    *out = BUF_ADDR(ar, index);\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst uint8_t * const* cc_array_sized_get_buffer(CC_ArraySized *ar)\\n{\\n    return (const uint8_t* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_ArraySized.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_sized_index_of(CC_ArraySized *ar, uint8_t *element, size_t *index)\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) { \\n            // Mismatching byte, skip to next block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            if (j == ar->data_length - 1) {\\n                *index = i;\\n                return CC_OK;\\n            }\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_ArraySized, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_ArraySized, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's allocators\\n *       and it also inherits the configuration of the original CC_ArraySized.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_sized_subarray(CC_ArraySized *ar, size_t b, size_t e, CC_ArraySized **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_ArraySized *sub_ar = ar->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * ar->data_length))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc   = ar->mem_alloc;\\n    sub_ar->mem_calloc  = ar->mem_calloc;\\n    sub_ar->mem_free    = ar->mem_free;\\n    sub_ar->size        = e - b + 1;\\n    sub_ar->capacity    = sub_ar->size;\\n    sub_ar->data_length = ar->data_length;\\n\\n    memcpy(sub_ar->buffer,\\n           BUF_ADDR(ar, b),\\n           sub_ar->size * ar->data_length);\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a copy of the specified CC_ArraySized. \\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's\\n *       allocators and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_sized_copy(CC_ArraySized *ar, CC_ArraySized **out)\\n{\\n    CC_ArraySized *copy = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->data_length = ar->data_length;\\n    copy->exp_factor  = ar->exp_factor;\\n    copy->size        = ar->size;\\n    copy->capacity    = ar->capacity;\\n    copy->mem_alloc   = ar->mem_alloc;\\n    copy->mem_calloc  = ar->mem_calloc;\\n    copy->mem_free    = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * ar->data_length);\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_ArraySized was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_ArraySized is empty.\\n */\\nenum cc_stat cc_array_sized_filter_mut(CC_ArraySized *ar, bool (*pred) (const uint8_t*))\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(BUF_ADDR(ar, i))) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * ar->data_length;\\n                memmove(BUF_ADDR(ar, (i + 1)),\\n                        BUF_ADDR(ar, (i + 1 + rm)),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * ar->data_length;\\n        memmove(BUF_ADDR(ar, 0),\\n                BUF_ADDR(ar, rm),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by creating a new CC_ArraySized that contains all elements\\n * from the original CC_ArraySized that return true on pred(element) without modifying \\n * the original CC_ArraySized.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_sized_filter(CC_ArraySized *ar, bool (*pred) (const uint8_t*), CC_ArraySized **out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    CC_ArraySized *filtered = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!filtered) {\\n        return CC_ERR_ALLOC;\\n    }\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->data_length = ar->data_length;\\n    filtered->exp_factor  = ar->exp_factor;\\n    filtered->size        = 0;\\n    filtered->capacity    = ar->capacity;\\n    filtered->mem_alloc   = ar->mem_alloc;\\n    filtered->mem_calloc  = ar->mem_calloc;\\n    filtered->mem_free    = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(BUF_ADDR(ar, i))) {\\n            memcpy(BUF_ADDR(filtered, f++), \\n                   BUF_ADDR(ar, i),\\n                   ar->data_length);\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_sized_reverse(CC_ArraySized *ar, uint8_t *tmp)\\n{\\n    if (ar->size == 0) {\\n        return;\\n    }\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        memcpy(tmp, BUF_ADDR(ar, i), ar->data_length);\\n        memcpy(BUF_ADDR(ar, i), BUF_ADDR(ar, j), ar->data_length);\\n        memcpy(BUF_ADDR(ar, j), tmp, ar->data_length);\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_ArraySized, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_sized_trim_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->size == ar->capacity) {\\n        return CC_OK;\\n    }\\n    uint8_t *new_buff = ar->mem_calloc(ar->size, ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * ar->data_length);\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_ArraySized.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_sized_contains(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t o = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) {\\n            // Mismatching byte, skip block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            // Last byte is equal, match found\\n            if (j == ar->data_length - 1) {\\n                o++;\\n            }\\n        }\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_ArraySized. The size of the array is the\\n * number of elements contained within the CC_ArraySized.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_ArraySized.\\n */\\nsize_t cc_array_sized_size(CC_ArraySized *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_ArraySized. The capacity of the CC_ArraySized is\\n * the maximum number of elements an CC_ArraySized can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_ArraySized.\\n */\\nsize_t cc_array_sized_capacity(CC_ArraySized *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sized_sort(CC_ArraySized *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, ar->data_length, cmp);\\n}\\n\\n/**\\n * Expands the CC_ArraySized capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS) {\\n        return CC_ERR_MAX_CAPACITY;\\n    }\\n\\n    size_t new_capacity = (size_t) (ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity) {\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    } else {\\n        ar->capacity = new_capacity;\\n    }\\n    uint8_t *new_buff = ar->mem_alloc(ar->capacity * ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    memcpy(new_buff, ar->buffer, ar->size * ar->data_length);\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_sized_map(CC_ArraySized *ar, void (*fn) (uint8_t *e))\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        fn(BUF_ADDR(ar, i));\\n    }\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_sized_reduce(CC_ArraySized *ar, void (*fn) (uint8_t*, uint8_t*, uint8_t*), uint8_t *result)\\n{\\n    if (ar->size == 1) {\\n        fn(BUF_ADDR(ar, 0), NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1) {\\n        fn(BUF_ADDR(ar, 0), BUF_ADDR(ar, 1), result);\\n    }\\n    for (size_t i = 2; i < ar->size; i++) {\\n        fn(result, BUF_ADDR(ar, i), result);\\n    }\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_sized_iter_init(CC_ArraySizedIter *iter, CC_ArraySized *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the reference of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_sized_iter_next(CC_ArraySizedIter *iter, uint8_t **out)\\n{\\n    if (iter->index >= iter->ar->size) {\\n        return CC_ITER_END;\\n    }\\n    *out = BUF_ADDR(iter->ar, iter->index);\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_sized_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_sized_iter_remove(CC_ArraySizedIter *iter, uint8_t *out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_sized_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK) {\\n            iter->last_removed = true;\\n        }\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_ArraySized after the last returned element by\\n * <code>cc_array_sized_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_iter_add(CC_ArraySizedIter *iter, uint8_t *element)\\n{\\n    return cc_array_sized_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_sized_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_iter_replace(CC_ArraySizedIter *iter, uint8_t *element, uint8_t *out)\\n{\\n    return cc_array_sized_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_sized_iter_index(CC_ArraySizedIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_sized_zip_iter_init(CC_ArraySizedZipIter *iter, CC_ArraySized *ar1, CC_ArraySized *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_sized_zip_iter_next(CC_ArraySizedZipIter *iter, uint8_t **out1, uint8_t **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size) {\\n        return CC_ITER_END;\\n    }\\n    *out1 = BUF_ADDR(iter->ar1, iter->index);\\n    *out2 = BUF_ADDR(iter->ar2, iter->index);\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_sized_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_remove(CC_ArraySizedZipIter *iter, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (!iter->last_removed) {\\n        cc_array_sized_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_sized_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_sized_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_sized_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_add(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_ArraySized  *ar1  = iter->ar1;\\n    CC_ArraySized  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n        (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK))) {\\n        return CC_ERR_ALLOC;\\n    }\\n    cc_array_sized_add_at(ar1, e1, index);\\n    cc_array_sized_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_zip_iter_replace(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    cc_array_sized_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_sized_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_sized_zip_iter_index(CC_ArraySizedZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_sized_struct_size()\\n{\\n    return sizeof(CC_ArraySized);\\n}\", \"embeddings\": [-0.025888890027999878, 0.05897556245326996, 0.04312824457883835, 0.15057995915412903, 0.21656082570552826, -0.1372252106666565, 0.059074074029922485, 0.3140525817871094, 0.01510709896683693, -0.2032148838043213, -0.011338979005813599, -0.13835427165031433, 0.006707610562443733, 0.10400837659835815, 0.01009272038936615, 0.04696326330304146, 0.06594192236661911, 0.005075186491012573, 0.07626029849052429, -0.1354171633720398, -0.18347233533859253, 0.07981599867343903, 0.197105273604393, 0.0943121463060379, 0.17410942912101746, -0.010039418935775757, 0.21111847460269928, 0.11401759088039398, 0.23752029240131378, -0.15377488732337952, -0.01511133462190628, -0.06539464741945267, 0.07925151288509369, -0.1513480842113495, 0.003996647894382477, 0.04850735515356064, 0.03858079016208649, 0.04806123673915863, 0.017959043383598328, 0.02130994014441967, -0.19929243624210358, -0.06645715981721878, 0.11848654597997665, 0.20920291543006897, 0.049903519451618195, 0.009923379868268967, -0.021207906305789948, 0.10926954448223114, -0.07324962317943573, 0.07229563593864441, 0.04683971405029297, 0.06198815628886223, -0.03745899349451065, -0.041841909289360046, -0.08515559136867523, 0.03782140836119652, -0.004456482827663422, 0.28891706466674805, 0.0377945750951767, -0.025491200387477875, -0.040907666087150574, -0.002271994948387146, -0.12047925591468811, 0.08580000698566437, 0.14712563157081604, 0.04682549461722374, -0.06714355945587158, -0.1570541262626648, -0.06868115067481995, -0.028790012001991272, 0.16307206451892853, 0.0672614797949791, 0.06648138165473938, -0.15663111209869385, -0.10907259583473206, -0.04963085800409317, 0.15218399465084076, 0.6279610395431519, -0.0740806981921196, 0.08877228200435638, 0.24079163372516632, -0.08155357837677002, 0.045222483575344086, 0.07282210886478424, 0.13464781641960144, -0.015143461525440216, -0.10332830995321274, 0.07961038500070572, 0.07866352051496506, 0.14076337218284607, 0.13710817694664001, 0.15754434466362, -0.04039795696735382, -0.042261164635419846, 0.034986987709999084, 0.004399627447128296, 0.07679972052574158, -0.38542887568473816, 0.05506254732608795, 0.26151272654533386, 0.055543530732393265, -0.050462257117033005, -0.184841126203537, -0.10858453810214996, -0.022181548178195953, -0.006742347031831741, 0.04511013254523277, 0.1136254072189331, 0.03288336098194122, -0.03759010136127472, 0.048704393208026886, 0.06338997930288315, 0.011865833774209023, 0.05254518985748291, 0.0586983896791935, -0.07587665319442749, 0.09035645425319672, -0.030615277588367462, 0.1496880054473877, -0.047592565417289734, 0.15243656933307648, -0.031431712210178375, -0.06406480818986893, -0.018007628619670868, 0.028286293148994446, 0.043659985065460205, 0.07029438763856888, -0.11008752137422562, 0.08327769488096237, 0.09396091848611832, -0.01885560154914856, -0.12985754013061523, 0.0002618357539176941, 0.1571703553199768, 0.1345607191324234, -0.035949867218732834, 0.0018717795610427856, 0.12655645608901978, 0.016793087124824524, 0.04885413497686386, -0.017878763377666473, 0.1268453150987625, 0.2486904114484787, 0.013965778052806854, 0.13964833319187164, -0.12337927520275116, 0.07998654246330261, 0.1152145117521286, -0.2851414382457733, -0.15503814816474915, -0.00969860702753067, -0.08567573875188828, -0.02505813166499138, 0.025199346244335175, -0.22188448905944824, 0.7905084490776062, 0.04080615192651749, -0.050131089985370636, -0.10072043538093567, -0.039792560040950775, 0.05682259052991867, -0.28224048018455505, -0.027114592492580414, 0.05336035415530205, 0.08114355057477951, 0.11440206319093704, 0.017568260431289673, 0.07442864775657654, 0.1712864488363266, 0.002275470644235611, 0.017145462334156036, -0.09366321563720703, -0.09745433181524277, 0.153589129447937, 0.07990937680006027, 0.011414047330617905, -0.15575742721557617, 0.08663880825042725, -0.09529754519462585, 0.07446500658988953, -0.06308791786432266, 0.025405269116163254, -0.16017864644527435, -0.013294592499732971, -0.02098030596971512, 0.04116903990507126, 0.02757863700389862, -0.1594807356595993, 0.10196489840745926, 0.02879296988248825, -0.05690518021583557, 0.08315441012382507, 0.1299012005329132, -0.04994615912437439, -0.05707695335149765, 0.04309700429439545, -0.12835174798965454, -0.051399193704128265, 0.1995733678340912, -0.03867354989051819, 0.036592770367860794, -0.13403911888599396, 0.2172393798828125, -0.009398408234119415, 0.19195517897605896, 0.12178698927164078, -0.11880222707986832, 0.0916893407702446, -0.053770970553159714, -0.07903634011745453, -0.05999337509274483, 0.15615206956863403, 0.05292341113090515, -0.0016044368967413902, -0.14563512802124023, -0.08641467988491058, 0.03806109353899956, 0.13752727210521698, 0.01907140575349331, -0.06912441551685333, 0.10343696922063828, 0.15106600522994995, -0.041927993297576904, -0.09596331417560577, -0.10623243451118469, 0.18891966342926025, 0.1888345330953598, 0.01409216970205307, 0.0037394054234027863, 0.0856156200170517, 0.1413082480430603, 0.19063036143779755, -0.12978416681289673, 0.14246459305286407, 0.020240142941474915, -0.23121552169322968, -0.0310385599732399, 0.02166225016117096, -0.047853581607341766, -0.16941072046756744, -0.08515967428684235, 0.12338656187057495, 0.11890164017677307, 0.2224782109260559, 0.041386257857084274, -0.06352248042821884, -0.14066751301288605, 0.054556842893362045, -0.08172773569822311, 0.020812444388866425, -0.06530643254518509, -0.08949990570545197, 0.035965610295534134, -0.04415096715092659, -0.16113169491291046, -0.07593722641468048, -0.12917539477348328, 0.0780210942029953, 0.05829396843910217, 0.1962825059890747, -0.02358168363571167, -0.08942025899887085, 0.04878492280840874, -0.08267594873905182, -0.03498469665646553, -0.479792058467865, -0.09058306366205215, 0.09224206209182739, 0.08767038583755493, -0.0407322533428669, 0.079936183989048, -0.07188597321510315, 0.20181697607040405, 0.16936683654785156, 0.05752735212445259, 0.017759598791599274, 0.0056488290429115295, -0.0002687796950340271, -0.10072443634271622, -0.032861970365047455, -0.06838642060756683, 0.05819126218557358, -0.1216571182012558, 0.08483225107192993, -0.015051902271807194, 0.024492330849170685, 0.047506071627140045, 0.007757272571325302, 0.06270578503608704, 0.08238744735717773, 0.03579872101545334, 0.01214318722486496, 0.11007224768400192, 0.1616085320711136, 0.05380404368042946, 0.07916422188282013, 0.22372591495513916, -0.12307457625865936, -0.03149862587451935, -0.2703794240951538, 0.05077696591615677, -0.16761605441570282, 0.05050690099596977, -0.06918612867593765, 0.35339194536209106, -0.11190237104892731, 0.018309712409973145, 0.028098944574594498, 0.29761803150177, -0.031185094267129898, 0.008207298815250397, 0.07945799082517624, -0.14542002975940704, 0.16127891838550568, -0.09787829220294952, -0.024846233427524567, -0.09415095299482346, -0.04708379879593849, 0.10670267045497894, 0.01428108662366867, -0.12677223980426788, 0.1203920841217041, 0.19567802548408508, 0.10302017629146576, -0.02650749683380127, 0.170684352517128, 0.14353233575820923, -0.0633755475282669, -0.08877088874578476, 0.6248738765716553, -0.48555272817611694, 0.17954760789871216, -0.1935354471206665, 0.32373046875, 0.000981643795967102, 0.23453134298324585, -0.03280697762966156, 0.053111497312784195, 0.11885946989059448, 0.11518613994121552, -0.12396080791950226, -0.04409406706690788, -0.055708423256874084, 0.23034754395484924, 0.07682575285434723, 0.12736377120018005, 0.1560559868812561, -0.056100714951753616, 0.08336623013019562, -0.016420572996139526, -0.14817260205745697, 0.1131630390882492, 0.04392537847161293, -0.10275446623563766, 0.11535097658634186, 0.28158774971961975, -0.06705927848815918, -0.09370964765548706, 0.07150641083717346, 0.07105687260627747, 0.1625640094280243, -0.13398981094360352, 0.1558380126953125, -0.02854681946337223, 0.28724831342697144, -0.323263943195343, -0.28487226366996765, 0.01889488846063614, -0.06422895193099976, 0.06163523346185684, 0.08791307359933853, 0.22057542204856873, 0.1655135303735733, -0.13216152787208557, 0.04474389925599098, -0.03557800129055977, -0.16663405299186707, 0.021245770156383514, -0.054072827100753784, 0.1492418646812439, 0.05137118697166443, 0.05314734950661659, 0.060946233570575714, 0.009919684380292892, 0.0877784788608551, -0.19104686379432678, 0.18169036507606506, 0.136778324842453, 0.2159571796655655, -0.10277299582958221, 0.07189609855413437, -0.15443232655525208, 0.10098971426486969, 0.024694308638572693, 0.024043984711170197, 0.0840912014245987, -0.08395130187273026, 0.09762130677700043, -0.09450779855251312, -0.075100839138031, 0.09841883182525635, 0.09600107371807098, -0.044557247310876846, 0.18050506711006165, 0.16792583465576172, 0.029578622430562973, 0.04077529162168503, -0.048473529517650604, -0.08171588182449341, -0.11748654395341873, 0.052328530699014664, 0.08101250231266022, 0.030724234879016876, 0.06198129802942276, 0.030774826183915138, -0.10596215724945068, 0.07448369264602661, -0.18232673406600952, -0.07178377360105515, 0.21853190660476685, 0.15125060081481934, 0.12767645716667175, -0.014297053217887878, -0.07795869559049606, -0.0432911217212677, -0.04815409705042839, -0.04919871687889099, -0.10043314099311829, 0.08484433591365814, -0.11060477793216705, 0.016248535364866257, 0.23546338081359863, 0.039409130811691284, 0.10445872694253922, 0.1332743614912033, -0.0905180424451828, -0.07723680138587952, -0.01617085188627243, -0.05761057883501053, 0.0754350945353508, -0.07101859152317047, 0.019523385912179947, 0.025585465133190155, 0.14282089471817017, -0.006725665181875229, -0.12536650896072388, 0.3408747613430023, 0.09332901984453201, -0.10050685703754425, 0.09510819613933563, -0.24545595049858093, 0.03545505180954933, -0.04974230006337166, -0.47032979130744934, 0.08063426613807678, 0.18801862001419067, 0.10818468034267426, 0.05044110491871834, 0.09970077872276306, 0.02006208524107933, -0.005089949816465378, 0.1181022971868515, 0.035455748438835144, -0.08769109100103378, -0.00010830163955688477, -0.07062386721372604, 0.1885610818862915, 0.07223203778266907, 0.12755918502807617, 0.08118759095668793, 0.0487884022295475, 0.21184873580932617, 0.01284985151141882, -0.1559872180223465, 0.03317736089229584, 0.059147413820028305, -0.022818386554718018, -0.13893070816993713, 0.10723855346441269, -0.16723303496837616, -0.06593818962574005, 0.08207438141107559, 0.14879095554351807, -0.0008060410618782043, -0.02965300716459751, -0.08344518393278122, 0.19987452030181885, 0.03217703476548195, -0.08632534742355347, -0.007019612938165665, -0.12748250365257263, 0.13250529766082764, 0.0001260899007320404, 0.1686529815196991, 0.26923036575317383, 0.13798540830612183, 0.134383887052536, 0.08779310435056686, 0.1867486834526062, -0.07034183293581009, 0.051592931151390076, 0.10801585018634796, 0.06530273705720901, -0.05590524896979332, -0.10650280117988586, -0.09015005826950073, -0.04057922214269638, 0.1246405765414238, 0.13474637269973755, -0.12908047437667847, -0.053880348801612854, 0.02736210823059082, 0.08259464055299759, -0.0014498457312583923, 0.04801115766167641, 0.05244755372405052, 0.04501138627529144, 0.05919158458709717, -0.01749555766582489, 0.21571311354637146, -0.12261193990707397, -0.1222316175699234, -0.04856446757912636, 0.024843735620379448, -0.03843823820352554, 0.04392871633172035, 0.09661704301834106, -0.03555038571357727, 0.06885334849357605, -0.04165259748697281, 0.03407103568315506, 0.05821456387639046, 0.04538636654615402, 0.12110517919063568, -0.09806571900844574, 0.042578618973493576, 0.09201270341873169, 0.03317814692854881, 0.18456295132637024, -0.1412939429283142, -0.05784359946846962, -0.1034340038895607, 0.1912948042154312, -0.05047916993498802, 0.15644867718219757, 0.003389861434698105, 0.18465471267700195, 0.03176604211330414, 0.004206288605928421, 0.07950012385845184, -0.20168599486351013, -0.9084393978118896, -0.024518627673387527, 0.14593279361724854, -0.12102721631526947, 0.06471116840839386, 0.12010069191455841, 0.0633293017745018, 0.10837401449680328, 0.13519856333732605, 0.007433870807290077, 0.018261108547449112, 0.15387704968452454, 0.18459738790988922, -0.1530817449092865, -0.05799392983317375, 0.10241453349590302, 0.09673922508955002, -0.20084579288959503, 0.1755332350730896, -0.09614793211221695, -0.11854594200849533, -0.014507696032524109, 0.08969110995531082, -0.000999636948108673, 0.05869675427675247, 0.21995078027248383, 0.024929044768214226, 0.16901612281799316, -0.00380513072013855, 0.056872185319662094, 0.20889912545681, 0.13613258302211761, -0.20878075063228607, 0.04711208492517471, 0.15131419897079468, 0.16332215070724487, 0.09944760054349899, 13.745203971862793, -0.10302527993917465, 0.15814214944839478, -0.1329439878463745, -0.06773772835731506, -0.013548661023378372, -0.0739610567688942, 0.09937746077775955, -0.018659278750419617, -0.03723718971014023, 0.06106090173125267, -0.02567991428077221, -0.014341138303279877, 0.05419035255908966, -0.004995070397853851, -0.09076118469238281, 0.008566189557313919, 0.013309776782989502, 0.11419209837913513, 0.0033814311027526855, -0.15936803817749023, -0.06976872682571411, 0.03264245390892029, -0.3315695524215698, -0.0009606496314518154, -0.1028907522559166, 0.09374671429395676, 0.053372614085674286, 0.03987651318311691, 0.051837287843227386, 0.20264387130737305, 0.10756448656320572, 0.13008178770542145, -0.010580919682979584, 0.0037392079830169678, -0.04806223139166832, -0.40021300315856934, -0.08972122520208359, 0.11164230108261108, -0.06561070680618286, -0.0170905739068985, 0.03082755208015442, 0.17814722657203674, -0.04267045110464096, 0.07082992792129517, 0.08481095731258392, -0.1444670408964157, 0.12798522412776947, -0.048820801079273224, -0.09455609321594238, 0.11334741860628128, 0.12395364046096802, 0.24902841448783875, 0.01588098518550396, -0.11510854214429855, -0.26047512888908386, 0.22729715704917908, 0.041607148945331573, -0.0049974024295806885, 0.26430702209472656, -0.00043354183435440063, -0.11138706654310226, -0.00036241859197616577, -0.05183092877268791, 0.030586037784814835, 0.012132465839385986, 0.12017502635717392, 0.10802695155143738, 0.0671876072883606, 0.07413243502378464, 0.1950143575668335, -0.15103916823863983, 0.10489924997091293, 0.03758415952324867, -0.000736970454454422, 0.08773557096719742, -0.03229861706495285, -0.016386229544878006, 0.08303394168615341, -0.08654463291168213, -0.014753863215446472, 0.0314859040081501, -0.11495684087276459, -0.13549357652664185, -0.18651272356510162, 0.1151166781783104, -0.07281360030174255, 0.19683653116226196, 0.15568843483924866, 0.05179174244403839, -0.11111388355493546, 0.09594959765672684, -0.04636313021183014, -0.055635206401348114, 0.16397635638713837, -0.06611228734254837, 0.00772310234606266, -0.14445485174655914, 0.06154929846525192, 0.06087713688611984, -0.1115930899977684, -0.08583362400531769, -0.04403059929609299, 0.02287788689136505, -0.06191520392894745, 0.018484733998775482, -0.029621746391057968, 0.06676597893238068, -0.006970580667257309, 0.04690767079591751, 0.0776766836643219, 0.15174192190170288, 0.07624723017215729, -0.15978297591209412, -0.07153967767953873, 0.029701415449380875, 0.048984844237565994, -0.04287843778729439, 0.21712203323841095, -0.009670663625001907, 0.14097999036312103, 0.01227283850312233, -0.13881099224090576, -0.06089046224951744, 0.09791378676891327, -0.16263264417648315, -0.043614085763692856, 0.16732551157474518, 0.07006460428237915, 0.005205739289522171, 0.09371068328619003, -0.05607672780752182, 0.33611422777175903, 0.12959857285022736, 0.005159631371498108, 0.07488852739334106, -0.02439044415950775, 0.06500706821680069, 0.08697617053985596, 0.1914590299129486, -0.002987165004014969, -0.034637682139873505, 0.15755018591880798, -0.1635158210992813, -0.0935063511133194, 0.21006101369857788, 0.17526495456695557, -0.01708902046084404, -0.045275796204805374, 0.1768195629119873, 0.13548432290554047, 0.19659730792045593, -0.0308831874281168, -0.11351345479488373, -0.11193689703941345, -0.15289606153964996, -0.11617401242256165, 0.012288428843021393, -0.007408946752548218, -0.07705048471689224, 0.2092413604259491, -0.44807884097099304, 0.046022459864616394, -0.18766073882579803, -0.09465989470481873, 0.04642519727349281, 0.090940460562706, 0.06948380917310715, 0.11424971371889114, -0.13436761498451233, 0.07000313699245453, 0.07338067144155502, -0.18555650115013123, 0.0011719726026058197, -0.006315387785434723, 0.0858946219086647, 0.21607902646064758, -0.3890279531478882, -0.15596234798431396, 0.05200665444135666]}"
"{\"sha\": \"8490a88f377d8fed802e4f3b2d1d87a0d6cb81b2\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/sized/cc_array_sized.c\", \"func_name\": \"cc_array_sized_iter_next\", \"original_string\": \"enum cc_stat cc_array_sized_iter_next(CC_ArraySizedIter *iter, uint8_t **out)\\n{\\n    if (iter->index >= iter->ar->size) {\\n        return CC_ITER_END;\\n    }\\n    *out = BUF_ADDR(iter->ar, iter->index);\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\", \"code_tokens\": [\"enum\", \"cc_stat\", \"cc_array_sized_iter_next\", \"(\", \"CC_ArraySizedIter\", \"*\", \"iter\", \",\", \"uint8_t\", \"*\", \"*\", \"out\", \")\", \"{\", \"if\", \"(\", \"iter\", \"->\", \"index\", \">=\", \"iter\", \"->\", \"ar\", \"->\", \"size\", \")\", \"{\", \"return\", \"CC_ITER_END\", \";\", \"}\", \"*\", \"out\", \"=\", \"BUF_ADDR\", \"(\", \"iter\", \"->\", \"ar\", \",\", \"iter\", \"->\", \"index\", \")\", \";\", \"iter\", \"->\", \"index\", \"++\", \";\", \"iter\", \"->\", \"last_removed\", \"=\", \"false\", \";\", \"return\", \"CC_OK\", \";\", \"}\"], \"docstring\": \"/**\\n * Advances the iterator and sets the out parameter to the reference of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Advances\", \"the\", \"iterator\", \"and\", \"sets\", \"the\", \"out\", \"parameter\", \"to\", \"the\", \"reference\", \"of\", \"the\", \"*\", \"next\", \"element\", \"in\", \"the\", \"sequence\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"iter\", \"the\", \"iterator\", \"that\", \"is\", \"being\", \"advanced\", \"*\", \"@param\", \"[\", \"out\", \"]\", \"out\", \"pointer\", \"to\", \"where\", \"the\", \"next\", \"element\", \"is\", \"set\", \"*\", \"*\", \"@return\", \"CC_OK\", \"if\", \"the\", \"iterator\", \"was\", \"advanced\", \"or\", \"CC_ITER_END\", \"if\", \"the\", \"*\", \"end\", \"of\", \"the\", \"CC_Array\", \"has\", \"been\", \"reached\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2024 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n\\n#include \\\"sized/cc_array_sized.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\n#define INDEX(a, i) a->data_length * i\\n#define BUF_ADDR(a, i) &a->buffer[a->data_length * i]\\n\\n\\nstruct cc_array_sized_s {\\n    size_t   data_length;\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    uint8_t *buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[in] Size of the array element in bytes\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new(size_t element_size, CC_ArraySized **out)\\n{\\n    CC_ArraySizedConf c;\\n    cc_array_sized_conf_init(&c);\\n    return cc_array_sized_new_conf(element_size, &c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_ArraySized based on the specified CC_ArraySizedConf struct \\n * and returns a status code.\\n *\\n * The CC_ArraySized is allocated using the allocators specified in the CC_ArraySizedConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArraySizedConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] element_size the size of the data being stored in bytes\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new_conf(\\n    size_t element_size, \\n    CC_ArraySizedConf const * const conf, \\n    CC_ArraySized **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_ArraySized *ar = conf->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    uint8_t *buff = conf->mem_alloc(conf->capacity * element_size);\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->data_length = element_size;\\n    ar->buffer      = buff;\\n    ar->exp_factor  = ex;\\n    ar->capacity    = conf->capacity;\\n    ar->mem_alloc   = conf->mem_alloc;\\n    ar->mem_calloc  = conf->mem_calloc;\\n    ar->mem_free    = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArraySizedConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArraySizedConf structure that is being initialized\\n */\\nvoid cc_array_sized_conf_init(CC_ArraySizedConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_ArraySized structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_sized_destroy(CC_ArraySized *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n\\n/**\\n * Adds a new element to the CC_ArraySized. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_ArraySized.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add(CC_ArraySized *ar, uint8_t *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    memcpy(BUF_ADDR(ar, ar->size), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add_at(CC_ArraySized *ar, uint8_t *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_sized_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * ar->data_length;\\n\\n    memmove(BUF_ADDR(ar, (index + 1)),\\n            BUF_ADDR(ar, index),\\n            shift);\\n\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_ArraySized.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_replace_at(CC_ArraySized *ar, uint8_t *element, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n* Swaps the values at the specified indices.\\n*\\n* @param[in] ar array whose elements are being swapped\\n* @param[in] index1 first position\\n* @param[in] index2 second position\\n* \\n* @return CC_OK if the operation was successful, or CC_ERR_OUT_OF_RANGE if \\n* one of the indices was out of range.\\n*/\\nenum cc_stat cc_array_sized_swap_at(CC_ArraySized *ar, size_t index1, size_t index2)\\n{\\n    if (index1 >= ar->size || index2 >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n\\n    for (size_t i = 0; i < ar->data_length; i++) {\\n        uint8_t tmp = ar->buffer[INDEX(ar, index1 + i)];\\n        ar->buffer[INDEX(ar, index1 + i)] = ar->buffer[INDEX(ar, index2 + i)];\\n        ar->buffer[INDEX(ar, index2 + i)] = tmp;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_ArraySized if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_sized_remove(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_sized_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n \\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_remove_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_sized_remove_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    return cc_array_sized_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_sized_remove_all(CC_ArraySized *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Copies an CC_ArraySized element from the specified index to the out pointer.\\n * The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] source index of the array element\\n * @param[out] destination address\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_sized_get_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_sized_get_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n    return cc_array_sized_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n* Returns the pointer to the element at the specified index\\n*/\\nenum cc_stat cc_array_sized_peek(CC_ArraySized* ar, size_t index, uint8_t** out)\\n{\\n    if (index > ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    *out = BUF_ADDR(ar, index);\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst uint8_t * const* cc_array_sized_get_buffer(CC_ArraySized *ar)\\n{\\n    return (const uint8_t* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_ArraySized.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_sized_index_of(CC_ArraySized *ar, uint8_t *element, size_t *index)\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) { \\n            // Mismatching byte, skip to next block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            if (j == ar->data_length - 1) {\\n                *index = i;\\n                return CC_OK;\\n            }\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_ArraySized, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_ArraySized, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's allocators\\n *       and it also inherits the configuration of the original CC_ArraySized.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_sized_subarray(CC_ArraySized *ar, size_t b, size_t e, CC_ArraySized **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_ArraySized *sub_ar = ar->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * ar->data_length))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc   = ar->mem_alloc;\\n    sub_ar->mem_calloc  = ar->mem_calloc;\\n    sub_ar->mem_free    = ar->mem_free;\\n    sub_ar->size        = e - b + 1;\\n    sub_ar->capacity    = sub_ar->size;\\n    sub_ar->data_length = ar->data_length;\\n\\n    memcpy(sub_ar->buffer,\\n           BUF_ADDR(ar, b),\\n           sub_ar->size * ar->data_length);\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a copy of the specified CC_ArraySized. \\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's\\n *       allocators and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_sized_copy(CC_ArraySized *ar, CC_ArraySized **out)\\n{\\n    CC_ArraySized *copy = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->data_length = ar->data_length;\\n    copy->exp_factor  = ar->exp_factor;\\n    copy->size        = ar->size;\\n    copy->capacity    = ar->capacity;\\n    copy->mem_alloc   = ar->mem_alloc;\\n    copy->mem_calloc  = ar->mem_calloc;\\n    copy->mem_free    = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * ar->data_length);\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_ArraySized was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_ArraySized is empty.\\n */\\nenum cc_stat cc_array_sized_filter_mut(CC_ArraySized *ar, bool (*pred) (const uint8_t*))\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(BUF_ADDR(ar, i))) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * ar->data_length;\\n                memmove(BUF_ADDR(ar, (i + 1)),\\n                        BUF_ADDR(ar, (i + 1 + rm)),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * ar->data_length;\\n        memmove(BUF_ADDR(ar, 0),\\n                BUF_ADDR(ar, rm),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by creating a new CC_ArraySized that contains all elements\\n * from the original CC_ArraySized that return true on pred(element) without modifying \\n * the original CC_ArraySized.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_sized_filter(CC_ArraySized *ar, bool (*pred) (const uint8_t*), CC_ArraySized **out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    CC_ArraySized *filtered = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!filtered) {\\n        return CC_ERR_ALLOC;\\n    }\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->data_length = ar->data_length;\\n    filtered->exp_factor  = ar->exp_factor;\\n    filtered->size        = 0;\\n    filtered->capacity    = ar->capacity;\\n    filtered->mem_alloc   = ar->mem_alloc;\\n    filtered->mem_calloc  = ar->mem_calloc;\\n    filtered->mem_free    = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(BUF_ADDR(ar, i))) {\\n            memcpy(BUF_ADDR(filtered, f++), \\n                   BUF_ADDR(ar, i),\\n                   ar->data_length);\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_sized_reverse(CC_ArraySized *ar, uint8_t *tmp)\\n{\\n    if (ar->size == 0) {\\n        return;\\n    }\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        memcpy(tmp, BUF_ADDR(ar, i), ar->data_length);\\n        memcpy(BUF_ADDR(ar, i), BUF_ADDR(ar, j), ar->data_length);\\n        memcpy(BUF_ADDR(ar, j), tmp, ar->data_length);\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_ArraySized, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_sized_trim_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->size == ar->capacity) {\\n        return CC_OK;\\n    }\\n    uint8_t *new_buff = ar->mem_calloc(ar->size, ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * ar->data_length);\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_ArraySized.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_sized_contains(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t o = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) {\\n            // Mismatching byte, skip block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            // Last byte is equal, match found\\n            if (j == ar->data_length - 1) {\\n                o++;\\n            }\\n        }\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_ArraySized. The size of the array is the\\n * number of elements contained within the CC_ArraySized.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_ArraySized.\\n */\\nsize_t cc_array_sized_size(CC_ArraySized *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_ArraySized. The capacity of the CC_ArraySized is\\n * the maximum number of elements an CC_ArraySized can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_ArraySized.\\n */\\nsize_t cc_array_sized_capacity(CC_ArraySized *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sized_sort(CC_ArraySized *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, ar->data_length, cmp);\\n}\\n\\n/**\\n * Expands the CC_ArraySized capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS) {\\n        return CC_ERR_MAX_CAPACITY;\\n    }\\n\\n    size_t new_capacity = (size_t) (ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity) {\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    } else {\\n        ar->capacity = new_capacity;\\n    }\\n    uint8_t *new_buff = ar->mem_alloc(ar->capacity * ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    memcpy(new_buff, ar->buffer, ar->size * ar->data_length);\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_sized_map(CC_ArraySized *ar, void (*fn) (uint8_t *e))\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        fn(BUF_ADDR(ar, i));\\n    }\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_sized_reduce(CC_ArraySized *ar, void (*fn) (uint8_t*, uint8_t*, uint8_t*), uint8_t *result)\\n{\\n    if (ar->size == 1) {\\n        fn(BUF_ADDR(ar, 0), NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1) {\\n        fn(BUF_ADDR(ar, 0), BUF_ADDR(ar, 1), result);\\n    }\\n    for (size_t i = 2; i < ar->size; i++) {\\n        fn(result, BUF_ADDR(ar, i), result);\\n    }\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_sized_iter_init(CC_ArraySizedIter *iter, CC_ArraySized *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the reference of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_sized_iter_next(CC_ArraySizedIter *iter, uint8_t **out)\\n{\\n    if (iter->index >= iter->ar->size) {\\n        return CC_ITER_END;\\n    }\\n    *out = BUF_ADDR(iter->ar, iter->index);\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_sized_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_sized_iter_remove(CC_ArraySizedIter *iter, uint8_t *out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_sized_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK) {\\n            iter->last_removed = true;\\n        }\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_ArraySized after the last returned element by\\n * <code>cc_array_sized_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_iter_add(CC_ArraySizedIter *iter, uint8_t *element)\\n{\\n    return cc_array_sized_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_sized_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_iter_replace(CC_ArraySizedIter *iter, uint8_t *element, uint8_t *out)\\n{\\n    return cc_array_sized_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_sized_iter_index(CC_ArraySizedIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_sized_zip_iter_init(CC_ArraySizedZipIter *iter, CC_ArraySized *ar1, CC_ArraySized *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_sized_zip_iter_next(CC_ArraySizedZipIter *iter, uint8_t **out1, uint8_t **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size) {\\n        return CC_ITER_END;\\n    }\\n    *out1 = BUF_ADDR(iter->ar1, iter->index);\\n    *out2 = BUF_ADDR(iter->ar2, iter->index);\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_sized_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_remove(CC_ArraySizedZipIter *iter, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (!iter->last_removed) {\\n        cc_array_sized_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_sized_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_sized_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_sized_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_add(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_ArraySized  *ar1  = iter->ar1;\\n    CC_ArraySized  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n        (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK))) {\\n        return CC_ERR_ALLOC;\\n    }\\n    cc_array_sized_add_at(ar1, e1, index);\\n    cc_array_sized_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_zip_iter_replace(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    cc_array_sized_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_sized_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_sized_zip_iter_index(CC_ArraySizedZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_sized_struct_size()\\n{\\n    return sizeof(CC_ArraySized);\\n}\", \"embeddings\": [-0.0005662217736244202, 0.03523799031972885, 0.03456360474228859, 0.12230284512042999, 0.31656384468078613, -0.1574583798646927, 0.09803400188684464, 0.34592458605766296, 0.04047420993447304, -0.27348190546035767, -0.0034715458750724792, -0.13244101405143738, 0.013054134324193, 0.019406944513320923, -0.029247522354125977, 0.007810115814208984, 0.1116148978471756, -0.023002900183200836, 0.04842215031385422, -0.293401837348938, -0.17621299624443054, 0.1236678883433342, 0.20212812721729279, 0.1164405345916748, 0.23868097364902496, 0.0901394933462143, 0.21346569061279297, 0.10543781518936157, 0.3021548390388489, -0.20012567937374115, 0.004497118294239044, -0.09449256211519241, 0.08723925054073334, -0.17656999826431274, 0.04956495389342308, 0.032909899950027466, 0.021803367882966995, 0.0643470361828804, -0.03463461622595787, 0.017973322421312332, -0.18416400253772736, -0.03720617666840553, 0.08492306619882584, 0.16552108526229858, 0.05936900153756142, -0.003480374813079834, 0.05392957478761673, 0.16052816808223724, -0.07235530018806458, 0.03672141209244728, 0.08342236280441284, -0.05532863363623619, -0.024122880771756172, -0.03149297833442688, -0.06706805527210236, 0.008907563984394073, -0.011165650561451912, 0.35067570209503174, 0.03620760887861252, 0.0008151829242706299, -0.027648411691188812, -0.04935427010059357, -0.17048104107379913, 0.16274623572826385, 0.13331538438796997, 0.013575486838817596, -0.08341376483440399, -0.2857668399810791, -0.02035454660654068, -0.05469564348459244, 0.14877621829509735, 0.02408732660114765, 0.08503890037536621, -0.17770640552043915, -0.15662194788455963, -0.0831523984670639, 0.06456181406974792, 0.5695427656173706, -0.010116757825016975, 0.1642667055130005, 0.22175376117229462, -0.09253473579883575, 0.05547647178173065, 0.1710815727710724, 0.17879575490951538, -0.0019138865172863007, -0.11500438302755356, 0.10449586808681488, -0.0064797960221767426, 0.1765213906764984, 0.0757201611995697, 0.21239621937274933, -0.0743219181895256, -0.08344161510467529, -0.0017320215702056885, 0.018931221216917038, 0.08989211916923523, -0.2181011438369751, 0.07236223667860031, 0.3414451479911804, 0.0027764514088630676, -0.06165925785899162, -0.27167874574661255, -0.08806249499320984, -0.03559240698814392, 0.055835314095020294, -0.025764010846614838, 0.06781037896871567, 0.05981501191854477, -0.06996158510446548, 0.10263748466968536, 0.0016832277178764343, -0.0012314971536397934, 0.04686756432056427, 0.042257074266672134, -0.07269584387540817, 0.10102958232164383, -0.04513843357563019, 0.16697722673416138, -0.12494102865457535, 0.18062356114387512, 0.016177169978618622, 0.01186099648475647, -0.10032650828361511, -0.11028146743774414, 0.06477126479148865, 0.03154376149177551, -0.21953561902046204, 0.10624389350414276, 0.07396155595779419, -0.0308525487780571, -0.1105160340666771, 0.0034581348299980164, 0.019784003496170044, 0.13689959049224854, 0.008539505302906036, 0.08560819178819656, 0.020449433475732803, 0.03294119983911514, -0.003015577793121338, -0.002394728362560272, 0.0723576545715332, 0.22939042747020721, 0.01731584221124649, 0.16067937016487122, -0.19467389583587646, 0.14629262685775757, 0.15121452510356903, -0.29769474267959595, -0.24323514103889465, 0.016059957444667816, -0.12350211292505264, -0.012781761586666107, 0.0043209008872509, -0.16149887442588806, 0.8102619051933289, 0.10246869921684265, -0.09170695394277573, -0.07947847247123718, -0.039094649255275726, 0.052396975457668304, -0.28219521045684814, -0.1007528007030487, 0.13137906789779663, 0.02129586786031723, 0.11137854307889938, 0.07877340167760849, 0.08638487756252289, 0.15244030952453613, 0.0608183816075325, 0.07877476513385773, -0.09874394536018372, -0.06043136119842529, 0.1700354516506195, 0.06658535450696945, -0.07637157291173935, -0.17382514476776123, 0.06482468545436859, -0.0559823215007782, 0.03665199130773544, -0.1410386562347412, 0.011213220655918121, -0.1898391991853714, -0.02486681193113327, -0.060656897723674774, 0.0152202807366848, 0.023311085999011993, -0.10294845700263977, 0.07210330665111542, 0.03272317349910736, -0.0022681690752506256, 0.04131411761045456, 0.1399536430835724, -0.0695572942495346, -0.05842708796262741, 0.014415718615055084, -0.09518855065107346, -0.04811316728591919, 0.22611215710639954, -0.059574052691459656, 0.032130248844623566, -0.11151041090488434, 0.2496260553598404, -0.08038429915904999, 0.1502690613269806, 0.14467570185661316, -0.19032514095306396, 0.0003884807229042053, -4.410743713378906e-06, -0.08094809949398041, -0.07947228848934174, 0.16018790006637573, 0.03745322674512863, -0.004302644170820713, -0.11934725940227509, -0.07497726380825043, 0.07935629785060883, 0.15047301352024078, 0.040856413543224335, -0.0814858004450798, 0.08481518924236298, 0.20470449328422546, -0.06779338419437408, -0.09216326475143433, -0.14496539533138275, 0.20113489031791687, 0.1776265949010849, 0.060577794909477234, -0.03700544685125351, 0.11191846430301666, 0.1484033763408661, 0.2744543254375458, -0.23142828047275543, 0.13109377026557922, 0.03128570318222046, -0.22478842735290527, -0.047857075929641724, 0.0544959232211113, -0.01576564460992813, -0.13578344881534576, -0.06623513251543045, 0.16522207856178284, 0.17754478752613068, 0.2932812571525574, 0.02959298901259899, 0.016563132405281067, -0.13518069684505463, 0.08933314681053162, -0.09883502125740051, 0.08205830305814743, -0.03303447365760803, 0.024558067321777344, 0.010601039975881577, -0.12660656869411469, -0.15428587794303894, -0.07885012030601501, -0.1651935875415802, 0.012502629309892654, 0.11765460669994354, 0.24096927046775818, -0.01647629588842392, -0.07808597385883331, 0.05253566801548004, -0.01530332863330841, -0.07250641286373138, -0.4093888998031616, -0.04951084405183792, 0.10372617840766907, 0.061482131481170654, -0.032305069267749786, 0.0678686872124672, -0.0846032127737999, 0.2010236382484436, 0.14253902435302734, 0.05782417207956314, 0.018078826367855072, -0.011085803620517254, 0.03457847982645035, -0.13425107300281525, -0.0032298043370246887, -0.049272965639829636, 0.02441747486591339, -0.12210793048143387, 0.12330795079469681, 0.0951886773109436, -0.0423172228038311, 0.12054238468408585, -0.012495467439293861, 0.05289396643638611, 0.05982295051217079, 0.024554098024964333, 0.04546721279621124, 0.18512113392353058, 0.11185845732688904, 0.05198780819773674, 0.11319129168987274, 0.20805621147155762, -0.11359354853630066, 0.013601340353488922, -0.31690847873687744, 0.08209098130464554, -0.2527323067188263, 0.06244700029492378, -0.020245380699634552, 0.4072381854057312, -0.006994595751166344, 0.002023175358772278, 0.030970871448516846, 0.300235390663147, 0.07757927477359772, 0.06304818391799927, 0.09980438649654388, -0.16896750032901764, 0.1423427015542984, -0.15919041633605957, 0.028737086802721024, -0.05625521391630173, -0.081277996301651, 0.1034984365105629, 0.015137650072574615, -0.04054271802306175, 0.1051669716835022, 0.2162572145462036, 0.12811388075351715, 0.027306117117404938, 0.11063764244318008, 0.1176043152809143, -0.06129194796085358, -0.1746889054775238, 0.6438202261924744, -0.5569188594818115, 0.22869130969047546, -0.20380759239196777, 0.37142109870910645, -0.054746001958847046, 0.3054623007774353, -0.04996873438358307, 0.10921214520931244, 0.12379879504442215, 0.1302093267440796, -0.16713431477546692, -0.08369487524032593, -0.10190556943416595, 0.2970234751701355, 0.14955808222293854, 0.11687955260276794, 0.2412066012620926, 0.005091488361358643, 0.14615988731384277, -0.05478982999920845, -0.15467171370983124, 0.13677112758159637, 0.01697266846895218, -0.11255041509866714, 0.11007121205329895, 0.3300313651561737, -0.12103275209665298, -0.08554060757160187, 0.035439711064100266, 0.04192957654595375, 0.17903804779052734, -0.17960059642791748, 0.166107177734375, -0.10706018656492233, 0.32819217443466187, -0.4096325635910034, -0.33300334215164185, 0.06042070314288139, -0.11830607056617737, 0.11355966329574585, 0.11128250509500504, 0.2394048571586609, 0.19897432625293732, -0.22461216151714325, 0.07626835256814957, -0.046047162264585495, -0.10314945876598358, -0.013300545513629913, 0.0036591440439224243, 0.130896657705307, 0.08645418286323547, 0.04345139488577843, 0.05941275507211685, 0.01888386346399784, 0.045568011701107025, -0.1604679524898529, 0.2198178917169571, 0.15999335050582886, 0.2796477675437927, -0.10721984505653381, 0.07199609279632568, -0.2031841278076172, 0.12269604206085205, -0.04281553998589516, 0.06070359796285629, 0.04095154255628586, -0.04036492854356766, 0.08055607974529266, -0.12516838312149048, -0.08430373668670654, 0.16050362586975098, 0.24563023447990417, -0.07542595267295837, 0.14859488606452942, 0.10409294813871384, 0.08158533275127411, 0.07226404547691345, -0.1071256697177887, -0.15946143865585327, -0.1544990837574005, 0.09334300458431244, 0.05371079593896866, 0.04184603691101074, 0.0597214438021183, 0.1651185154914856, -0.13837307691574097, 0.019600629806518555, -0.30900734663009644, -0.06417164951562881, 0.16991986334323883, 0.15992431342601776, 0.10173889994621277, -0.005263090133666992, -0.1674107015132904, -0.02943292260169983, -0.03840037062764168, -0.04847852885723114, -0.10233311355113983, 0.09437838196754456, -0.18108215928077698, 0.025378212332725525, 0.23778054118156433, 0.0811024159193039, 0.09642325341701508, 0.1498076319694519, -0.06471382826566696, -0.11024782061576843, 0.029434286057949066, -0.0012368429452180862, 0.033460140228271484, -0.09733428061008453, 0.02423091232776642, 0.06176438182592392, 0.15662597119808197, -0.013490268960595131, -0.07532913237810135, 0.3675696551799774, 0.11988279223442078, -0.1260797530412674, 0.06018412858247757, -0.18879571557044983, 0.008266635239124298, -0.050183337181806564, -0.3850703537464142, 0.12202827632427216, 0.2159586101770401, 0.07432201504707336, 0.03135356307029724, 0.11569435149431229, 0.05882296711206436, 0.017620671540498734, 0.05770460516214371, -0.05697185918688774, -0.13577240705490112, 0.03910282254219055, -0.0823177769780159, 0.1311255544424057, 0.015095165930688381, 0.21295295655727386, 0.11180510371923447, 0.06293384730815887, 0.18333235383033752, 0.032218169420957565, -0.12440192699432373, 0.036396387964487076, -0.010280415415763855, -0.021982412785291672, -0.1912766396999359, 0.0859467163681984, -0.11364958435297012, -0.04512077942490578, 0.12166061252355576, 0.16091030836105347, 0.014307349920272827, -0.012106673792004585, -0.14731410145759583, 0.2187134474515915, 0.08799966424703598, -0.10999763011932373, 0.01461152732372284, -0.0774402767419815, 0.13819444179534912, 0.05117250978946686, 0.16366615891456604, 0.2645604610443115, 0.17340540885925293, 0.07774040102958679, 0.11279354244470596, 0.3096919655799866, -0.1093902736902237, 0.03340321034193039, 0.0704672634601593, 0.04960089921951294, -0.10963501036167145, -0.12687760591506958, -0.09272641688585281, -0.03494758903980255, 0.0908576101064682, 0.1440628170967102, -0.15344944596290588, -0.031210221350193024, -0.05062592774629593, 0.17058072984218597, -0.03981718420982361, 0.044986430555582047, 0.07131056487560272, -0.014618948101997375, 0.027068182826042175, -0.07734961807727814, 0.24262139201164246, -0.14318202435970306, -0.10052327811717987, -0.08931896090507507, 0.03119136206805706, -0.07675428688526154, 0.07340708374977112, 0.09263522922992706, 0.005064606666564941, 0.08089276403188705, 0.01984294503927231, -0.054825492203235626, 0.06375624239444733, 0.10146495699882507, 0.18653979897499084, -0.13244299590587616, 0.04202770069241524, 0.11781442165374756, 0.09417859464883804, 0.2402014583349228, -0.09047182649374008, -0.1902785450220108, -0.12346918135881424, 0.20062494277954102, -0.08523416519165039, 0.22380682826042175, -0.00581146776676178, 0.142291858792305, 0.07278751581907272, -0.04556543380022049, 0.017111562192440033, -0.1344708353281021, -0.8024651408195496, -0.06372493505477905, 0.13974112272262573, -0.032645221799612045, 0.06753774732351303, 0.11897672712802887, 0.09581390023231506, 0.08492249250411987, 0.08639846742153168, 0.07784050703048706, -0.01713036745786667, 0.17392879724502563, 0.18338456749916077, -0.10229317843914032, -0.1513311266899109, 0.09923398494720459, 0.11736005544662476, -0.22162847220897675, 0.20845970511436462, -0.02405071258544922, -0.14834025502204895, 0.05034191161394119, 0.2537239193916321, -0.08777789026498795, 0.06527980417013168, 0.22656473517417908, 0.1034749448299408, 0.22753994166851044, -0.04001322388648987, 0.04603852331638336, 0.2612428367137909, 0.17519469559192657, -0.2940102219581604, 0.004921693354845047, 0.12153138220310211, 0.16517092287540436, 0.08500035852193832, 13.862284660339355, -0.06918355822563171, 0.2162264883518219, -0.1486433744430542, -0.07986124604940414, -0.06158878654241562, -0.07093250006437302, 0.06760665774345398, -0.02212025225162506, -0.020166069269180298, 0.09157226234674454, -0.07825382053852081, -0.010845055803656578, 0.03891026973724365, -0.07740506529808044, -0.019797474145889282, -0.05002716928720474, -0.11876657605171204, 0.12817350029945374, 0.025075986981391907, -0.19489893317222595, -0.09140761196613312, -0.03586919605731964, -0.3938003182411194, -0.025467589497566223, -0.10797687619924545, 0.13729675114154816, 0.0031663700938224792, 0.02653580531477928, 0.0776921957731247, 0.20963287353515625, 0.0924575999379158, 0.14130699634552002, -0.04941074550151825, 0.06088591367006302, -0.021771974861621857, -0.4218676686286926, -0.13505686819553375, 0.09146624058485031, -0.00867924839258194, 0.0020896345376968384, 0.020525600761175156, 0.17335215210914612, -0.08227718621492386, 0.10951612889766693, 0.10891428589820862, -0.2168886363506317, 0.12955302000045776, -0.10939650982618332, -0.07995465397834778, 0.19233264029026031, 0.11589090526103973, 0.28116869926452637, 0.020884137600660324, -0.11558499187231064, -0.24103668332099915, 0.2760498523712158, -0.005958385765552521, -0.058836549520492554, 0.3482128083705902, 0.0014798417687416077, -0.0860183909535408, -0.05034777894616127, 0.015095179900527, -0.04982656612992287, 0.033043719828128815, 0.08027248829603195, 0.09665561467409134, -0.14559568464756012, 0.09873447567224503, 0.20965197682380676, -0.18053533136844635, 0.14333182573318481, -0.028689071536064148, 0.005952905863523483, 0.08965598046779633, 0.06895070523023605, -0.04247952625155449, 0.0724145770072937, -0.0752144604921341, -0.019430011510849, 0.08539779484272003, -0.17190507054328918, -0.12007347494363785, -0.30728137493133545, 0.08501400053501129, -0.10008974373340607, 0.2102806568145752, 0.21908912062644958, -0.023981556296348572, -0.03628040850162506, 0.08703210949897766, -0.04074445366859436, -0.14373084902763367, 0.22036638855934143, -0.03172992914915085, -0.07999579608440399, -0.14759881794452667, 0.09166816622018814, 0.12575650215148926, -0.0744127407670021, -0.08160673081874847, -0.041428469121456146, -0.013197556138038635, -0.07011494040489197, 0.007606219500303268, -0.0786193236708641, 0.03318233788013458, -0.06102908402681351, 0.0368209108710289, 0.04309380054473877, 0.14515092968940735, 0.1091221272945404, -0.15718552470207214, -0.09926025569438934, -0.005241651087999344, 0.04501880705356598, -0.02616778388619423, 0.24155423045158386, 0.06155399605631828, 0.15135982632637024, 0.05509130284190178, -0.18658596277236938, -0.031035039573907852, 0.06489690393209457, -0.20563873648643494, 0.04414749890565872, 0.2112622857093811, 0.03758326172828674, -0.03460871800780296, 0.06152184307575226, -0.06763947755098343, 0.4404529929161072, 0.09817018359899521, 0.025641921907663345, 0.012386471033096313, 0.004561677575111389, 0.04689278453588486, 0.07524965703487396, 0.1939031183719635, 0.035211142152547836, -0.03955864906311035, 0.167204350233078, -0.16465820372104645, -0.02225707471370697, 0.3066743314266205, 0.11265327036380768, -0.010829560458660126, -0.0793602466583252, 0.18181967735290527, 0.12695066630840302, 0.20143385231494904, -0.11880946159362793, -0.12630681693553925, -0.07808607816696167, -0.14946143329143524, -0.18363870680332184, 0.04447734355926514, -0.05372277647256851, -0.03618936240673065, 0.24469274282455444, -0.33199816942214966, 0.08901114016771317, -0.25041982531547546, -0.03900512680411339, 0.06691588461399078, 0.035593077540397644, 0.12440968304872513, 0.11270277947187424, -0.09286811202764511, 0.07043497264385223, 0.12184084206819534, -0.19868220388889313, -0.0049579814076423645, -0.029814157634973526, 0.07671298086643219, 0.14490461349487305, -0.4444501996040344, -0.19263038039207458, 0.104872927069664]}"
"{\"sha\": \"8490a88f377d8fed802e4f3b2d1d87a0d6cb81b2\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/sized/cc_array_sized.c\", \"func_name\": \"cc_array_sized_iter_remove\", \"original_string\": \"enum cc_stat cc_array_sized_iter_remove(CC_ArraySizedIter *iter, uint8_t *out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_sized_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK) {\\n            iter->last_removed = true;\\n        }\\n    }\\n    return status;\\n}\", \"code_tokens\": [\"enum\", \"cc_stat\", \"cc_array_sized_iter_remove\", \"(\", \"CC_ArraySizedIter\", \"*\", \"iter\", \",\", \"uint8_t\", \"*\", \"out\", \")\", \"{\", \"enum\", \"cc_stat\", \"status\", \"=\", \"CC_ERR_VALUE_NOT_FOUND\", \";\", \"if\", \"(\", \"!\", \"iter\", \"->\", \"last_removed\", \")\", \"{\", \"status\", \"=\", \"cc_array_sized_remove_at\", \"(\", \"iter\", \"->\", \"ar\", \",\", \"iter\", \"->\", \"index\", \"-\", \"1\", \",\", \"out\", \")\", \";\", \"if\", \"(\", \"status\", \"==\", \"CC_OK\", \")\", \"{\", \"iter\", \"->\", \"last_removed\", \"=\", \"true\", \";\", \"}\", \"}\", \"return\", \"status\", \";\", \"}\"], \"docstring\": \"/**\\n * Removes the last returned element by <code>cc_array_sized_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Removes\", \"the\", \"last\", \"returned\", \"element\", \"by\", \"<code\", \">\", \"cc_array_sized_iter_next\", \"()\", \"<\", \"/\", \"code\", \">\", \"*\", \"function\", \"without\", \"invalidating\", \"the\", \"iterator\", \"and\", \"optionally\", \"sets\", \"the\", \"out\", \"*\", \"parameter\", \"to\", \"the\", \"value\", \"of\", \"the\", \"removed\", \"element\", \".\", \"*\", \"*\", \"@note\", \"This\", \"function\", \"should\", \"only\", \"ever\", \"be\", \"called\", \"after\", \"a\", \"call\", \"to\", \"<code\", \">\", \"*\", \"cc_array_sized_iter_next\", \"()\", \"<\", \"/\", \"code\", \">\", \".\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"iter\", \"the\", \"iterator\", \"on\", \"which\", \"this\", \"operation\", \"is\", \"being\", \"performed\", \"*\", \"@param\", \"[\", \"out\", \"]\", \"out\", \"pointer\", \"to\", \"where\", \"the\", \"removed\", \"element\", \"is\", \"stored\", \"or\", \"NULL\", \"*\", \"if\", \"it\", \"is\", \"to\", \"be\", \"ignored\", \"*\", \"*\", \"@return\", \"CC_OK\", \"if\", \"the\", \"element\", \"was\", \"successfully\", \"removed\", \"or\", \"*\", \"CC_ERR_VALUE_NOT_FOUND\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2024 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n\\n#include \\\"sized/cc_array_sized.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\n#define INDEX(a, i) a->data_length * i\\n#define BUF_ADDR(a, i) &a->buffer[a->data_length * i]\\n\\n\\nstruct cc_array_sized_s {\\n    size_t   data_length;\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    uint8_t *buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[in] Size of the array element in bytes\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new(size_t element_size, CC_ArraySized **out)\\n{\\n    CC_ArraySizedConf c;\\n    cc_array_sized_conf_init(&c);\\n    return cc_array_sized_new_conf(element_size, &c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_ArraySized based on the specified CC_ArraySizedConf struct \\n * and returns a status code.\\n *\\n * The CC_ArraySized is allocated using the allocators specified in the CC_ArraySizedConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArraySizedConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] element_size the size of the data being stored in bytes\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new_conf(\\n    size_t element_size, \\n    CC_ArraySizedConf const * const conf, \\n    CC_ArraySized **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_ArraySized *ar = conf->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    uint8_t *buff = conf->mem_alloc(conf->capacity * element_size);\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->data_length = element_size;\\n    ar->buffer      = buff;\\n    ar->exp_factor  = ex;\\n    ar->capacity    = conf->capacity;\\n    ar->mem_alloc   = conf->mem_alloc;\\n    ar->mem_calloc  = conf->mem_calloc;\\n    ar->mem_free    = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArraySizedConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArraySizedConf structure that is being initialized\\n */\\nvoid cc_array_sized_conf_init(CC_ArraySizedConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_ArraySized structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_sized_destroy(CC_ArraySized *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n\\n/**\\n * Adds a new element to the CC_ArraySized. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_ArraySized.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add(CC_ArraySized *ar, uint8_t *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    memcpy(BUF_ADDR(ar, ar->size), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add_at(CC_ArraySized *ar, uint8_t *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_sized_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * ar->data_length;\\n\\n    memmove(BUF_ADDR(ar, (index + 1)),\\n            BUF_ADDR(ar, index),\\n            shift);\\n\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_ArraySized.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_replace_at(CC_ArraySized *ar, uint8_t *element, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n* Swaps the values at the specified indices.\\n*\\n* @param[in] ar array whose elements are being swapped\\n* @param[in] index1 first position\\n* @param[in] index2 second position\\n* \\n* @return CC_OK if the operation was successful, or CC_ERR_OUT_OF_RANGE if \\n* one of the indices was out of range.\\n*/\\nenum cc_stat cc_array_sized_swap_at(CC_ArraySized *ar, size_t index1, size_t index2)\\n{\\n    if (index1 >= ar->size || index2 >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n\\n    for (size_t i = 0; i < ar->data_length; i++) {\\n        uint8_t tmp = ar->buffer[INDEX(ar, index1 + i)];\\n        ar->buffer[INDEX(ar, index1 + i)] = ar->buffer[INDEX(ar, index2 + i)];\\n        ar->buffer[INDEX(ar, index2 + i)] = tmp;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_ArraySized if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_sized_remove(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_sized_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n \\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_remove_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_sized_remove_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    return cc_array_sized_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_sized_remove_all(CC_ArraySized *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Copies an CC_ArraySized element from the specified index to the out pointer.\\n * The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] source index of the array element\\n * @param[out] destination address\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_sized_get_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_sized_get_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n    return cc_array_sized_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n* Returns the pointer to the element at the specified index\\n*/\\nenum cc_stat cc_array_sized_peek(CC_ArraySized* ar, size_t index, uint8_t** out)\\n{\\n    if (index > ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    *out = BUF_ADDR(ar, index);\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst uint8_t * const* cc_array_sized_get_buffer(CC_ArraySized *ar)\\n{\\n    return (const uint8_t* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_ArraySized.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_sized_index_of(CC_ArraySized *ar, uint8_t *element, size_t *index)\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) { \\n            // Mismatching byte, skip to next block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            if (j == ar->data_length - 1) {\\n                *index = i;\\n                return CC_OK;\\n            }\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_ArraySized, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_ArraySized, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's allocators\\n *       and it also inherits the configuration of the original CC_ArraySized.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_sized_subarray(CC_ArraySized *ar, size_t b, size_t e, CC_ArraySized **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_ArraySized *sub_ar = ar->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * ar->data_length))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc   = ar->mem_alloc;\\n    sub_ar->mem_calloc  = ar->mem_calloc;\\n    sub_ar->mem_free    = ar->mem_free;\\n    sub_ar->size        = e - b + 1;\\n    sub_ar->capacity    = sub_ar->size;\\n    sub_ar->data_length = ar->data_length;\\n\\n    memcpy(sub_ar->buffer,\\n           BUF_ADDR(ar, b),\\n           sub_ar->size * ar->data_length);\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a copy of the specified CC_ArraySized. \\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's\\n *       allocators and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_sized_copy(CC_ArraySized *ar, CC_ArraySized **out)\\n{\\n    CC_ArraySized *copy = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->data_length = ar->data_length;\\n    copy->exp_factor  = ar->exp_factor;\\n    copy->size        = ar->size;\\n    copy->capacity    = ar->capacity;\\n    copy->mem_alloc   = ar->mem_alloc;\\n    copy->mem_calloc  = ar->mem_calloc;\\n    copy->mem_free    = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * ar->data_length);\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_ArraySized was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_ArraySized is empty.\\n */\\nenum cc_stat cc_array_sized_filter_mut(CC_ArraySized *ar, bool (*pred) (const uint8_t*))\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(BUF_ADDR(ar, i))) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * ar->data_length;\\n                memmove(BUF_ADDR(ar, (i + 1)),\\n                        BUF_ADDR(ar, (i + 1 + rm)),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * ar->data_length;\\n        memmove(BUF_ADDR(ar, 0),\\n                BUF_ADDR(ar, rm),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by creating a new CC_ArraySized that contains all elements\\n * from the original CC_ArraySized that return true on pred(element) without modifying \\n * the original CC_ArraySized.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_sized_filter(CC_ArraySized *ar, bool (*pred) (const uint8_t*), CC_ArraySized **out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    CC_ArraySized *filtered = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!filtered) {\\n        return CC_ERR_ALLOC;\\n    }\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->data_length = ar->data_length;\\n    filtered->exp_factor  = ar->exp_factor;\\n    filtered->size        = 0;\\n    filtered->capacity    = ar->capacity;\\n    filtered->mem_alloc   = ar->mem_alloc;\\n    filtered->mem_calloc  = ar->mem_calloc;\\n    filtered->mem_free    = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(BUF_ADDR(ar, i))) {\\n            memcpy(BUF_ADDR(filtered, f++), \\n                   BUF_ADDR(ar, i),\\n                   ar->data_length);\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_sized_reverse(CC_ArraySized *ar, uint8_t *tmp)\\n{\\n    if (ar->size == 0) {\\n        return;\\n    }\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        memcpy(tmp, BUF_ADDR(ar, i), ar->data_length);\\n        memcpy(BUF_ADDR(ar, i), BUF_ADDR(ar, j), ar->data_length);\\n        memcpy(BUF_ADDR(ar, j), tmp, ar->data_length);\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_ArraySized, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_sized_trim_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->size == ar->capacity) {\\n        return CC_OK;\\n    }\\n    uint8_t *new_buff = ar->mem_calloc(ar->size, ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * ar->data_length);\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_ArraySized.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_sized_contains(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t o = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) {\\n            // Mismatching byte, skip block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            // Last byte is equal, match found\\n            if (j == ar->data_length - 1) {\\n                o++;\\n            }\\n        }\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_ArraySized. The size of the array is the\\n * number of elements contained within the CC_ArraySized.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_ArraySized.\\n */\\nsize_t cc_array_sized_size(CC_ArraySized *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_ArraySized. The capacity of the CC_ArraySized is\\n * the maximum number of elements an CC_ArraySized can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_ArraySized.\\n */\\nsize_t cc_array_sized_capacity(CC_ArraySized *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sized_sort(CC_ArraySized *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, ar->data_length, cmp);\\n}\\n\\n/**\\n * Expands the CC_ArraySized capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS) {\\n        return CC_ERR_MAX_CAPACITY;\\n    }\\n\\n    size_t new_capacity = (size_t) (ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity) {\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    } else {\\n        ar->capacity = new_capacity;\\n    }\\n    uint8_t *new_buff = ar->mem_alloc(ar->capacity * ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    memcpy(new_buff, ar->buffer, ar->size * ar->data_length);\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_sized_map(CC_ArraySized *ar, void (*fn) (uint8_t *e))\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        fn(BUF_ADDR(ar, i));\\n    }\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_sized_reduce(CC_ArraySized *ar, void (*fn) (uint8_t*, uint8_t*, uint8_t*), uint8_t *result)\\n{\\n    if (ar->size == 1) {\\n        fn(BUF_ADDR(ar, 0), NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1) {\\n        fn(BUF_ADDR(ar, 0), BUF_ADDR(ar, 1), result);\\n    }\\n    for (size_t i = 2; i < ar->size; i++) {\\n        fn(result, BUF_ADDR(ar, i), result);\\n    }\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_sized_iter_init(CC_ArraySizedIter *iter, CC_ArraySized *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the reference of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_sized_iter_next(CC_ArraySizedIter *iter, uint8_t **out)\\n{\\n    if (iter->index >= iter->ar->size) {\\n        return CC_ITER_END;\\n    }\\n    *out = BUF_ADDR(iter->ar, iter->index);\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_sized_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_sized_iter_remove(CC_ArraySizedIter *iter, uint8_t *out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_sized_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK) {\\n            iter->last_removed = true;\\n        }\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_ArraySized after the last returned element by\\n * <code>cc_array_sized_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_iter_add(CC_ArraySizedIter *iter, uint8_t *element)\\n{\\n    return cc_array_sized_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_sized_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_iter_replace(CC_ArraySizedIter *iter, uint8_t *element, uint8_t *out)\\n{\\n    return cc_array_sized_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_sized_iter_index(CC_ArraySizedIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_sized_zip_iter_init(CC_ArraySizedZipIter *iter, CC_ArraySized *ar1, CC_ArraySized *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_sized_zip_iter_next(CC_ArraySizedZipIter *iter, uint8_t **out1, uint8_t **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size) {\\n        return CC_ITER_END;\\n    }\\n    *out1 = BUF_ADDR(iter->ar1, iter->index);\\n    *out2 = BUF_ADDR(iter->ar2, iter->index);\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_sized_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_remove(CC_ArraySizedZipIter *iter, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (!iter->last_removed) {\\n        cc_array_sized_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_sized_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_sized_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_sized_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_add(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_ArraySized  *ar1  = iter->ar1;\\n    CC_ArraySized  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n        (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK))) {\\n        return CC_ERR_ALLOC;\\n    }\\n    cc_array_sized_add_at(ar1, e1, index);\\n    cc_array_sized_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_zip_iter_replace(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    cc_array_sized_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_sized_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_sized_zip_iter_index(CC_ArraySizedZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_sized_struct_size()\\n{\\n    return sizeof(CC_ArraySized);\\n}\", \"embeddings\": [-0.012270867824554443, 0.03804150968790054, 0.07345869392156601, 0.1126929372549057, 0.4043710231781006, -0.16479067504405975, 0.11845332384109497, 0.2811301052570343, 0.04095041751861572, -0.29190996289253235, 0.0823652446269989, -0.12413714081048965, 0.04153060168027878, 0.09661325812339783, 0.02684326097369194, 0.030838802456855774, 0.04018305242061615, -0.022392988204956055, 0.03538307547569275, -0.27989426255226135, -0.1770043969154358, 0.11360548436641693, 0.12206505984067917, 0.13419221341609955, 0.2802375853061676, 0.07013706117868423, 0.23802995681762695, 0.12527808547019958, 0.30471861362457275, -0.1631557047367096, 0.0008933767676353455, -0.06803049892187119, 0.06261201202869415, -0.2004896104335785, -0.007179226726293564, -0.02933264523744583, 0.007264241576194763, 0.09713976085186005, -0.026210011914372444, 0.032652586698532104, -0.17994718253612518, 0.016743719577789307, 0.06579606980085373, 0.15998336672782898, 0.09178094565868378, -0.01795210689306259, 0.07205283641815186, 0.19554747641086578, -0.061738889664411545, 0.057021740823984146, 0.12664508819580078, -0.08098025619983673, 0.020327743142843246, -0.08514279872179031, -0.05499671772122383, -0.03145526349544525, -0.02465374767780304, 0.37475162744522095, 0.046488333493471146, -0.022245027124881744, -0.07313074171543121, -0.17410047352313995, -0.19487202167510986, 0.1373603641986847, 0.10496530681848526, -0.01808372139930725, -0.11541187763214111, -0.2221762239933014, 0.02163340337574482, -0.007953915745019913, 0.0657651275396347, 0.06989022344350815, 0.09642677754163742, -0.16669771075248718, -0.183487668633461, -0.11037357151508331, 0.07325536012649536, 0.4733620285987854, -0.07330241054296494, 0.17061269283294678, 0.18170350790023804, -0.10579836368560791, 0.042100079357624054, 0.16506034135818481, 0.1214752346277237, 0.03695226460695267, -0.1269131898880005, 0.09124305844306946, -0.045215196907520294, 0.1702391803264618, 0.10716278105974197, 0.11060714721679688, -0.10805254429578781, -0.03944044187664986, 0.014063339680433273, -0.04215409234166145, 0.09815344214439392, -0.18329325318336487, 0.06581243872642517, 0.43336021900177, -0.11444903910160065, -0.07619908452033997, -0.2106325328350067, -0.08971913158893585, -0.04025083780288696, 0.010422740131616592, -0.029234126210212708, 0.07638923823833466, 0.07121500372886658, 0.0011620298027992249, 0.1444205641746521, 0.05806513875722885, 0.0378590002655983, 0.04926266521215439, 0.04115643352270126, -0.08607131242752075, 0.11722977459430695, 0.007626790553331375, 0.1868979036808014, -0.1439957320690155, 0.12093965709209442, 0.0026061758399009705, -0.029033638536930084, -0.08342179656028748, -0.06994129717350006, 0.0654919445514679, 0.04920165240764618, -0.25752875208854675, 0.17061057686805725, 0.06313452124595642, -0.008205674588680267, -0.13916750252246857, -0.006429359316825867, -0.03607846051454544, 0.08330745995044708, 0.004850197583436966, 0.08976916968822479, 0.041779328137636185, 0.008560769259929657, -0.006078869104385376, -0.08153501898050308, 0.061033837497234344, 0.30046242475509644, -0.051542770117521286, 0.23820263147354126, -0.13588179647922516, 0.19398163259029388, 0.1418568640947342, -0.31562569737434387, -0.17833901941776276, 0.03474324569106102, -0.11792238056659698, -0.031279563903808594, 0.04144076630473137, -0.10724999010562897, 0.7357208132743835, 0.1326116919517517, -0.1311621069908142, -0.016145676374435425, 0.011277839541435242, 0.03282761201262474, -0.26366332173347473, -0.044583991169929504, 0.2041575014591217, 0.05354778841137886, 0.10796298831701279, 0.06478668749332428, 0.01938539184629917, 0.14559349417686462, 0.0007597804069519043, 0.11430926620960236, -0.06336754560470581, -0.06649436801671982, 0.16471755504608154, 0.03087150678038597, -0.061195217072963715, -0.13151580095291138, 0.05739372968673706, -0.05981052666902542, -0.0008985549211502075, -0.12224005162715912, -0.0008567348122596741, -0.1351391226053238, -0.0436883270740509, -0.09838869422674179, -0.022148381918668747, -0.004013225436210632, -0.08887118101119995, 0.04943140223622322, 0.024427451193332672, 0.04715057462453842, -0.0036546066403388977, 0.1441013514995575, -0.02335299551486969, -0.04929544776678085, 0.006881393492221832, -0.11896710842847824, -0.04747842252254486, 0.1722240447998047, -0.037818968296051025, -0.060008704662323, -0.16576504707336426, 0.1924259513616562, -0.05501114949584007, -0.022859737277030945, 0.12327119708061218, -0.2882693111896515, -0.007697343826293945, -0.022119205445051193, -0.06700042635202408, -0.08579465746879578, 0.15665203332901, 0.08724384009838104, 0.039834823459386826, -0.07179830968379974, -0.12014923244714737, 0.08467572927474976, 0.1845356822013855, 0.054355841130018234, -0.06932863593101501, 0.1319623589515686, 0.21394002437591553, -0.0720665454864502, -0.0707249641418457, -0.07778409868478775, 0.1703270971775055, 0.22737714648246765, 0.1099696010351181, -0.01660790666937828, 0.04894349351525307, 0.14905884861946106, 0.17997480928897858, -0.21840603649616241, 0.15627418458461761, 0.026439890265464783, -0.15813802182674408, -0.06654979288578033, 0.046699948608875275, -0.009285226464271545, -0.15431509912014008, -0.008375156670808792, 0.1931762993335724, 0.16891905665397644, 0.2824403643608093, 0.04841158166527748, 0.034215256571769714, -0.1136767715215683, -0.045528657734394073, -0.14207637310028076, 0.018212981522083282, 0.012197584845125675, 0.011625317856669426, 0.04642239958047867, -0.09047012031078339, -0.13545753061771393, -0.018557235598564148, -0.0599004328250885, -0.017849799245595932, 0.10747477412223816, 0.3209354877471924, -0.015973158180713654, -0.02425435744225979, 0.06427765637636185, -0.0018170848488807678, -0.104337677359581, -0.42195451259613037, -0.05606839060783386, 0.06264571100473404, 0.03305642679333687, -0.005306854844093323, 0.07948742061853409, -0.11335613578557968, 0.2951175272464752, 0.1036735400557518, 0.06752091646194458, -0.009435594081878662, -0.05514872074127197, 0.051622867584228516, -0.135242760181427, 0.012471972033381462, -0.022592153400182724, 0.07321293652057648, -0.16449961066246033, 0.07836763560771942, 0.014059877023100853, 0.01825552247464657, 0.11693135648965836, 0.06096755713224411, 0.00038893893361091614, 0.033873915672302246, 0.04187164828181267, 0.07360822707414627, 0.16154032945632935, 0.15006078779697418, 0.07827655971050262, 0.11563649773597717, 0.17729608714580536, -0.08770184218883514, -0.021177008748054504, -0.26062002778053284, 0.0698600709438324, -0.2649737298488617, 0.05329529196023941, -0.08478125184774399, 0.37008658051490784, 0.040836356580257416, -0.04697831720113754, -0.0012179240584373474, 0.24587635695934296, 0.03865806758403778, 0.08971073478460312, 0.07378809154033661, -0.11478392034769058, 0.07625269889831543, -0.11252099275588989, 0.10635314881801605, -0.04666374623775482, -0.10261209309101105, 0.09328107535839081, 0.0019451826810836792, -0.032637905329465866, 0.13584575057029724, 0.21216757595539093, 0.11988593637943268, 0.010125438682734966, 0.04024010896682739, 0.08923052251338959, -0.0012835951056331396, -0.17287638783454895, 0.5817611217498779, -0.5118329524993896, 0.1505240648984909, -0.1749088168144226, 0.3314966857433319, -0.020345762372016907, 0.28732264041900635, -0.07841216772794724, 0.12310010194778442, 0.08962129056453705, 0.1565999686717987, -0.09359458088874817, -0.08945997059345245, -0.16121546924114227, 0.2642611861228943, 0.12735310196876526, 0.20190691947937012, 0.21502487361431122, -0.06374217569828033, 0.12349852174520493, -0.07670451700687408, -0.16058364510536194, 0.20257800817489624, -0.028613746166229248, -0.12852628529071808, 0.0963086485862732, 0.4068722128868103, -0.1287705898284912, -0.03464793041348457, -0.005900191143155098, -0.021397940814495087, 0.1522621363401413, -0.16836488246917725, 0.15152886509895325, -0.1564033329486847, 0.26949071884155273, -0.4900316596031189, -0.3770139813423157, 0.006907902657985687, -0.1257084608078003, 0.09219447523355484, 0.17152638733386993, 0.1802653819322586, 0.16396553814411163, -0.28061485290527344, 0.10558394342660904, -0.02714141085743904, -0.06795177608728409, -0.014197207987308502, 0.020854204893112183, 0.14499962329864502, 0.0062417760491371155, 0.03437957540154457, 0.06605537235736847, 0.008768077939748764, 0.0590515099465847, -0.18306976556777954, 0.30271798372268677, 0.1711062341928482, 0.2341730147600174, -0.08026397228240967, 0.09303335100412369, -0.12396346032619476, 0.0858558639883995, 0.016838548704981804, 0.0244230255484581, 0.07735594362020493, -0.1067359521985054, 0.14610925316810608, -0.07756597548723221, -0.08939225971698761, 0.15322843194007874, 0.23850083351135254, -0.03115272894501686, 0.22918349504470825, 0.12551915645599365, 0.08024410158395767, 0.1251722276210785, -0.1304861605167389, -0.11164002120494843, -0.20444636046886444, 0.0939597636461258, 0.1277022659778595, 0.09465503692626953, 0.010346565395593643, 0.17956013977527618, -0.11359123885631561, 0.02083357609808445, -0.29767757654190063, -0.09355933219194412, 0.191261887550354, 0.2056465446949005, 0.1440863162279129, -0.01706329733133316, -0.2053244709968567, -0.045318737626075745, -0.006501891650259495, -0.053867220878601074, -0.05122007057070732, 0.029626455157995224, -0.1940535008907318, 0.01650109887123108, 0.29376161098480225, 0.05391288176178932, 0.08795187622308731, 0.10683779418468475, -0.057832397520542145, -0.10922418534755707, -0.03698481246829033, 0.10960344970226288, 0.024937542155385017, -0.08402480185031891, 0.04950568079948425, 0.08036348223686218, 0.08137815445661545, -0.010470651090145111, -0.09376164525747299, 0.31158551573753357, 0.11103139817714691, -0.09311337769031525, 0.07508986443281174, -0.16871999204158783, -0.023677319288253784, -0.035988617688417435, -0.29125332832336426, 0.10949471592903137, 0.15603330731391907, 0.11707955598831177, 0.0762414038181305, 0.19039294123649597, 0.03770901635289192, 0.0053027234971523285, 0.07021132856607437, -0.09770633280277252, -0.16576337814331055, 0.08405404537916183, -0.07092013210058212, 0.1537826955318451, 0.024128666147589684, 0.23307257890701294, 0.13900083303451538, 0.10229716449975967, 0.23797288537025452, 0.05255085229873657, -0.056616634130477905, 0.02453753352165222, -0.0497736930847168, -0.0315299816429615, -0.23312492668628693, 0.0047409869730472565, -0.13600970804691315, 0.0011506862938404083, 0.10852162539958954, 0.12562131881713867, 0.014640819281339645, 0.03498447686433792, -0.16887825727462769, 0.25463852286338806, 0.15325595438480377, -0.12206542491912842, 0.019050627946853638, -0.11089588701725006, 0.11030279099941254, 0.0691271722316742, 0.1689472645521164, 0.2641183137893677, 0.173930823802948, 0.024390392005443573, 0.11335673928260803, 0.36780059337615967, -0.12537650763988495, 0.0012862086296081543, 0.10740049183368683, 0.03847971186041832, -0.021412987262010574, -0.10870486497879028, -0.12638422846794128, -0.008891511708498001, 0.0466376394033432, 0.16493287682533264, -0.19668099284172058, -0.05157138407230377, -0.08095309883356094, 0.15626023709774017, 0.01694072037935257, 0.019625235348939896, 0.08997495472431183, -0.04147814214229584, 0.004128279164433479, -0.0943678766489029, 0.30045419931411743, -0.1317296028137207, -0.14536117017269135, -0.03381789103150368, 0.022243021056056023, -0.06800249963998795, 0.038727767765522, 0.1237749457359314, -0.009018667042255402, 0.1299610733985901, 0.047818537801504135, 0.016111593693494797, 0.038041360676288605, 0.05190955474972725, 0.19603408873081207, -0.06094871833920479, 0.013672498986124992, 0.019913699477910995, 0.0741150751709938, 0.2434280961751938, -0.07996200025081635, -0.25964662432670593, -0.08720877021551132, 0.19088777899742126, -0.16453106701374054, 0.12639690935611725, 0.04154394567012787, 0.19125297665596008, 0.11485467851161957, -0.014060929417610168, 0.0009149685502052307, -0.10000546276569366, -0.6795606017112732, -0.10652348399162292, 0.16803687810897827, 0.03234000876545906, 0.04496770352125168, 0.19585414230823517, 0.11336341500282288, 0.03985590487718582, 0.13092796504497528, 0.06796164810657501, -0.0164286270737648, 0.1482827216386795, 0.21390877664089203, -0.13752301037311554, -0.14350339770317078, 0.1286165416240692, 0.09397689253091812, -0.1980353593826294, 0.23872095346450806, -0.07023647427558899, -0.11205332726240158, 0.030966781079769135, 0.3203669786453247, -0.00951065868139267, 0.060397665947675705, 0.25100040435791016, 0.05985846370458603, 0.2876965403556824, -0.0757334977388382, 0.115730419754982, 0.32681500911712646, 0.14317981898784637, -0.33433568477630615, 0.003119058907032013, 0.11862219125032425, 0.23446016013622284, 0.07271409779787064, 13.863909721374512, -0.013598927296698093, 0.2297389954328537, -0.1782875657081604, -0.06383192539215088, -0.03335820883512497, -0.09356608241796494, 0.054670549929142, -0.009677916765213013, 0.017363082617521286, 0.09761429578065872, -0.08479542285203934, 0.02046213485300541, -0.04781496152281761, -0.08125580847263336, -0.008858554065227509, -0.051084622740745544, -0.09336332976818085, 0.13991951942443848, 0.007620960474014282, -0.18068885803222656, -0.08930382132530212, -0.039887577295303345, -0.47861936688423157, -0.05592046305537224, -0.0005685165524482727, 0.13309404253959656, 0.10576945543289185, 0.033415287733078, 0.07363035529851913, 0.06399170309305191, 0.1492619663476944, 0.09753803163766861, -0.03453361243009567, -0.03127328306436539, -0.02822023257613182, -0.4204922318458557, -0.13141712546348572, 0.08977065980434418, 0.0025934502482414246, -0.029363729059696198, 0.01737358048558235, 0.18041643500328064, -0.08616744726896286, 0.08542803674936295, 0.09348303824663162, -0.1638902723789215, 0.14180836081504822, -0.09427201002836227, -0.03289801627397537, 0.20453527569770813, 0.13217347860336304, 0.3436652421951294, -0.02798709273338318, -0.14967340230941772, -0.271546334028244, 0.2960204482078552, -0.02394627034664154, -0.04934021830558777, 0.43154671788215637, 0.01630689948797226, -0.08286207169294357, -0.06731778383255005, 0.01887020282447338, -0.05552132800221443, 0.02779494971036911, 0.10335138440132141, 0.11209199577569962, -0.20848672091960907, 0.18422582745552063, 0.2536308765411377, -0.2227611094713211, 0.16142655909061432, -0.04602573439478874, -0.0763314813375473, 0.10332389175891876, -0.014775313436985016, -0.049437519162893295, 0.048532627522945404, -0.10192662477493286, 0.01982705667614937, 0.06461076438426971, -0.1998029202222824, -0.13793055713176727, -0.2776373624801636, 0.08699237555265427, 0.0033186301589012146, 0.19130846858024597, 0.2869444489479065, -0.04165872931480408, -0.027547799050807953, 0.0011076144874095917, -0.02780933678150177, -0.15983423590660095, 0.22117197513580322, -0.018929943442344666, -0.09128841757774353, -0.14439867436885834, 0.02952609211206436, 0.13612788915634155, -0.023578107357025146, -0.09629696607589722, -0.02127205580472946, -0.008534282445907593, -0.12524163722991943, -0.051098816096782684, -0.022817812860012054, 0.02383572608232498, -0.06743218004703522, 0.06784695386886597, 0.027742434293031693, 0.04625517502427101, 0.0721697062253952, -0.2116960734128952, -0.12623806297779083, -0.03420634940266609, -0.05000258609652519, -0.025709155946969986, 0.21519942581653595, 0.08553986996412277, 0.12530703842639923, 0.0938713401556015, -0.23287229239940643, -0.061212051659822464, 0.08277253061532974, -0.21135187149047852, 0.06417697668075562, 0.17592449486255646, 0.0541277676820755, -0.02912570908665657, -0.03608941659331322, -0.049048155546188354, 0.5206823348999023, 0.1664888709783554, 0.049832239747047424, -0.07827375829219818, 0.024032719433307648, 0.027437031269073486, 0.061716821044683456, 0.22264985740184784, 0.0646824836730957, 0.02486620843410492, 0.14534299075603485, -0.12724074721336365, -0.02838195115327835, 0.3160005211830139, 0.1342426836490631, -0.022768080234527588, -0.13998650014400482, 0.13851308822631836, 0.05221065133810043, 0.13545352220535278, -0.17867594957351685, -0.07288578152656555, -0.1393362581729889, -0.16537173092365265, -0.15515276789665222, 0.007743604481220245, -0.06098458915948868, 0.019617993384599686, 0.11972945928573608, -0.26495257019996643, 0.08035842329263687, -0.248220756649971, -0.053318772464990616, 0.05960719287395477, 0.05013605207204819, 0.1409187763929367, 0.10254935920238495, -0.07045245915651321, 0.0527845062315464, 0.08406553417444229, -0.11630985140800476, 0.0038324743509292603, -0.06239420548081398, 0.07545822113752365, 0.2540820837020874, -0.4387091398239136, -0.1751932054758072, 0.09138849377632141]}"
"{\"sha\": \"8490a88f377d8fed802e4f3b2d1d87a0d6cb81b2\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/sized/cc_array_sized.c\", \"func_name\": \"cc_array_sized_zip_iter_init\", \"original_string\": \"void cc_array_sized_zip_iter_init(CC_ArraySizedZipIter *iter, CC_ArraySized *ar1, CC_ArraySized *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\", \"code_tokens\": [\"void\", \"cc_array_sized_zip_iter_init\", \"(\", \"CC_ArraySizedZipIter\", \"*\", \"iter\", \",\", \"CC_ArraySized\", \"*\", \"ar1\", \",\", \"CC_ArraySized\", \"*\", \"ar2\", \")\", \"{\", \"iter\", \"->\", \"ar1\", \"=\", \"ar1\", \";\", \"iter\", \"->\", \"ar2\", \"=\", \"ar2\", \";\", \"iter\", \"->\", \"index\", \"=\", \"0\", \";\", \"iter\", \"->\", \"last_removed\", \"=\", \"false\", \";\", \"}\"], \"docstring\": \"/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Initializes\", \"the\", \"zip\", \"iterator\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"iter\", \"iterator\", \"that\", \"is\", \"being\", \"initialized\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"ar1\", \"first\", \"array\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"ar2\", \"second\", \"array\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2024 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n\\n#include \\\"sized/cc_array_sized.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\n#define INDEX(a, i) a->data_length * i\\n#define BUF_ADDR(a, i) &a->buffer[a->data_length * i]\\n\\n\\nstruct cc_array_sized_s {\\n    size_t   data_length;\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    uint8_t *buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[in] Size of the array element in bytes\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new(size_t element_size, CC_ArraySized **out)\\n{\\n    CC_ArraySizedConf c;\\n    cc_array_sized_conf_init(&c);\\n    return cc_array_sized_new_conf(element_size, &c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_ArraySized based on the specified CC_ArraySizedConf struct \\n * and returns a status code.\\n *\\n * The CC_ArraySized is allocated using the allocators specified in the CC_ArraySizedConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArraySizedConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] element_size the size of the data being stored in bytes\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new_conf(\\n    size_t element_size, \\n    CC_ArraySizedConf const * const conf, \\n    CC_ArraySized **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_ArraySized *ar = conf->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    uint8_t *buff = conf->mem_alloc(conf->capacity * element_size);\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->data_length = element_size;\\n    ar->buffer      = buff;\\n    ar->exp_factor  = ex;\\n    ar->capacity    = conf->capacity;\\n    ar->mem_alloc   = conf->mem_alloc;\\n    ar->mem_calloc  = conf->mem_calloc;\\n    ar->mem_free    = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArraySizedConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArraySizedConf structure that is being initialized\\n */\\nvoid cc_array_sized_conf_init(CC_ArraySizedConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_ArraySized structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_sized_destroy(CC_ArraySized *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n\\n/**\\n * Adds a new element to the CC_ArraySized. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_ArraySized.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add(CC_ArraySized *ar, uint8_t *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    memcpy(BUF_ADDR(ar, ar->size), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add_at(CC_ArraySized *ar, uint8_t *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_sized_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * ar->data_length;\\n\\n    memmove(BUF_ADDR(ar, (index + 1)),\\n            BUF_ADDR(ar, index),\\n            shift);\\n\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_ArraySized.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_replace_at(CC_ArraySized *ar, uint8_t *element, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n* Swaps the values at the specified indices.\\n*\\n* @param[in] ar array whose elements are being swapped\\n* @param[in] index1 first position\\n* @param[in] index2 second position\\n* \\n* @return CC_OK if the operation was successful, or CC_ERR_OUT_OF_RANGE if \\n* one of the indices was out of range.\\n*/\\nenum cc_stat cc_array_sized_swap_at(CC_ArraySized *ar, size_t index1, size_t index2)\\n{\\n    if (index1 >= ar->size || index2 >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n\\n    for (size_t i = 0; i < ar->data_length; i++) {\\n        uint8_t tmp = ar->buffer[INDEX(ar, index1 + i)];\\n        ar->buffer[INDEX(ar, index1 + i)] = ar->buffer[INDEX(ar, index2 + i)];\\n        ar->buffer[INDEX(ar, index2 + i)] = tmp;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_ArraySized if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_sized_remove(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_sized_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n \\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_remove_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_sized_remove_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    return cc_array_sized_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_sized_remove_all(CC_ArraySized *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Copies an CC_ArraySized element from the specified index to the out pointer.\\n * The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] source index of the array element\\n * @param[out] destination address\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_sized_get_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_sized_get_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n    return cc_array_sized_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n* Returns the pointer to the element at the specified index\\n*/\\nenum cc_stat cc_array_sized_peek(CC_ArraySized* ar, size_t index, uint8_t** out)\\n{\\n    if (index > ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    *out = BUF_ADDR(ar, index);\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst uint8_t * const* cc_array_sized_get_buffer(CC_ArraySized *ar)\\n{\\n    return (const uint8_t* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_ArraySized.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_sized_index_of(CC_ArraySized *ar, uint8_t *element, size_t *index)\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) { \\n            // Mismatching byte, skip to next block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            if (j == ar->data_length - 1) {\\n                *index = i;\\n                return CC_OK;\\n            }\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_ArraySized, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_ArraySized, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's allocators\\n *       and it also inherits the configuration of the original CC_ArraySized.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_sized_subarray(CC_ArraySized *ar, size_t b, size_t e, CC_ArraySized **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_ArraySized *sub_ar = ar->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * ar->data_length))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc   = ar->mem_alloc;\\n    sub_ar->mem_calloc  = ar->mem_calloc;\\n    sub_ar->mem_free    = ar->mem_free;\\n    sub_ar->size        = e - b + 1;\\n    sub_ar->capacity    = sub_ar->size;\\n    sub_ar->data_length = ar->data_length;\\n\\n    memcpy(sub_ar->buffer,\\n           BUF_ADDR(ar, b),\\n           sub_ar->size * ar->data_length);\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a copy of the specified CC_ArraySized. \\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's\\n *       allocators and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_sized_copy(CC_ArraySized *ar, CC_ArraySized **out)\\n{\\n    CC_ArraySized *copy = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->data_length = ar->data_length;\\n    copy->exp_factor  = ar->exp_factor;\\n    copy->size        = ar->size;\\n    copy->capacity    = ar->capacity;\\n    copy->mem_alloc   = ar->mem_alloc;\\n    copy->mem_calloc  = ar->mem_calloc;\\n    copy->mem_free    = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * ar->data_length);\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_ArraySized was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_ArraySized is empty.\\n */\\nenum cc_stat cc_array_sized_filter_mut(CC_ArraySized *ar, bool (*pred) (const uint8_t*))\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(BUF_ADDR(ar, i))) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * ar->data_length;\\n                memmove(BUF_ADDR(ar, (i + 1)),\\n                        BUF_ADDR(ar, (i + 1 + rm)),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * ar->data_length;\\n        memmove(BUF_ADDR(ar, 0),\\n                BUF_ADDR(ar, rm),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by creating a new CC_ArraySized that contains all elements\\n * from the original CC_ArraySized that return true on pred(element) without modifying \\n * the original CC_ArraySized.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_sized_filter(CC_ArraySized *ar, bool (*pred) (const uint8_t*), CC_ArraySized **out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    CC_ArraySized *filtered = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!filtered) {\\n        return CC_ERR_ALLOC;\\n    }\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->data_length = ar->data_length;\\n    filtered->exp_factor  = ar->exp_factor;\\n    filtered->size        = 0;\\n    filtered->capacity    = ar->capacity;\\n    filtered->mem_alloc   = ar->mem_alloc;\\n    filtered->mem_calloc  = ar->mem_calloc;\\n    filtered->mem_free    = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(BUF_ADDR(ar, i))) {\\n            memcpy(BUF_ADDR(filtered, f++), \\n                   BUF_ADDR(ar, i),\\n                   ar->data_length);\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_sized_reverse(CC_ArraySized *ar, uint8_t *tmp)\\n{\\n    if (ar->size == 0) {\\n        return;\\n    }\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        memcpy(tmp, BUF_ADDR(ar, i), ar->data_length);\\n        memcpy(BUF_ADDR(ar, i), BUF_ADDR(ar, j), ar->data_length);\\n        memcpy(BUF_ADDR(ar, j), tmp, ar->data_length);\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_ArraySized, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_sized_trim_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->size == ar->capacity) {\\n        return CC_OK;\\n    }\\n    uint8_t *new_buff = ar->mem_calloc(ar->size, ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * ar->data_length);\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_ArraySized.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_sized_contains(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t o = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) {\\n            // Mismatching byte, skip block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            // Last byte is equal, match found\\n            if (j == ar->data_length - 1) {\\n                o++;\\n            }\\n        }\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_ArraySized. The size of the array is the\\n * number of elements contained within the CC_ArraySized.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_ArraySized.\\n */\\nsize_t cc_array_sized_size(CC_ArraySized *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_ArraySized. The capacity of the CC_ArraySized is\\n * the maximum number of elements an CC_ArraySized can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_ArraySized.\\n */\\nsize_t cc_array_sized_capacity(CC_ArraySized *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sized_sort(CC_ArraySized *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, ar->data_length, cmp);\\n}\\n\\n/**\\n * Expands the CC_ArraySized capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS) {\\n        return CC_ERR_MAX_CAPACITY;\\n    }\\n\\n    size_t new_capacity = (size_t) (ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity) {\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    } else {\\n        ar->capacity = new_capacity;\\n    }\\n    uint8_t *new_buff = ar->mem_alloc(ar->capacity * ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    memcpy(new_buff, ar->buffer, ar->size * ar->data_length);\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_sized_map(CC_ArraySized *ar, void (*fn) (uint8_t *e))\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        fn(BUF_ADDR(ar, i));\\n    }\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_sized_reduce(CC_ArraySized *ar, void (*fn) (uint8_t*, uint8_t*, uint8_t*), uint8_t *result)\\n{\\n    if (ar->size == 1) {\\n        fn(BUF_ADDR(ar, 0), NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1) {\\n        fn(BUF_ADDR(ar, 0), BUF_ADDR(ar, 1), result);\\n    }\\n    for (size_t i = 2; i < ar->size; i++) {\\n        fn(result, BUF_ADDR(ar, i), result);\\n    }\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_sized_iter_init(CC_ArraySizedIter *iter, CC_ArraySized *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the reference of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_sized_iter_next(CC_ArraySizedIter *iter, uint8_t **out)\\n{\\n    if (iter->index >= iter->ar->size) {\\n        return CC_ITER_END;\\n    }\\n    *out = BUF_ADDR(iter->ar, iter->index);\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_sized_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_sized_iter_remove(CC_ArraySizedIter *iter, uint8_t *out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_sized_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK) {\\n            iter->last_removed = true;\\n        }\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_ArraySized after the last returned element by\\n * <code>cc_array_sized_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_iter_add(CC_ArraySizedIter *iter, uint8_t *element)\\n{\\n    return cc_array_sized_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_sized_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_iter_replace(CC_ArraySizedIter *iter, uint8_t *element, uint8_t *out)\\n{\\n    return cc_array_sized_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_sized_iter_index(CC_ArraySizedIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_sized_zip_iter_init(CC_ArraySizedZipIter *iter, CC_ArraySized *ar1, CC_ArraySized *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_sized_zip_iter_next(CC_ArraySizedZipIter *iter, uint8_t **out1, uint8_t **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size) {\\n        return CC_ITER_END;\\n    }\\n    *out1 = BUF_ADDR(iter->ar1, iter->index);\\n    *out2 = BUF_ADDR(iter->ar2, iter->index);\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_sized_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_remove(CC_ArraySizedZipIter *iter, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (!iter->last_removed) {\\n        cc_array_sized_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_sized_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_sized_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_sized_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_add(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_ArraySized  *ar1  = iter->ar1;\\n    CC_ArraySized  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n        (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK))) {\\n        return CC_ERR_ALLOC;\\n    }\\n    cc_array_sized_add_at(ar1, e1, index);\\n    cc_array_sized_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_zip_iter_replace(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    cc_array_sized_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_sized_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_sized_zip_iter_index(CC_ArraySizedZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_sized_struct_size()\\n{\\n    return sizeof(CC_ArraySized);\\n}\", \"embeddings\": [-0.006457671523094177, 0.03325735405087471, 0.03357017785310745, 0.10975445806980133, 0.17828580737113953, -0.21375146508216858, 0.07375208288431168, 0.3236292600631714, 0.0610613077878952, -0.19099238514900208, -0.02542714774608612, -0.15169134736061096, -0.010032696649432182, 0.12905316054821014, -0.03621751070022583, 0.03593284264206886, 0.046798162162303925, 0.03345263749361038, 0.07219454646110535, -0.08999422937631607, -0.18375854194164276, 0.04114937037229538, 0.19643700122833252, 0.10864441841840744, 0.16363704204559326, 0.0220426544547081, 0.2638610005378723, 0.15380500257015228, 0.1749308556318283, -0.07939165830612183, 0.031876154243946075, -0.01590556651353836, 0.07850144058465958, -0.13918328285217285, 0.03542177006602287, 0.03543137013912201, 0.06411977857351303, 0.059666261076927185, 0.01415619719773531, 0.04047198221087456, -0.14399603009223938, 0.00789379607886076, 0.1329261064529419, 0.20942480862140656, 0.03146611899137497, 0.009206339716911316, -0.01199059933423996, 0.12362772226333618, -0.09168212115764618, 0.045653656125068665, 0.08200707286596298, 0.0473480150103569, -0.04008699953556061, -0.010366473346948624, -0.09438057243824005, -0.008796736598014832, 0.04541929438710213, 0.3162510395050049, 0.04520038142800331, -0.042716287076473236, -0.07851894199848175, 0.05993597209453583, -0.11458741128444672, 0.10242629051208496, 0.18016467988491058, -0.006872981786727905, -0.08700427412986755, -0.1627567857503891, -0.048611368983983994, -0.016951654106378555, 0.1426500678062439, 0.0648103654384613, 0.08858741819858551, -0.23598085343837738, -0.10755756497383118, -0.07488059997558594, 0.0972084254026413, 0.5578659772872925, -0.033053673803806305, 0.13013023138046265, 0.2534935474395752, -0.08817771077156067, -0.031029611825942993, 0.09703925251960754, 0.08427124470472336, -0.01205061748623848, -0.11857060343027115, 0.12093544006347656, 0.08555137366056442, 0.1466880887746811, 0.13015326857566833, 0.1391664743423462, -0.06395887583494186, 0.01175614446401596, 0.023388022556900978, -0.039953190833330154, 0.07082119584083557, -0.3819486200809479, 0.04293793439865112, 0.3042137324810028, 0.01056366041302681, -0.05047531798481941, -0.15625223517417908, -0.00895673781633377, -0.002161674201488495, 0.02579251304268837, 0.0758519321680069, 0.13206897675991058, 0.01967167854309082, -0.03505782037973404, 0.07201157510280609, 0.1188574954867363, 0.04710279405117035, 0.07243435084819794, 0.07622428983449936, -0.05700092762708664, 0.06512430310249329, -0.01824643462896347, 0.12962910532951355, -0.07403246313333511, 0.19943061470985413, -0.00912272185087204, -0.05521606653928757, -0.0010407641530036926, 0.040385421365499496, 0.03260723128914833, 0.005989342927932739, -0.1764204502105713, 0.07493066787719727, 0.07709168642759323, -0.039859481155872345, -0.12351372092962265, -0.014740295708179474, 0.04617577791213989, 0.13010042905807495, -0.042978595942258835, -0.008416108787059784, 0.07258628308773041, 0.0036087557673454285, -0.010141320526599884, -0.08737228065729141, 0.10762928426265717, 0.2875560522079468, 0.019845567643642426, 0.2373388111591339, -0.13352809846401215, 0.07667168229818344, 0.11768762767314911, -0.2607516050338745, -0.1633819341659546, 0.040043704211711884, -0.08765013515949249, 0.012905589304864407, 0.024669354781508446, -0.18163849413394928, 0.7486236691474915, 0.11739711463451385, -0.09283556789159775, -0.08304891735315323, -0.030717454850673676, 0.07720454782247543, -0.2582128345966339, -0.042015671730041504, 0.03439599648118019, 0.05453048646450043, 0.09456352144479752, 0.04110077768564224, 0.08406005799770355, 0.16775844991207123, -0.010118294507265091, 0.04673518240451813, -0.052431561052799225, -0.11683845520019531, 0.17747318744659424, 0.0661027655005455, -0.051076002418994904, -0.16162414848804474, 0.06763901561498642, -0.09772787988185883, 0.06055370718240738, -0.04829401522874832, 0.04614528641104698, -0.10645967721939087, -0.007341399788856506, 0.028409641236066818, 0.037670303136110306, 0.01521451398730278, -0.1299499124288559, 0.06944212317466736, 0.01688908040523529, -0.09091269969940186, 0.09098362177610397, 0.14791123569011688, 0.008855439722537994, -0.08867941051721573, 0.04630220681428909, -0.13607251644134521, -0.05927920341491699, 0.14634358882904053, -0.10104963183403015, 0.02588033676147461, -0.12134091556072235, 0.2396976351737976, -0.059245187789201736, 0.14593207836151123, 0.0926288589835167, -0.13733990490436554, 0.07111377269029617, -0.04307558760046959, -0.047146402299404144, -0.028825048357248306, 0.14368048310279846, 0.04408201575279236, -0.0017319917678833008, -0.11486972868442535, -0.07350713759660721, -0.007660511881113052, 0.07631294429302216, -0.02364777773618698, -0.0802573561668396, 0.12356974929571152, 0.16462001204490662, -0.06541693955659866, -0.08339071273803711, -0.13704420626163483, 0.18714100122451782, 0.17966684699058533, 0.025304723531007767, -0.012237701565027237, 0.06793771684169769, 0.14250987768173218, 0.2356710135936737, -0.17441438138484955, 0.13831712305545807, 0.09563986957073212, -0.25275933742523193, -0.024488039314746857, 0.05580219626426697, -0.04356100410223007, -0.1536695659160614, -0.038476623594760895, 0.09991371631622314, 0.13085900247097015, 0.2479766607284546, 0.07959580421447754, -0.0487661138176918, -0.18066872656345367, 0.04332102835178375, -0.053624533116817474, 0.0224170982837677, -0.061173319816589355, -0.05042754486203194, 0.05053296312689781, -0.07586400210857391, -0.136623352766037, -0.034556854516267776, -0.15329183638095856, 0.12030012905597687, 0.11753641068935394, 0.21006974577903748, -0.014332346618175507, -0.12290532886981964, -0.01904233545064926, -0.06370709836483002, -0.028330961242318153, -0.41409555077552795, -0.05673322081565857, 0.094172902405262, 0.0294547937810421, -0.05241023004055023, 0.04859573766589165, -0.04057648777961731, 0.24931693077087402, 0.12774913012981415, 0.07973306626081467, 0.030580028891563416, 0.05083806812763214, 0.045177776366472244, -0.08473127335309982, -0.06587856262922287, -0.06040818616747856, 0.03418262302875519, -0.11333535611629486, 0.08834156394004822, 0.027158252894878387, -0.03491729125380516, -0.013085950165987015, -0.007069071754813194, 0.09161783754825592, 0.11497265845537186, 0.05749645456671715, 0.04673054814338684, 0.16219021379947662, 0.12149600684642792, 0.004863161593675613, 0.11914230138063431, 0.21340860426425934, -0.12932991981506348, -0.019426271319389343, -0.21618366241455078, 0.04943426698446274, -0.13637010753154755, 0.023248635232448578, -0.1082409918308258, 0.3703448474407196, -0.05361069366335869, 0.025776419788599014, 0.050168413668870926, 0.3058423399925232, -0.0018048249185085297, -0.011325766332447529, 0.07104433327913284, -0.14549873769283295, 0.19924676418304443, -0.17418119311332703, -0.014369811862707138, -0.05554909259080887, -0.024681467562913895, 0.07349948585033417, -0.035208314657211304, -0.09673021733760834, 0.08427344262599945, 0.15267860889434814, 0.09355860948562622, -0.019269246608018875, 0.15157514810562134, 0.11464038491249084, -0.031598564237356186, -0.12429577857255936, 0.6758176684379578, -0.5991321206092834, 0.09941151738166809, -0.21600711345672607, 0.27463260293006897, 0.026736851781606674, 0.21300186216831207, -0.07867089658975601, 0.07751554995775223, 0.10631126165390015, 0.10471794009208679, -0.12643271684646606, 0.007208176888525486, -0.07082703709602356, 0.22270415723323822, 0.03130250796675682, 0.14022418856620789, 0.1962783932685852, -0.0173521526157856, 0.09088979661464691, -0.09332356601953506, -0.14715442061424255, 0.1011437475681305, 0.0649530291557312, -0.17152948677539825, 0.10125331580638885, 0.2598871886730194, -0.07825664430856705, -0.11141026020050049, 0.06719110906124115, 0.09597828984260559, 0.15343667566776276, -0.15004122257232666, 0.15066608786582947, -0.05567574501037598, 0.3012149930000305, -0.32249611616134644, -0.2173900306224823, 0.04011944681406021, -0.031117696315050125, 0.05930880829691887, 0.06292998790740967, 0.2767697870731354, 0.1649433672428131, -0.14791715145111084, 0.06381859630346298, -0.00028042495250701904, -0.09810946881771088, -0.023157715797424316, -0.04145359992980957, 0.1241922527551651, 0.07044254243373871, 0.09526075422763824, 0.07870757579803467, 0.005101017653942108, 0.06180484965443611, -0.14419373869895935, 0.21854054927825928, 0.09920619428157806, 0.19108568131923676, -0.10489203035831451, 0.03670325502753258, -0.13097822666168213, 0.04579423367977142, 0.05045105144381523, 0.032203227281570435, 0.09013500809669495, -0.10130460560321808, 0.10812494903802872, -0.10056684166193008, -0.051672350615262985, 0.10997046530246735, 0.13417716324329376, -0.008299451321363449, 0.14955082535743713, 0.13149064779281616, 0.11673953384160995, 0.044250115752220154, -0.058602474629879, -0.12119121849536896, -0.1973423957824707, 0.06603638827800751, 0.04900045692920685, 0.07670705765485764, 0.028827538713812828, 0.043878424912691116, -0.10004174709320068, 0.0044163428246974945, -0.20936574041843414, -0.07300423830747604, 0.19985783100128174, 0.16409924626350403, 0.10953204333782196, -0.06602080911397934, -0.06152341514825821, -0.06226338446140289, -0.05303031951189041, -0.06039425730705261, -0.09100480377674103, 0.012966271489858627, -0.13119246065616608, 0.007946256548166275, 0.2694079279899597, 0.06309057772159576, 0.10061759501695633, 0.1384986788034439, -0.1138094812631607, -0.08940094709396362, 0.0026602037250995636, -0.029356013983488083, 0.08238990604877472, -0.04210766777396202, 0.028872959315776825, 0.058565691113471985, 0.10333877801895142, 0.0005082432180643082, -0.12457694858312607, 0.3126090466976166, 0.07376089692115784, -0.06201266124844551, 0.06085725128650665, -0.17643462121486664, 0.042642995715141296, -0.059749577194452286, -0.5006133317947388, 0.0397307425737381, 0.20722483098506927, 0.09899221360683441, 0.03238735347986221, 0.07308146357536316, 0.010373950004577637, 0.02811633236706257, 0.032726310193538666, -0.009058568626642227, -0.1275208443403244, 0.015881605446338654, -0.04907641559839249, 0.19332456588745117, 0.008579494431614876, 0.12040968239307404, 0.16952741146087646, 0.039010755717754364, 0.18414823710918427, -0.004795411601662636, -0.21035653352737427, 0.02812185138463974, 0.03090636059641838, -0.05427088961005211, -0.14233995974063873, 0.12385813891887665, -0.1875157356262207, -0.07479210197925568, 0.09716052561998367, 0.12536762654781342, -0.028540797531604767, -0.02489473484456539, -0.08099747449159622, 0.25186145305633545, 0.05961954966187477, -0.11741389334201813, 0.010698191821575165, -0.07488925755023956, 0.11703592538833618, 0.07865557074546814, 0.08610150218009949, 0.2686185836791992, 0.11411470919847488, 0.10213722288608551, 0.11082892119884491, 0.15747064352035522, -0.04923988878726959, 0.07346832752227783, 0.10844125598669052, 0.12019823491573334, -0.11132469773292542, -0.04859084263443947, -0.09673763066530228, -0.019355982542037964, 0.11559615284204483, 0.11091622710227966, -0.1419225037097931, -0.05234731733798981, -0.03293142467737198, 0.10284525156021118, -0.004954751580953598, 0.041920971125364304, 0.03243963047862053, 0.06619009375572205, 0.09540044516324997, -0.02097681164741516, 0.15432420372962952, -0.1400320827960968, -0.08561985194683075, -0.04982074722647667, 0.05080742761492729, -0.05888354778289795, 0.07210034132003784, 0.08701998740434647, -0.04380859434604645, 0.08521314710378647, -0.003087356686592102, 0.0538017563521862, 0.018796583637595177, 0.04728006571531296, 0.12384621053934097, -0.09847553074359894, 0.01867680810391903, 0.06700947880744934, 0.02077493816614151, 0.2118500918149948, -0.15372702479362488, -0.14008113741874695, -0.09736437350511551, 0.20354031026363373, -0.02647383138537407, 0.16929525136947632, 0.016837144270539284, 0.16432663798332214, 0.06650897115468979, -0.03533361852169037, 0.013036668300628662, -0.17847491800785065, -0.7948492169380188, -0.024179618805646896, 0.07903230935335159, -0.03367285802960396, 0.06807177513837814, 0.10079406201839447, 0.09366355836391449, 0.0797186866402626, 0.07418138533830643, 0.023329827934503555, 0.0020610466599464417, 0.1696663647890091, 0.17525920271873474, -0.19826681911945343, -0.023828040808439255, 0.07132703810930252, 0.09402651339769363, -0.16193212568759918, 0.1868632733821869, -0.012261451222002506, -0.14373087882995605, 0.054849617183208466, 0.18024834990501404, 0.045324549078941345, 0.08765987306833267, 0.2233065813779831, 0.04108890891075134, 0.1621834635734558, -0.050012409687042236, 0.024149393662810326, 0.2629784643650055, 0.12291055917739868, -0.2128228098154068, 0.03975037857890129, 0.10394757241010666, 0.15859472751617432, 0.16785064339637756, 13.791592597961426, -0.10945858061313629, 0.1533435732126236, -0.08446594327688217, -0.10856419056653976, -0.059156641364097595, -0.08181799203157425, 0.12175460904836655, -0.052909642457962036, 0.002217620611190796, 0.04756394773721695, -0.0555010586977005, -0.010664844885468483, 0.04800825193524361, -0.014690369367599487, -0.022439301013946533, -0.012004334479570389, -0.04892399162054062, 0.09732326120138168, 0.030054282397031784, -0.17719823122024536, -0.051058411598205566, 0.05179327353835106, -0.2620682120323181, -0.011639576405286789, -0.12717100977897644, 0.12523455917835236, 0.0660662055015564, 0.05636627972126007, 0.07064743340015411, 0.21863386034965515, 0.12469317018985748, 0.10765160620212555, 0.0007880702614784241, -0.000742889940738678, -0.06554729491472244, -0.3564373254776001, -0.10867919772863388, 0.07023045420646667, -0.07352142035961151, -0.038769930601119995, 0.013293124735355377, 0.150068998336792, -0.04371083527803421, 0.06207399070262909, 0.05953294038772583, -0.18921653926372528, 0.09827699512243271, -0.04938087612390518, -0.05938602238893509, 0.14023062586784363, 0.1273101568222046, 0.21758706867694855, 0.00010133907198905945, -0.09543821960687637, -0.20684519410133362, 0.2173735350370407, 0.03204154968261719, -0.032585516571998596, 0.26434558629989624, -0.03706049174070358, -0.056974925100803375, -0.04979751631617546, -0.07455958425998688, 0.035426296293735504, 0.04121597856283188, 0.15212610363960266, 0.08532117307186127, 0.0690218135714531, 0.11376097798347473, 0.14097464084625244, -0.11585120111703873, 0.0765356570482254, 0.024866091087460518, -0.09837450087070465, 0.1061595156788826, -0.0055258795619010925, -0.022040318697690964, 0.052494898438453674, -0.14284579455852509, -0.0004488453269004822, 0.05080537497997284, -0.12528587877750397, -0.12665319442749023, -0.17484501004219055, 0.0878526121377945, -0.11601249873638153, 0.1957421898841858, 0.19324539601802826, 0.08107537031173706, -0.09527422487735748, 0.03793448209762573, -0.0573236346244812, -0.06087139993906021, 0.17728129029273987, -0.04180755466222763, -0.07569759339094162, -0.12870584428310394, 0.06375263631343842, 0.02538607269525528, -0.06958845257759094, -0.0778382271528244, -0.022172145545482635, 0.05716755986213684, -0.07845477759838104, -0.02415495365858078, 0.021878376603126526, 0.04267903417348862, -0.07098321616649628, 0.045969970524311066, 0.06916815042495728, 0.11929309368133545, 0.05691248178482056, -0.2003706842660904, -0.05853971093893051, -0.005704335868358612, 0.041925013065338135, 0.0038959458470344543, 0.1710948646068573, 0.019679592922329903, 0.13029229640960693, 0.08631128072738647, -0.10963276028633118, -0.07644772529602051, 0.06397971510887146, -0.1316727101802826, 0.020585233345627785, 0.18032918870449066, 0.10774391144514084, 0.010364584624767303, 0.16516929864883423, -0.08593416959047318, 0.268856406211853, 0.1753636747598648, -0.033313773572444916, 0.018244318664073944, -0.02314727008342743, 0.07436711341142654, 0.10271749645471573, 0.18898820877075195, 0.07270151376724243, -0.0005115866661071777, 0.19495445489883423, -0.1318899393081665, -0.07493095844984055, 0.300991952419281, 0.13477395474910736, 0.027847127988934517, 0.028670310974121094, 0.16243724524974823, 0.10025419294834137, 0.141566663980484, -0.006434246897697449, -0.20705705881118774, -0.09800264239311218, -0.14810460805892944, -0.11562718451023102, 0.032648831605911255, -0.050624288618564606, -0.07066363841295242, 0.2634120583534241, -0.4377579391002655, 0.024724574759602547, -0.2629282772541046, -0.10732463002204895, 0.02201971411705017, 0.09211011230945587, 0.10699648410081863, 0.08786804974079132, -0.11551078408956528, 0.11024905741214752, 0.09796418249607086, -0.15099270641803741, 0.044698312878608704, -0.014506347477436066, 0.049673501402139664, 0.20419923961162567, -0.3456065058708191, -0.16343924403190613, 0.022189699113368988]}"
"{\"sha\": \"8490a88f377d8fed802e4f3b2d1d87a0d6cb81b2\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/sized/cc_array_sized.c\", \"func_name\": \"cc_array_sized_zip_iter_next\", \"original_string\": \"enum cc_stat cc_array_sized_zip_iter_next(CC_ArraySizedZipIter *iter, uint8_t **out1, uint8_t **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size) {\\n        return CC_ITER_END;\\n    }\\n    *out1 = BUF_ADDR(iter->ar1, iter->index);\\n    *out2 = BUF_ADDR(iter->ar2, iter->index);\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\", \"code_tokens\": [\"enum\", \"cc_stat\", \"cc_array_sized_zip_iter_next\", \"(\", \"CC_ArraySizedZipIter\", \"*\", \"iter\", \",\", \"uint8_t\", \"*\", \"*\", \"out1\", \",\", \"uint8_t\", \"*\", \"*\", \"out2\", \")\", \"{\", \"if\", \"(\", \"iter\", \"->\", \"index\", \">=\", \"iter\", \"->\", \"ar1\", \"->\", \"size\", \"||\", \"iter\", \"->\", \"index\", \">=\", \"iter\", \"->\", \"ar2\", \"->\", \"size\", \")\", \"{\", \"return\", \"CC_ITER_END\", \";\", \"}\", \"*\", \"out1\", \"=\", \"BUF_ADDR\", \"(\", \"iter\", \"->\", \"ar1\", \",\", \"iter\", \"->\", \"index\", \")\", \";\", \"*\", \"out2\", \"=\", \"BUF_ADDR\", \"(\", \"iter\", \"->\", \"ar2\", \",\", \"iter\", \"->\", \"index\", \")\", \";\", \"iter\", \"->\", \"index\", \"++\", \";\", \"iter\", \"->\", \"last_removed\", \"=\", \"false\", \";\", \"return\", \"CC_OK\", \";\", \"}\"], \"docstring\": \"/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Outputs\", \"the\", \"next\", \"element\", \"pair\", \"in\", \"the\", \"sequence\", \"and\", \"advances\", \"the\", \"iterator\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"iter\", \"iterator\", \"that\", \"is\", \"being\", \"advanced\", \"*\", \"@param\", \"[\", \"out\", \"]\", \"out1\", \"output\", \"of\", \"the\", \"first\", \"array\", \"element\", \"*\", \"@param\", \"[\", \"out\", \"]\", \"out2\", \"output\", \"of\", \"the\", \"second\", \"array\", \"element\", \"*\", \"*\", \"@return\", \"CC_OK\", \"if\", \"a\", \"next\", \"element\", \"pair\", \"is\", \"returned\", \"or\", \"CC_ITER_END\", \"if\", \"the\", \"end\", \"of\", \"one\", \"*\", \"of\", \"the\", \"arrays\", \"has\", \"been\", \"reached\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2024 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n\\n#include \\\"sized/cc_array_sized.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\n#define INDEX(a, i) a->data_length * i\\n#define BUF_ADDR(a, i) &a->buffer[a->data_length * i]\\n\\n\\nstruct cc_array_sized_s {\\n    size_t   data_length;\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    uint8_t *buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[in] Size of the array element in bytes\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new(size_t element_size, CC_ArraySized **out)\\n{\\n    CC_ArraySizedConf c;\\n    cc_array_sized_conf_init(&c);\\n    return cc_array_sized_new_conf(element_size, &c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_ArraySized based on the specified CC_ArraySizedConf struct \\n * and returns a status code.\\n *\\n * The CC_ArraySized is allocated using the allocators specified in the CC_ArraySizedConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArraySizedConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] element_size the size of the data being stored in bytes\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new_conf(\\n    size_t element_size, \\n    CC_ArraySizedConf const * const conf, \\n    CC_ArraySized **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_ArraySized *ar = conf->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    uint8_t *buff = conf->mem_alloc(conf->capacity * element_size);\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->data_length = element_size;\\n    ar->buffer      = buff;\\n    ar->exp_factor  = ex;\\n    ar->capacity    = conf->capacity;\\n    ar->mem_alloc   = conf->mem_alloc;\\n    ar->mem_calloc  = conf->mem_calloc;\\n    ar->mem_free    = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArraySizedConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArraySizedConf structure that is being initialized\\n */\\nvoid cc_array_sized_conf_init(CC_ArraySizedConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_ArraySized structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_sized_destroy(CC_ArraySized *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n\\n/**\\n * Adds a new element to the CC_ArraySized. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_ArraySized.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add(CC_ArraySized *ar, uint8_t *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    memcpy(BUF_ADDR(ar, ar->size), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add_at(CC_ArraySized *ar, uint8_t *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_sized_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * ar->data_length;\\n\\n    memmove(BUF_ADDR(ar, (index + 1)),\\n            BUF_ADDR(ar, index),\\n            shift);\\n\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_ArraySized.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_replace_at(CC_ArraySized *ar, uint8_t *element, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n* Swaps the values at the specified indices.\\n*\\n* @param[in] ar array whose elements are being swapped\\n* @param[in] index1 first position\\n* @param[in] index2 second position\\n* \\n* @return CC_OK if the operation was successful, or CC_ERR_OUT_OF_RANGE if \\n* one of the indices was out of range.\\n*/\\nenum cc_stat cc_array_sized_swap_at(CC_ArraySized *ar, size_t index1, size_t index2)\\n{\\n    if (index1 >= ar->size || index2 >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n\\n    for (size_t i = 0; i < ar->data_length; i++) {\\n        uint8_t tmp = ar->buffer[INDEX(ar, index1 + i)];\\n        ar->buffer[INDEX(ar, index1 + i)] = ar->buffer[INDEX(ar, index2 + i)];\\n        ar->buffer[INDEX(ar, index2 + i)] = tmp;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_ArraySized if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_sized_remove(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_sized_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n \\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_remove_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_sized_remove_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    return cc_array_sized_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_sized_remove_all(CC_ArraySized *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Copies an CC_ArraySized element from the specified index to the out pointer.\\n * The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] source index of the array element\\n * @param[out] destination address\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_sized_get_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_sized_get_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n    return cc_array_sized_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n* Returns the pointer to the element at the specified index\\n*/\\nenum cc_stat cc_array_sized_peek(CC_ArraySized* ar, size_t index, uint8_t** out)\\n{\\n    if (index > ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    *out = BUF_ADDR(ar, index);\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst uint8_t * const* cc_array_sized_get_buffer(CC_ArraySized *ar)\\n{\\n    return (const uint8_t* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_ArraySized.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_sized_index_of(CC_ArraySized *ar, uint8_t *element, size_t *index)\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) { \\n            // Mismatching byte, skip to next block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            if (j == ar->data_length - 1) {\\n                *index = i;\\n                return CC_OK;\\n            }\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_ArraySized, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_ArraySized, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's allocators\\n *       and it also inherits the configuration of the original CC_ArraySized.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_sized_subarray(CC_ArraySized *ar, size_t b, size_t e, CC_ArraySized **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_ArraySized *sub_ar = ar->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * ar->data_length))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc   = ar->mem_alloc;\\n    sub_ar->mem_calloc  = ar->mem_calloc;\\n    sub_ar->mem_free    = ar->mem_free;\\n    sub_ar->size        = e - b + 1;\\n    sub_ar->capacity    = sub_ar->size;\\n    sub_ar->data_length = ar->data_length;\\n\\n    memcpy(sub_ar->buffer,\\n           BUF_ADDR(ar, b),\\n           sub_ar->size * ar->data_length);\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a copy of the specified CC_ArraySized. \\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's\\n *       allocators and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_sized_copy(CC_ArraySized *ar, CC_ArraySized **out)\\n{\\n    CC_ArraySized *copy = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->data_length = ar->data_length;\\n    copy->exp_factor  = ar->exp_factor;\\n    copy->size        = ar->size;\\n    copy->capacity    = ar->capacity;\\n    copy->mem_alloc   = ar->mem_alloc;\\n    copy->mem_calloc  = ar->mem_calloc;\\n    copy->mem_free    = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * ar->data_length);\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_ArraySized was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_ArraySized is empty.\\n */\\nenum cc_stat cc_array_sized_filter_mut(CC_ArraySized *ar, bool (*pred) (const uint8_t*))\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(BUF_ADDR(ar, i))) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * ar->data_length;\\n                memmove(BUF_ADDR(ar, (i + 1)),\\n                        BUF_ADDR(ar, (i + 1 + rm)),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * ar->data_length;\\n        memmove(BUF_ADDR(ar, 0),\\n                BUF_ADDR(ar, rm),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by creating a new CC_ArraySized that contains all elements\\n * from the original CC_ArraySized that return true on pred(element) without modifying \\n * the original CC_ArraySized.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_sized_filter(CC_ArraySized *ar, bool (*pred) (const uint8_t*), CC_ArraySized **out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    CC_ArraySized *filtered = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!filtered) {\\n        return CC_ERR_ALLOC;\\n    }\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->data_length = ar->data_length;\\n    filtered->exp_factor  = ar->exp_factor;\\n    filtered->size        = 0;\\n    filtered->capacity    = ar->capacity;\\n    filtered->mem_alloc   = ar->mem_alloc;\\n    filtered->mem_calloc  = ar->mem_calloc;\\n    filtered->mem_free    = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(BUF_ADDR(ar, i))) {\\n            memcpy(BUF_ADDR(filtered, f++), \\n                   BUF_ADDR(ar, i),\\n                   ar->data_length);\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_sized_reverse(CC_ArraySized *ar, uint8_t *tmp)\\n{\\n    if (ar->size == 0) {\\n        return;\\n    }\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        memcpy(tmp, BUF_ADDR(ar, i), ar->data_length);\\n        memcpy(BUF_ADDR(ar, i), BUF_ADDR(ar, j), ar->data_length);\\n        memcpy(BUF_ADDR(ar, j), tmp, ar->data_length);\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_ArraySized, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_sized_trim_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->size == ar->capacity) {\\n        return CC_OK;\\n    }\\n    uint8_t *new_buff = ar->mem_calloc(ar->size, ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * ar->data_length);\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_ArraySized.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_sized_contains(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t o = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) {\\n            // Mismatching byte, skip block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            // Last byte is equal, match found\\n            if (j == ar->data_length - 1) {\\n                o++;\\n            }\\n        }\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_ArraySized. The size of the array is the\\n * number of elements contained within the CC_ArraySized.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_ArraySized.\\n */\\nsize_t cc_array_sized_size(CC_ArraySized *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_ArraySized. The capacity of the CC_ArraySized is\\n * the maximum number of elements an CC_ArraySized can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_ArraySized.\\n */\\nsize_t cc_array_sized_capacity(CC_ArraySized *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sized_sort(CC_ArraySized *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, ar->data_length, cmp);\\n}\\n\\n/**\\n * Expands the CC_ArraySized capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS) {\\n        return CC_ERR_MAX_CAPACITY;\\n    }\\n\\n    size_t new_capacity = (size_t) (ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity) {\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    } else {\\n        ar->capacity = new_capacity;\\n    }\\n    uint8_t *new_buff = ar->mem_alloc(ar->capacity * ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    memcpy(new_buff, ar->buffer, ar->size * ar->data_length);\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_sized_map(CC_ArraySized *ar, void (*fn) (uint8_t *e))\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        fn(BUF_ADDR(ar, i));\\n    }\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_sized_reduce(CC_ArraySized *ar, void (*fn) (uint8_t*, uint8_t*, uint8_t*), uint8_t *result)\\n{\\n    if (ar->size == 1) {\\n        fn(BUF_ADDR(ar, 0), NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1) {\\n        fn(BUF_ADDR(ar, 0), BUF_ADDR(ar, 1), result);\\n    }\\n    for (size_t i = 2; i < ar->size; i++) {\\n        fn(result, BUF_ADDR(ar, i), result);\\n    }\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_sized_iter_init(CC_ArraySizedIter *iter, CC_ArraySized *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the reference of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_sized_iter_next(CC_ArraySizedIter *iter, uint8_t **out)\\n{\\n    if (iter->index >= iter->ar->size) {\\n        return CC_ITER_END;\\n    }\\n    *out = BUF_ADDR(iter->ar, iter->index);\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_sized_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_sized_iter_remove(CC_ArraySizedIter *iter, uint8_t *out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_sized_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK) {\\n            iter->last_removed = true;\\n        }\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_ArraySized after the last returned element by\\n * <code>cc_array_sized_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_iter_add(CC_ArraySizedIter *iter, uint8_t *element)\\n{\\n    return cc_array_sized_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_sized_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_iter_replace(CC_ArraySizedIter *iter, uint8_t *element, uint8_t *out)\\n{\\n    return cc_array_sized_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_sized_iter_index(CC_ArraySizedIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_sized_zip_iter_init(CC_ArraySizedZipIter *iter, CC_ArraySized *ar1, CC_ArraySized *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_sized_zip_iter_next(CC_ArraySizedZipIter *iter, uint8_t **out1, uint8_t **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size) {\\n        return CC_ITER_END;\\n    }\\n    *out1 = BUF_ADDR(iter->ar1, iter->index);\\n    *out2 = BUF_ADDR(iter->ar2, iter->index);\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_sized_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_remove(CC_ArraySizedZipIter *iter, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (!iter->last_removed) {\\n        cc_array_sized_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_sized_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_sized_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_sized_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_add(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_ArraySized  *ar1  = iter->ar1;\\n    CC_ArraySized  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n        (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK))) {\\n        return CC_ERR_ALLOC;\\n    }\\n    cc_array_sized_add_at(ar1, e1, index);\\n    cc_array_sized_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_zip_iter_replace(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    cc_array_sized_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_sized_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_sized_zip_iter_index(CC_ArraySizedZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_sized_struct_size()\\n{\\n    return sizeof(CC_ArraySized);\\n}\", \"embeddings\": [-0.004940852522850037, 0.0652625560760498, 0.05012383311986923, 0.11296312510967255, 0.3287227153778076, -0.18265430629253387, 0.1244177520275116, 0.3720563054084778, 0.07027273625135422, -0.2607511281967163, -0.00470617413520813, -0.12146816402673721, 0.009825564920902252, 0.06869116425514221, -0.03359026461839676, 0.0279746875166893, 0.055654287338256836, -0.00883675366640091, 0.0669294074177742, -0.3132426142692566, -0.22818240523338318, 0.08430834859609604, 0.20857064425945282, 0.12741628289222717, 0.22238846123218536, 0.09968301653862, 0.260405957698822, 0.1044687032699585, 0.3290170133113861, -0.1683182567358017, 0.035315848886966705, -0.07768858224153519, 0.059615299105644226, -0.19305115938186646, 0.04070432484149933, -0.0019311793148517609, 0.015040088444948196, 0.047518156468868256, -0.017991680651903152, -0.01980733498930931, -0.18317528069019318, 0.023163888603448868, 0.0769733190536499, 0.18815381824970245, 0.07276298105716705, 0.0028727389872074127, 0.03925294801592827, 0.18404895067214966, -0.08738411962985992, 0.06310400366783142, 0.07739749550819397, -0.08169887959957123, -0.01956704817712307, -0.08820881694555283, -0.06555940210819244, -0.035370275378227234, 0.02334093488752842, 0.40181469917297363, -0.02670522779226303, -0.034518495202064514, -0.047567643225193024, -0.08099918067455292, -0.16604425013065338, 0.19664838910102844, 0.1300385296344757, 0.025585277006030083, -0.11632522940635681, -0.24697408080101013, -0.0458214245736599, -0.004960574209690094, 0.10869148373603821, 0.0316670760512352, 0.12226609140634537, -0.1775919646024704, -0.13196131587028503, -0.049918919801712036, 0.04347196966409683, 0.5432651042938232, -0.010168766602873802, 0.18332189321517944, 0.20941823720932007, -0.0674811452627182, 0.08901908248662949, 0.15839946269989014, 0.11658447235822678, 0.04121609032154083, -0.08449593931436539, 0.08867157250642776, 0.01762031950056553, 0.15887132287025452, 0.08512391895055771, 0.15744152665138245, -0.08974631875753403, -0.07390433549880981, -0.012651704251766205, 0.04983721300959587, 0.07348493486642838, -0.17131957411766052, 0.07568226009607315, 0.383394330739975, -0.053805578500032425, -0.07022595405578613, -0.24419432878494263, -0.07898169755935669, -0.041604600846767426, 0.012533217668533325, -0.06173478811979294, 0.08963063359260559, 0.06617173552513123, -0.026590831577777863, 0.1329265534877777, 0.04044816642999649, -0.022230247035622597, 0.041736386716365814, -0.0006994642317295074, -0.07352512329816818, 0.08789245784282684, -0.049705080687999725, 0.19390781223773956, -0.0884755328297615, 0.16234540939331055, -0.02531641721725464, -0.027519024908542633, -0.060037434101104736, -0.07239659130573273, 0.08847953379154205, -0.038018323481082916, -0.24697014689445496, 0.13022901117801666, 0.10238126665353775, -0.03595585376024246, -0.07056009024381638, -0.028209984302520752, -0.017026588320732117, 0.09774274379014969, 0.011575862765312195, 0.04155612736940384, 0.038225531578063965, 0.04141294211149216, -0.018398411571979523, -0.02955201268196106, 0.04130500555038452, 0.2708095610141754, -0.027055975049734116, 0.23144540190696716, -0.14272448420524597, 0.1425127536058426, 0.124513640999794, -0.3024042546749115, -0.24722272157669067, 0.033986978232860565, -0.09468169510364532, 0.007970042526721954, -0.005026478320360184, -0.18110255897045135, 0.853641927242279, 0.1265721619129181, -0.10562475770711899, -0.03714492917060852, -0.005736388266086578, 0.05090286582708359, -0.29815447330474854, -0.05316619575023651, 0.1378071904182434, 0.051519665867090225, 0.13797548413276672, 0.07924697548151016, 0.07557882368564606, 0.1511128544807434, 0.023684440180659294, 0.0896025076508522, -0.11299531161785126, -0.07435149699449539, 0.17401690781116486, 0.03838755935430527, -0.08461501449346542, -0.15103299915790558, 0.04625033587217331, -0.06390641629695892, 0.03701159358024597, -0.09348645806312561, 0.02399367094039917, -0.1883351355791092, -0.01999182254076004, -0.05397137999534607, 0.015881875529885292, 0.026186320930719376, -0.025109369307756424, 0.04464328661561012, -0.006976522505283356, 0.007412165403366089, 0.038989000022411346, 0.12867209315299988, -0.10470496118068695, -0.07146825641393661, 0.02380315214395523, -0.09789872914552689, -0.10413779318332672, 0.19056972861289978, -0.03342070430517197, 0.005848829634487629, -0.15217295289039612, 0.2851676344871521, -0.112720787525177, 0.10872510820627213, 0.13252152502536774, -0.19377760589122772, 0.0047638267278671265, -0.01904650405049324, -0.12158896774053574, -0.06082696095108986, 0.08622743934392929, 0.07155664265155792, 0.04373665526509285, -0.08096720278263092, -0.09702981263399124, 0.10579044371843338, 0.09931442141532898, 0.08238595724105835, -0.1224643811583519, 0.120985247194767, 0.23352974653244019, -0.04831405729055405, -0.08412273228168488, -0.13052648305892944, 0.19687408208847046, 0.19114220142364502, 0.06484778970479965, -0.02368592470884323, 0.10416979342699051, 0.17953529953956604, 0.2554619312286377, -0.2165004163980484, 0.11241210997104645, 0.032242823392152786, -0.21336904168128967, -0.04438807815313339, 0.04642011225223541, 0.0058799684047698975, -0.14765313267707825, -0.05021418631076813, 0.1438283920288086, 0.1849101185798645, 0.2840585708618164, 0.007521688938140869, 0.034421470016241074, -0.1815677434206009, 0.025510694831609726, -0.07886070013046265, 0.027381982654333115, -0.053530894219875336, -0.02442123368382454, -0.0031626150012016296, -0.11738546192646027, -0.1501094251871109, -0.03763309493660927, -0.18897157907485962, 0.03270452469587326, 0.07873700559139252, 0.27893155813217163, -0.00231073796749115, -0.10057708621025085, 0.0479167141020298, -0.017342768609523773, -0.07889973372220993, -0.428545206785202, -0.07172852009534836, 0.06489630043506622, 0.04071875661611557, -0.023509763181209564, 0.0800350159406662, -0.09039779752492905, 0.26542797684669495, 0.14151903986930847, 0.061895087361335754, 0.017478466033935547, -0.0024146363139152527, 0.03638328239321709, -0.14030003547668457, -0.033456236124038696, -0.050581131130456924, 0.0454442985355854, -0.14762265980243683, 0.10484793782234192, 0.06142498925328255, -0.006627268623560667, 0.14722083508968353, -0.02479809708893299, 0.05086229741573334, 0.0964263379573822, 0.03580973669886589, 0.04536493122577667, 0.12603068351745605, 0.11361119151115417, 0.05478282645344734, 0.12986691296100616, 0.20716314017772675, -0.12850001454353333, 0.011462770402431488, -0.3143581748008728, 0.10945212841033936, -0.23274163901805878, 0.03335380181670189, -0.02971665933728218, 0.40377071499824524, -0.030443061143159866, 0.052434079349040985, 0.011806156486272812, 0.28371554613113403, 0.025538915768265724, 0.031933918595314026, 0.06621846556663513, -0.15368156135082245, 0.14167168736457825, -0.18061639368534088, 0.0497308224439621, -0.05917918682098389, -0.06902843713760376, 0.11407174915075302, 0.023226283490657806, -0.017727497965097427, 0.11124356836080551, 0.2408224195241928, 0.13818852603435516, -0.057466279715299606, 0.08734647929668427, 0.12386584281921387, -0.022174544632434845, -0.16005977988243103, 0.6519999504089355, -0.5775230526924133, 0.22292479872703552, -0.18155145645141602, 0.3120916187763214, -0.0307217538356781, 0.3289874196052551, -0.07461103051900864, 0.12336152791976929, 0.10794733464717865, 0.10858794301748276, -0.13563412427902222, -0.0670468807220459, -0.16823358833789825, 0.28715118765830994, 0.14022116363048553, 0.11815513670444489, 0.22813904285430908, -0.016676567494869232, 0.12723366916179657, -0.08572670072317123, -0.19018089771270752, 0.19107186794281006, 0.07950455695390701, -0.10614027827978134, 0.12144633382558823, 0.295377641916275, -0.10999155789613724, -0.11379694938659668, 0.020172983407974243, 0.026188362389802933, 0.17303945124149323, -0.16845405101776123, 0.1339123547077179, -0.10150770843029022, 0.318467378616333, -0.455742746591568, -0.38947853446006775, 0.025462189689278603, -0.09217742085456848, 0.054261576384305954, 0.12779366970062256, 0.27844753861427307, 0.18519482016563416, -0.19265788793563843, 0.07611143589019775, -0.05011420324444771, -0.07094346731901169, -0.03314172476530075, 0.00841529667377472, 0.12965992093086243, 0.06900644302368164, 0.035703662782907486, 0.1094917505979538, 0.008549682796001434, 0.058656658977270126, -0.16699844598770142, 0.21197611093521118, 0.1334434151649475, 0.2672012150287628, -0.10289983451366425, 0.09024162590503693, -0.17699840664863586, 0.10189729928970337, -0.02845706045627594, 0.05345822870731354, 0.07100380212068558, -0.09226321429014206, 0.14382359385490417, -0.08805466443300247, -0.09104914963245392, 0.18352475762367249, 0.2415899932384491, -0.044006530195474625, 0.19911229610443115, 0.09486661106348038, 0.0800570473074913, 0.16117073595523834, -0.16166338324546814, -0.16025739908218384, -0.15110993385314941, 0.10089653730392456, 0.03379075974225998, 0.053030408918857574, 0.009966954588890076, 0.16881799697875977, -0.15735234320163727, 0.008951431140303612, -0.3465694189071655, -0.16299381852149963, 0.1574537754058838, 0.19481807947158813, 0.08552022278308868, -0.018379241228103638, -0.17080771923065186, -0.06634197384119034, -0.019656021147966385, -0.04927949607372284, -0.09814424812793732, 0.05022820830345154, -0.15577249228954315, 0.06067220866680145, 0.2514294385910034, 0.11527940630912781, 0.11093829572200775, 0.1073310375213623, -0.07574141025543213, -0.12330597639083862, -0.0013879016041755676, 0.028348753228783607, 0.04463190957903862, -0.06353530287742615, 0.03761748597025871, 0.0490235798060894, 0.12807220220565796, 0.014758026227355003, -0.11918812245130539, 0.4347955286502838, 0.115791916847229, -0.03825676441192627, 0.031680770218372345, -0.19745784997940063, 0.010740332305431366, -0.05438954755663872, -0.22611872851848602, 0.12001270800828934, 0.1830066293478012, 0.06867476552724838, -0.018270201981067657, 0.09487739205360413, 0.042480867356061935, -0.03210093080997467, 0.07824189960956573, -0.07491320371627808, -0.10514802485704422, 0.04286817088723183, -0.06563770025968552, 0.14950862526893616, 0.025991808623075485, 0.22098508477210999, 0.14803805947303772, 0.029676876962184906, 0.18224862217903137, 0.04416694492101669, -0.131557434797287, 0.023969847708940506, -0.021147318184375763, -0.03040146827697754, -0.16697365045547485, 0.07958877831697464, -0.1738007813692093, -0.030959226191043854, 0.14673089981079102, 0.14632976055145264, 0.004982739686965942, 0.0011844243854284286, -0.18958476185798645, 0.2246110588312149, 0.1053798720240593, -0.1227196753025055, -0.0028005801141262054, -0.06859026849269867, 0.1402563452720642, 0.06651465594768524, 0.1101168617606163, 0.260911762714386, 0.17941001057624817, 0.06495393812656403, 0.1404004544019699, 0.3275989294052124, -0.11067962646484375, 0.049511492252349854, 0.09087830781936646, 0.054804183542728424, -0.09066437184810638, -0.11837190389633179, -0.08794358372688293, -0.022296395152807236, 0.10473136603832245, 0.14731445908546448, -0.18894773721694946, -0.011772435158491135, -0.14060142636299133, 0.15607768297195435, -0.020706824958324432, 0.04564735293388367, 0.05892444774508476, 0.018859662115573883, -0.004298817366361618, -0.08167747408151627, 0.2684251666069031, -0.14836004376411438, -0.11564569175243378, -0.09849047660827637, 0.004200829192996025, -0.1114266887307167, 0.054726243019104004, 0.11613084375858307, 0.009534090757369995, 0.0926814004778862, 0.030848702415823936, -0.0315670520067215, 0.051747243851423264, 0.11659552156925201, 0.19509358704090118, -0.12068887054920197, 0.04870198294520378, 0.09892511367797852, 0.05574057623744011, 0.2555524408817291, -0.06968719512224197, -0.21082590520381927, -0.10603071004152298, 0.18225044012069702, -0.03958312049508095, 0.1645093411207199, -0.011210650205612183, 0.1561470925807953, 0.08321242779493332, -0.04687470942735672, -0.009309321641921997, -0.13093005120754242, -0.7676379680633545, -0.046238142997026443, 0.14214615523815155, -0.007226180285215378, 0.0830501988530159, 0.1122380942106247, 0.07746393978595734, 0.07030215859413147, 0.10804165154695511, 0.06406107544898987, 0.012362468987703323, 0.15446904301643372, 0.24416616559028625, -0.11036251485347748, -0.11131113767623901, 0.10054096579551697, 0.09679806232452393, -0.24652107059955597, 0.24969449639320374, -0.019572097808122635, -0.18509837985038757, 0.09871916472911835, 0.3243163228034973, -0.00015873461961746216, 0.06781414151191711, 0.2068118453025818, 0.06668040156364441, 0.2267087996006012, -0.06612569093704224, 0.07562830299139023, 0.28743454813957214, 0.20215044915676117, -0.30559274554252625, 0.0031775981187820435, 0.15429693460464478, 0.15744251012802124, 0.05890452116727829, 14.08210277557373, -0.10281742364168167, 0.26183584332466125, -0.15838992595672607, -0.10080895572900772, -0.049807436764240265, -0.08205018192529678, 0.036449797451496124, -0.01338978111743927, -0.012088969349861145, 0.12854962050914764, -0.06201748549938202, -0.03165590018033981, -0.01301548257470131, -0.06543393433094025, -0.029869675636291504, -0.039316579699516296, -0.12663137912750244, 0.17920702695846558, 0.04959314316511154, -0.21874874830245972, -0.08368290960788727, -0.025491662323474884, -0.38966721296310425, 0.007553938310593367, -0.12764495611190796, 0.15482649207115173, 0.04371640086174011, 0.013268894515931606, 0.08879079669713974, 0.18251970410346985, 0.13123482465744019, 0.12455922365188599, -0.012931331992149353, 0.03618432208895683, -0.04095710441470146, -0.3931633234024048, -0.14952607452869415, 0.08578471094369888, -0.026874959468841553, -0.011326432228088379, 0.026260126382112503, 0.19031862914562225, -0.05516594648361206, 0.10378611087799072, 0.10956113040447235, -0.27079811692237854, 0.11733239889144897, -0.12600886821746826, -0.025248393416404724, 0.2219383716583252, 0.12533330917358398, 0.31674814224243164, -0.0046510472893714905, -0.12710252404212952, -0.21816137433052063, 0.26724016666412354, -0.027508243918418884, -0.08262746036052704, 0.3264239728450775, -0.0003689788281917572, -0.07998137921094894, -0.06352198123931885, 0.010074172168970108, -0.01576864719390869, 0.024372033774852753, 0.09864003211259842, 0.059621185064315796, -0.18455861508846283, 0.11100421100854874, 0.2032991498708725, -0.2190803438425064, 0.1606956422328949, -0.019929930567741394, -0.03840146213769913, 0.11192844808101654, 0.021579422056674957, -0.020979229360818863, 0.050720877945423126, -0.1318533718585968, -0.003150351345539093, 0.03847607970237732, -0.1928797960281372, -0.15302875638008118, -0.3375053405761719, 0.07315878570079803, -0.051409754902124405, 0.1815938949584961, 0.22061830759048462, -0.03047458827495575, -0.04410582408308983, 0.07375656813383102, -0.02403406798839569, -0.17494696378707886, 0.20956841111183167, -0.029547013342380524, -0.08753395825624466, -0.15212620794773102, 0.03976477310061455, 0.11150892078876495, -0.02376873791217804, -0.07561171054840088, -0.0390351265668869, 0.047671616077423096, -0.10367520153522491, 0.007906913757324219, -0.06528258323669434, 0.0031083375215530396, -0.019020281732082367, 0.06380487233400345, 0.01843796856701374, 0.12122462689876556, 0.1537470519542694, -0.204196497797966, -0.11829084157943726, -0.00658879429101944, 0.038269493728876114, -0.009303070604801178, 0.23027978837490082, 0.11220605671405792, 0.1521325409412384, 0.08387230336666107, -0.19372569024562836, -0.03297225758433342, 0.05081919580698013, -0.17823755741119385, 0.029168173670768738, 0.1792973279953003, 0.03185462951660156, -0.05230909213423729, 0.06487543880939484, -0.07659529894590378, 0.48016640543937683, 0.12195851653814316, 0.05432134121656418, -0.026789680123329163, -0.03353477269411087, 0.019157975912094116, 0.10290072858333588, 0.21114620566368103, 0.04088372737169266, -0.032043129205703735, 0.1653907746076584, -0.13266609609127045, -0.02244003862142563, 0.35747334361076355, 0.13579712808132172, 0.006032668054103851, -0.03312528505921364, 0.16760215163230896, 0.09322216361761093, 0.22268140316009521, -0.161905899643898, -0.1348051279783249, -0.06536513566970825, -0.1639624685049057, -0.17195531725883484, 0.05470944195985794, -0.08730389922857285, -0.039257586002349854, 0.24647417664527893, -0.2895255386829376, 0.1403401792049408, -0.2603068947792053, 0.0015617422759532928, 0.05784817039966583, 0.05511869490146637, 0.14932015538215637, 0.18795102834701538, -0.057487837970256805, 0.015800733119249344, 0.09101168811321259, -0.15969975292682648, 0.02279457449913025, -0.08044782280921936, 0.09960941970348358, 0.2675836980342865, -0.42376449704170227, -0.1983032524585724, 0.07907003909349442]}"
"{\"sha\": \"8490a88f377d8fed802e4f3b2d1d87a0d6cb81b2\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/sized/cc_array_sized.c\", \"func_name\": \"cc_array_sized_zip_iter_remove\", \"original_string\": \"enum cc_stat cc_array_sized_zip_iter_remove(CC_ArraySizedZipIter *iter, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (!iter->last_removed) {\\n        cc_array_sized_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_sized_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\", \"code_tokens\": [\"enum\", \"cc_stat\", \"cc_array_sized_zip_iter_remove\", \"(\", \"CC_ArraySizedZipIter\", \"*\", \"iter\", \",\", \"uint8_t\", \"*\", \"out1\", \",\", \"uint8_t\", \"*\", \"out2\", \")\", \"{\", \"if\", \"(\", \"(\", \"iter\", \"->\", \"index\", \"-\", \"1\", \")\", \">=\", \"iter\", \"->\", \"ar1\", \"->\", \"size\", \"||\", \"(\", \"iter\", \"->\", \"index\", \"-\", \"1\", \")\", \">=\", \"iter\", \"->\", \"ar2\", \"->\", \"size\", \")\", \"{\", \"return\", \"CC_ERR_OUT_OF_RANGE\", \";\", \"}\", \"if\", \"(\", \"!\", \"iter\", \"->\", \"last_removed\", \")\", \"{\", \"cc_array_sized_remove_at\", \"(\", \"iter\", \"->\", \"ar1\", \",\", \"iter\", \"->\", \"index\", \"-\", \"1\", \",\", \"out1\", \")\", \";\", \"cc_array_sized_remove_at\", \"(\", \"iter\", \"->\", \"ar2\", \",\", \"iter\", \"->\", \"index\", \"-\", \"1\", \",\", \"out2\", \")\", \";\", \"iter\", \"->\", \"last_removed\", \"=\", \"true\", \";\", \"return\", \"CC_OK\", \";\", \"}\", \"return\", \"CC_ERR_VALUE_NOT_FOUND\", \";\", \"}\"], \"docstring\": \"/**\\n * Removes and outputs the last returned element pair by <code>cc_array_sized_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Removes\", \"and\", \"outputs\", \"the\", \"last\", \"returned\", \"element\", \"pair\", \"by\", \"<code\", \">\", \"cc_array_sized_zip_iter_next\", \"()\", \"*\", \"<\", \"/\", \"code\", \">\", \"without\", \"invalidating\", \"the\", \"iterator\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"iter\", \"iterator\", \"on\", \"which\", \"this\", \"operation\", \"is\", \"being\", \"performed\", \"*\", \"@param\", \"[\", \"out\", \"]\", \"out1\", \"output\", \"of\", \"the\", \"removed\", \"element\", \"from\", \"the\", \"first\", \"array\", \"*\", \"@param\", \"[\", \"out\", \"]\", \"out2\", \"output\", \"of\", \"the\", \"removed\", \"element\", \"from\", \"the\", \"second\", \"array\", \"*\", \"*\", \"@return\", \"CC_OK\", \"if\", \"the\", \"element\", \"was\", \"successfully\", \"removed\", \"CC_ERR_OUT_OF_RANGE\", \"if\", \"the\", \"*\", \"state\", \"of\", \"the\", \"iterator\", \"is\", \"invalid\", \"or\", \"CC_ERR_VALUE_NOT_FOUND\", \"if\", \"the\", \"element\", \"was\", \"*\", \"already\", \"removed\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2024 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n\\n#include \\\"sized/cc_array_sized.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\n#define INDEX(a, i) a->data_length * i\\n#define BUF_ADDR(a, i) &a->buffer[a->data_length * i]\\n\\n\\nstruct cc_array_sized_s {\\n    size_t   data_length;\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    uint8_t *buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[in] Size of the array element in bytes\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new(size_t element_size, CC_ArraySized **out)\\n{\\n    CC_ArraySizedConf c;\\n    cc_array_sized_conf_init(&c);\\n    return cc_array_sized_new_conf(element_size, &c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_ArraySized based on the specified CC_ArraySizedConf struct \\n * and returns a status code.\\n *\\n * The CC_ArraySized is allocated using the allocators specified in the CC_ArraySizedConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArraySizedConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] element_size the size of the data being stored in bytes\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new_conf(\\n    size_t element_size, \\n    CC_ArraySizedConf const * const conf, \\n    CC_ArraySized **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_ArraySized *ar = conf->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    uint8_t *buff = conf->mem_alloc(conf->capacity * element_size);\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->data_length = element_size;\\n    ar->buffer      = buff;\\n    ar->exp_factor  = ex;\\n    ar->capacity    = conf->capacity;\\n    ar->mem_alloc   = conf->mem_alloc;\\n    ar->mem_calloc  = conf->mem_calloc;\\n    ar->mem_free    = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArraySizedConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArraySizedConf structure that is being initialized\\n */\\nvoid cc_array_sized_conf_init(CC_ArraySizedConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_ArraySized structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_sized_destroy(CC_ArraySized *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n\\n/**\\n * Adds a new element to the CC_ArraySized. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_ArraySized.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add(CC_ArraySized *ar, uint8_t *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    memcpy(BUF_ADDR(ar, ar->size), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add_at(CC_ArraySized *ar, uint8_t *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_sized_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * ar->data_length;\\n\\n    memmove(BUF_ADDR(ar, (index + 1)),\\n            BUF_ADDR(ar, index),\\n            shift);\\n\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_ArraySized.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_replace_at(CC_ArraySized *ar, uint8_t *element, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n* Swaps the values at the specified indices.\\n*\\n* @param[in] ar array whose elements are being swapped\\n* @param[in] index1 first position\\n* @param[in] index2 second position\\n* \\n* @return CC_OK if the operation was successful, or CC_ERR_OUT_OF_RANGE if \\n* one of the indices was out of range.\\n*/\\nenum cc_stat cc_array_sized_swap_at(CC_ArraySized *ar, size_t index1, size_t index2)\\n{\\n    if (index1 >= ar->size || index2 >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n\\n    for (size_t i = 0; i < ar->data_length; i++) {\\n        uint8_t tmp = ar->buffer[INDEX(ar, index1 + i)];\\n        ar->buffer[INDEX(ar, index1 + i)] = ar->buffer[INDEX(ar, index2 + i)];\\n        ar->buffer[INDEX(ar, index2 + i)] = tmp;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_ArraySized if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_sized_remove(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_sized_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n \\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_remove_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_sized_remove_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    return cc_array_sized_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_sized_remove_all(CC_ArraySized *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Copies an CC_ArraySized element from the specified index to the out pointer.\\n * The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] source index of the array element\\n * @param[out] destination address\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_sized_get_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_sized_get_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n    return cc_array_sized_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n* Returns the pointer to the element at the specified index\\n*/\\nenum cc_stat cc_array_sized_peek(CC_ArraySized* ar, size_t index, uint8_t** out)\\n{\\n    if (index > ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    *out = BUF_ADDR(ar, index);\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst uint8_t * const* cc_array_sized_get_buffer(CC_ArraySized *ar)\\n{\\n    return (const uint8_t* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_ArraySized.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_sized_index_of(CC_ArraySized *ar, uint8_t *element, size_t *index)\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) { \\n            // Mismatching byte, skip to next block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            if (j == ar->data_length - 1) {\\n                *index = i;\\n                return CC_OK;\\n            }\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_ArraySized, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_ArraySized, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's allocators\\n *       and it also inherits the configuration of the original CC_ArraySized.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_sized_subarray(CC_ArraySized *ar, size_t b, size_t e, CC_ArraySized **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_ArraySized *sub_ar = ar->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * ar->data_length))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc   = ar->mem_alloc;\\n    sub_ar->mem_calloc  = ar->mem_calloc;\\n    sub_ar->mem_free    = ar->mem_free;\\n    sub_ar->size        = e - b + 1;\\n    sub_ar->capacity    = sub_ar->size;\\n    sub_ar->data_length = ar->data_length;\\n\\n    memcpy(sub_ar->buffer,\\n           BUF_ADDR(ar, b),\\n           sub_ar->size * ar->data_length);\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a copy of the specified CC_ArraySized. \\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's\\n *       allocators and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_sized_copy(CC_ArraySized *ar, CC_ArraySized **out)\\n{\\n    CC_ArraySized *copy = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->data_length = ar->data_length;\\n    copy->exp_factor  = ar->exp_factor;\\n    copy->size        = ar->size;\\n    copy->capacity    = ar->capacity;\\n    copy->mem_alloc   = ar->mem_alloc;\\n    copy->mem_calloc  = ar->mem_calloc;\\n    copy->mem_free    = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * ar->data_length);\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_ArraySized was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_ArraySized is empty.\\n */\\nenum cc_stat cc_array_sized_filter_mut(CC_ArraySized *ar, bool (*pred) (const uint8_t*))\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(BUF_ADDR(ar, i))) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * ar->data_length;\\n                memmove(BUF_ADDR(ar, (i + 1)),\\n                        BUF_ADDR(ar, (i + 1 + rm)),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * ar->data_length;\\n        memmove(BUF_ADDR(ar, 0),\\n                BUF_ADDR(ar, rm),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by creating a new CC_ArraySized that contains all elements\\n * from the original CC_ArraySized that return true on pred(element) without modifying \\n * the original CC_ArraySized.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_sized_filter(CC_ArraySized *ar, bool (*pred) (const uint8_t*), CC_ArraySized **out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    CC_ArraySized *filtered = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!filtered) {\\n        return CC_ERR_ALLOC;\\n    }\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->data_length = ar->data_length;\\n    filtered->exp_factor  = ar->exp_factor;\\n    filtered->size        = 0;\\n    filtered->capacity    = ar->capacity;\\n    filtered->mem_alloc   = ar->mem_alloc;\\n    filtered->mem_calloc  = ar->mem_calloc;\\n    filtered->mem_free    = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(BUF_ADDR(ar, i))) {\\n            memcpy(BUF_ADDR(filtered, f++), \\n                   BUF_ADDR(ar, i),\\n                   ar->data_length);\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_sized_reverse(CC_ArraySized *ar, uint8_t *tmp)\\n{\\n    if (ar->size == 0) {\\n        return;\\n    }\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        memcpy(tmp, BUF_ADDR(ar, i), ar->data_length);\\n        memcpy(BUF_ADDR(ar, i), BUF_ADDR(ar, j), ar->data_length);\\n        memcpy(BUF_ADDR(ar, j), tmp, ar->data_length);\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_ArraySized, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_sized_trim_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->size == ar->capacity) {\\n        return CC_OK;\\n    }\\n    uint8_t *new_buff = ar->mem_calloc(ar->size, ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * ar->data_length);\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_ArraySized.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_sized_contains(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t o = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) {\\n            // Mismatching byte, skip block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            // Last byte is equal, match found\\n            if (j == ar->data_length - 1) {\\n                o++;\\n            }\\n        }\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_ArraySized. The size of the array is the\\n * number of elements contained within the CC_ArraySized.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_ArraySized.\\n */\\nsize_t cc_array_sized_size(CC_ArraySized *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_ArraySized. The capacity of the CC_ArraySized is\\n * the maximum number of elements an CC_ArraySized can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_ArraySized.\\n */\\nsize_t cc_array_sized_capacity(CC_ArraySized *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sized_sort(CC_ArraySized *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, ar->data_length, cmp);\\n}\\n\\n/**\\n * Expands the CC_ArraySized capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS) {\\n        return CC_ERR_MAX_CAPACITY;\\n    }\\n\\n    size_t new_capacity = (size_t) (ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity) {\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    } else {\\n        ar->capacity = new_capacity;\\n    }\\n    uint8_t *new_buff = ar->mem_alloc(ar->capacity * ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    memcpy(new_buff, ar->buffer, ar->size * ar->data_length);\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_sized_map(CC_ArraySized *ar, void (*fn) (uint8_t *e))\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        fn(BUF_ADDR(ar, i));\\n    }\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_sized_reduce(CC_ArraySized *ar, void (*fn) (uint8_t*, uint8_t*, uint8_t*), uint8_t *result)\\n{\\n    if (ar->size == 1) {\\n        fn(BUF_ADDR(ar, 0), NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1) {\\n        fn(BUF_ADDR(ar, 0), BUF_ADDR(ar, 1), result);\\n    }\\n    for (size_t i = 2; i < ar->size; i++) {\\n        fn(result, BUF_ADDR(ar, i), result);\\n    }\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_sized_iter_init(CC_ArraySizedIter *iter, CC_ArraySized *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the reference of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_sized_iter_next(CC_ArraySizedIter *iter, uint8_t **out)\\n{\\n    if (iter->index >= iter->ar->size) {\\n        return CC_ITER_END;\\n    }\\n    *out = BUF_ADDR(iter->ar, iter->index);\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_sized_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_sized_iter_remove(CC_ArraySizedIter *iter, uint8_t *out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_sized_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK) {\\n            iter->last_removed = true;\\n        }\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_ArraySized after the last returned element by\\n * <code>cc_array_sized_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_iter_add(CC_ArraySizedIter *iter, uint8_t *element)\\n{\\n    return cc_array_sized_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_sized_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_iter_replace(CC_ArraySizedIter *iter, uint8_t *element, uint8_t *out)\\n{\\n    return cc_array_sized_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_sized_iter_index(CC_ArraySizedIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_sized_zip_iter_init(CC_ArraySizedZipIter *iter, CC_ArraySized *ar1, CC_ArraySized *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_sized_zip_iter_next(CC_ArraySizedZipIter *iter, uint8_t **out1, uint8_t **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size) {\\n        return CC_ITER_END;\\n    }\\n    *out1 = BUF_ADDR(iter->ar1, iter->index);\\n    *out2 = BUF_ADDR(iter->ar2, iter->index);\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_sized_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_remove(CC_ArraySizedZipIter *iter, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (!iter->last_removed) {\\n        cc_array_sized_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_sized_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_sized_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_sized_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_add(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_ArraySized  *ar1  = iter->ar1;\\n    CC_ArraySized  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n        (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK))) {\\n        return CC_ERR_ALLOC;\\n    }\\n    cc_array_sized_add_at(ar1, e1, index);\\n    cc_array_sized_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_zip_iter_replace(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    cc_array_sized_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_sized_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_sized_zip_iter_index(CC_ArraySizedZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_sized_struct_size()\\n{\\n    return sizeof(CC_ArraySized);\\n}\", \"embeddings\": [0.021157678216695786, 0.03757726028561592, 0.06716570258140564, 0.11459386348724365, 0.39798036217689514, -0.2016955465078354, 0.11257356405258179, 0.3584289848804474, 0.07380489259958267, -0.24845176935195923, -0.00816892459988594, -0.11812085658311844, -0.0007557664066553116, 0.12243717908859253, -0.009238176047801971, 0.055219054222106934, 0.06192060932517052, -0.03721097856760025, 0.05620469152927399, -0.33700552582740784, -0.18211807310581207, 0.10503007471561432, 0.16925111413002014, 0.12078366428613663, 0.24037067592144012, 0.1095861941576004, 0.25253719091415405, 0.11591964215040207, 0.28827089071273804, -0.19425742328166962, 0.053913265466690063, -0.0501120463013649, 0.03785772994160652, -0.20690709352493286, 0.07240156084299088, -0.015243597328662872, 0.04088068753480911, 0.03335250914096832, -0.008503918536007404, 0.005245033651590347, -0.15919290482997894, 0.07736949622631073, 0.04866183549165726, 0.18284739553928375, 0.05932936817407608, -0.018514178693294525, 0.046741142868995667, 0.21071286499500275, -0.06985901296138763, 0.09097711741924286, 0.08283121883869171, -0.10317976772785187, 0.016149789094924927, -0.08176709711551666, -0.024264518171548843, -0.0593978613615036, -0.014871329069137573, 0.40999919176101685, -0.022375114262104034, -0.028522640466690063, -0.06459970772266388, -0.12130464613437653, -0.17450997233390808, 0.16519971191883087, 0.1250612884759903, 0.021181780844926834, -0.12909312546253204, -0.23567023873329163, -0.028255756944417953, 0.013127090409398079, 0.08106452971696854, 0.039598021656274796, 0.1290275603532791, -0.19419944286346436, -0.12422391772270203, -0.08570736646652222, 0.0013222619891166687, 0.5162676572799683, -0.004019375890493393, 0.1774064004421234, 0.21512843668460846, -0.09673921763896942, 0.11614920943975449, 0.17381881177425385, 0.13984960317611694, 0.013235151767730713, -0.10793464630842209, 0.11335108429193497, -0.007291775196790695, 0.19525612890720367, 0.0824754536151886, 0.1436217725276947, -0.07688135653734207, -0.05387052521109581, -0.01872435212135315, 0.02703045681118965, 0.06784803420305252, -0.13200488686561584, 0.07484009861946106, 0.4388435482978821, -0.0855066180229187, -0.10426245629787445, -0.22165051102638245, -0.08524693548679352, -0.04786913841962814, 0.003483545035123825, -0.09446901828050613, 0.0805211290717125, 0.05340927466750145, 0.005704764276742935, 0.198617085814476, 0.09471404552459717, 0.006044953130185604, 0.042797915637493134, -0.05384135991334915, -0.0668582171201706, 0.11864863336086273, -0.05175463855266571, 0.2022155225276947, -0.12275179475545883, 0.11476239562034607, 0.01285117119550705, 0.05013599246740341, -0.07982262969017029, -0.08052167296409607, 0.05787614732980728, 0.005918644368648529, -0.23651009798049927, 0.16051998734474182, 0.08670200407505035, -0.045399636030197144, -0.10571808367967606, -0.0003584623336791992, -0.002447381615638733, 0.0919380858540535, 0.0523531548678875, 0.05121709406375885, 0.028309542685747147, 0.06269944459199905, -0.022991903126239777, -0.044402725994586945, 0.022516541182994843, 0.2512377202510834, -0.0631571114063263, 0.2629452049732208, -0.17593683302402496, 0.178142711520195, 0.11921553313732147, -0.2555485665798187, -0.24298161268234253, 0.06143833324313164, -0.13027292490005493, -0.0155706275254488, 0.06270494312047958, -0.16276957094669342, 0.8259646892547607, 0.1374553143978119, -0.09638889878988266, -0.05026436597108841, 0.03368411958217621, 0.05248770862817764, -0.29426300525665283, -0.0654754638671875, 0.18367567658424377, 0.07254120707511902, 0.12790705263614655, 0.08454916626214981, 0.04355575516819954, 0.15452416241168976, 0.05697283893823624, 0.11522652208805084, -0.081912100315094, -0.07494642585515976, 0.15093110501766205, 0.011649519205093384, -0.06253362447023392, -0.13422490656375885, 0.08696102350950241, -0.06856755167245865, -0.016462460160255432, -0.08100078254938126, 0.003119528293609619, -0.16367532312870026, -0.016815461218357086, -0.08449042588472366, 0.003968741744756699, -0.006457090377807617, -0.04651550203561783, 0.01861804723739624, -0.012974301353096962, 0.07656094431877136, 0.04610942304134369, 0.13548055291175842, -0.02836930751800537, -0.08295492082834244, 0.023051008582115173, -0.11786609143018723, -0.12411762773990631, 0.15512093901634216, -0.028622537851333618, -0.011917011812329292, -0.20700550079345703, 0.2074218988418579, -0.13943706452846527, -0.04029449075460434, 0.12258150428533554, -0.26299285888671875, -0.003755912184715271, 0.016164150089025497, -0.15422403812408447, -0.0915178507566452, 0.10094574838876724, 0.09511128813028336, 0.041789229959249496, -0.026391848921775818, -0.13140513002872467, 0.12614743411540985, 0.12537004053592682, 0.10293176770210266, -0.10880706459283829, 0.14254631102085114, 0.22847247123718262, -0.07295168936252594, -0.07045070827007294, -0.15673798322677612, 0.19276048243045807, 0.22110405564308167, 0.07214834541082382, -0.04982832819223404, 0.05703652277588844, 0.17081433534622192, 0.22780713438987732, -0.24085290729999542, 0.11017902195453644, 0.03761058673262596, -0.2281673401594162, -0.035146087408065796, 0.02146955579519272, 0.016122333705425262, -0.11566329002380371, -0.04368458688259125, 0.1555100530385971, 0.19721290469169617, 0.28969433903694153, 0.008418455719947815, 0.04104780778288841, -0.19528131186962128, 0.04442157596349716, -0.05235447734594345, -0.015397027134895325, -0.036167681217193604, -0.02690957859158516, -0.046728551387786865, -0.15050943195819855, -0.1265944391489029, -0.02793746069073677, -0.1704302281141281, -0.00048475340008735657, 0.06624533236026764, 0.3344653844833374, -0.006601370871067047, -0.06549432873725891, 0.05482446402311325, -0.020229600369930267, -0.1151689812541008, -0.40251386165618896, -0.036206357181072235, 0.04100309684872627, -0.00187615305185318, -0.01377289742231369, 0.056935980916023254, -0.088435597717762, 0.283204585313797, 0.08574407547712326, 0.08275026082992554, -0.010770954191684723, -0.013779167085886002, 0.021357141435146332, -0.17083431780338287, 0.0172649547457695, -0.06659090518951416, 0.05686893314123154, -0.11680597066879272, 0.11199311912059784, 0.02974487841129303, 0.0217603649944067, 0.16581442952156067, -0.06409667432308197, 0.0297052301466465, 0.02215966209769249, 0.07887915521860123, 0.07317106425762177, 0.12804290652275085, 0.12381334602832794, 0.032400332391262054, 0.12807372212409973, 0.22571322321891785, -0.09951110184192657, 0.00536346435546875, -0.29669201374053955, 0.10733336210250854, -0.30168962478637695, 0.015361814759671688, -0.021978169679641724, 0.35968637466430664, -0.03587740659713745, 0.039329588413238525, 0.02459000051021576, 0.28830355405807495, 0.03943677619099617, 0.04802970960736275, 0.06849481910467148, -0.17116466164588928, 0.1319613754749298, -0.1959388107061386, 0.07395045459270477, -0.11674667149782181, -0.05974544212222099, 0.10494470596313477, 0.03852357342839241, -0.01929451897740364, 0.1148516982793808, 0.23592513799667358, 0.13514691591262817, -0.012995053082704544, 0.06768430769443512, 0.06202223151922226, -0.014005996286869049, -0.1831037998199463, 0.6807500123977661, -0.5645400881767273, 0.2077421247959137, -0.18251988291740417, 0.29832950234413147, -0.049308136105537415, 0.3426104485988617, -0.06694833189249039, 0.10059882700443268, 0.059571005403995514, 0.12958833575248718, -0.15464593470096588, -0.04548901692032814, -0.14119330048561096, 0.27684879302978516, 0.1514464020729065, 0.14108070731163025, 0.2022056132555008, -0.03981770947575569, 0.11276856064796448, -0.14734534919261932, -0.15225908160209656, 0.1749933660030365, 0.08050213754177094, -0.09238141775131226, 0.12898793816566467, 0.3194025456905365, -0.11014174669981003, -0.14842139184474945, 0.04131294786930084, 0.03260514885187149, 0.18290793895721436, -0.21917062997817993, 0.12303169816732407, -0.11232077330350876, 0.3095458745956421, -0.46857979893684387, -0.3739428222179413, 0.031846657395362854, -0.11307878792285919, 0.06059534102678299, 0.15875108540058136, 0.29188060760498047, 0.14853593707084656, -0.18985624611377716, 0.0933186411857605, -0.06030552461743355, -0.002778824418783188, -0.016070939600467682, -0.007525049149990082, 0.10218187421560287, 0.08100853115320206, 0.027065914124250412, 0.05690215900540352, 0.026040751487016678, 0.06168065965175629, -0.17756590247154236, 0.25291571021080017, 0.15277108550071716, 0.2275463491678238, -0.1220356822013855, 0.0590592622756958, -0.13102208077907562, 0.06779646873474121, -0.06605972349643707, 0.05371365696191788, 0.07227706164121628, -0.14309844374656677, 0.2449081689119339, -0.1195104718208313, -0.07161752879619598, 0.19988882541656494, 0.2045837640762329, 0.011666104197502136, 0.21066787838935852, 0.09523630142211914, 0.07356104999780655, 0.23663263022899628, -0.1287471204996109, -0.15761402249336243, -0.1735791712999344, 0.12455753237009048, 0.07146342098712921, 0.09398821741342545, 0.02005990967154503, 0.16117072105407715, -0.19039291143417358, -0.03835257515311241, -0.3613373935222626, -0.17903569340705872, 0.1685202419757843, 0.2523108720779419, 0.1228877529501915, -0.00996650755405426, -0.19943267107009888, -0.05560872703790665, -0.012648411095142365, -0.052022531628608704, -0.0617208331823349, 0.039715033024549484, -0.14653240144252777, 0.06606270372867584, 0.28692498803138733, 0.09204224497079849, 0.05862555280327797, 0.07059400528669357, -0.04364130645990372, -0.11165300011634827, -0.003338932991027832, 0.05061741918325424, 0.026001960039138794, -0.0842425674200058, 0.05874639004468918, 0.05147683247923851, 0.1193532645702362, 0.011036165058612823, -0.09188050776720047, 0.42739489674568176, 0.09606032073497772, -0.03933132439851761, 0.04813738912343979, -0.13781413435935974, 0.01023099571466446, -0.031160589307546616, -0.27200406789779663, 0.12643612921237946, 0.19458308815956116, 0.08229872584342957, 0.03183460608124733, 0.07997123897075653, 0.03705383464694023, -0.08301643282175064, 0.070498988032341, -0.07587343454360962, -0.1395803689956665, 0.024020366370677948, -0.08709075301885605, 0.1567804515361786, 0.010839533060789108, 0.24168992042541504, 0.14209479093551636, 0.06672395765781403, 0.17508399486541748, 0.03277014195919037, -0.06683409959077835, 0.04001222923398018, 0.019600555300712585, -0.050965193659067154, -0.17836621403694153, 0.05097406730055809, -0.13441257178783417, -0.01868712529540062, 0.11328676342964172, 0.14111854135990143, 0.04343375191092491, 0.045067042112350464, -0.19751089811325073, 0.24625667929649353, 0.12312144786119461, -0.12721911072731018, -0.0015150830149650574, -0.04695156589150429, 0.10326078534126282, 0.080964595079422, 0.07024030387401581, 0.2611386179924011, 0.16496139764785767, 0.026806920766830444, 0.1010909378528595, 0.31790778040885925, -0.13618828356266022, 0.010650865733623505, 0.1123027503490448, 0.020457379519939423, -0.11289520561695099, -0.08968673646450043, -0.09345366805791855, -0.048325538635253906, 0.05278768017888069, 0.16469654440879822, -0.2103448510169983, -0.05182182788848877, -0.11169015616178513, 0.15679742395877838, -0.0013212524354457855, 0.03237311169505119, 0.07937867939472198, -0.0009292364120483398, -0.023734677582979202, -0.1178552508354187, 0.31115293502807617, -0.18097040057182312, -0.10307951271533966, -0.07720647752285004, -0.018294556066393852, -0.11086510866880417, 0.019328100606799126, 0.10058967769145966, 0.0359516367316246, 0.12925925850868225, 0.057685766369104385, -0.02352762222290039, 0.022183552384376526, 0.10987599194049835, 0.20648397505283356, -0.1488245576620102, 0.033173542469739914, 0.07171477377414703, 0.07936504483222961, 0.23755306005477905, -0.08617612719535828, -0.21356429159641266, -0.12538287043571472, 0.17676159739494324, -0.0750824362039566, 0.14982739090919495, 0.03522569686174393, 0.18232859671115875, 0.10302142798900604, -0.05476485937833786, -0.03391018509864807, -0.0954204648733139, -0.6822388172149658, -0.06570333242416382, 0.15405908226966858, 0.0054503269493579865, 0.08969318121671677, 0.1606181412935257, 0.07633261382579803, 0.06018528342247009, 0.10754765570163727, 0.06570892035961151, 0.029827894642949104, 0.13818572461605072, 0.264515221118927, -0.11845510452985764, -0.11042618751525879, 0.13198819756507874, 0.08601085841655731, -0.25089031457901, 0.2839275300502777, -0.08260831236839294, -0.17157024145126343, 0.08699759840965271, 0.3567216992378235, 0.007307454943656921, 0.024790102615952492, 0.23421093821525574, 0.05172897130250931, 0.2270238846540451, -0.06042180955410004, 0.0688316747546196, 0.3662850856781006, 0.1530051976442337, -0.3565298020839691, 0.01885780692100525, 0.23566551506519318, 0.16878220438957214, 0.09895409643650055, 14.007781982421875, -0.08931076526641846, 0.2950594127178192, -0.1432320475578308, -0.1139516606926918, -0.021467193961143494, -0.07233937829732895, 0.028808265924453735, 0.00455058366060257, 0.006598621606826782, 0.09263256192207336, -0.09477405250072479, -0.04770109802484512, -0.030551712960004807, -0.08814367651939392, -0.008712686598300934, -0.027139857411384583, -0.13217194378376007, 0.17527440190315247, 0.04079994186758995, -0.20885467529296875, -0.049147918820381165, -0.0582844614982605, -0.4062070846557617, -0.01858317106962204, -0.034589655697345734, 0.10402445495128632, 0.0523337759077549, 0.025057870894670486, 0.08798485994338989, 0.1948990374803543, 0.1690748631954193, 0.12376168370246887, -0.012762710452079773, 0.03447038307785988, -0.02157559059560299, -0.3698825240135193, -0.17445294559001923, 0.09225986897945404, -0.011533044278621674, -0.02584870159626007, 0.026600606739521027, 0.15967173874378204, -0.0378025621175766, 0.12776222825050354, 0.10657407343387604, -0.24081745743751526, 0.13201278448104858, -0.11636707931756973, -0.029292888939380646, 0.2254074662923813, 0.11653350293636322, 0.3285837769508362, 0.013212788850069046, -0.13817530870437622, -0.1995973289012909, 0.31295961141586304, -0.01806759089231491, -0.042250871658325195, 0.36079153418540955, 0.012752994894981384, -0.05869220942258835, -0.08098931610584259, 0.07472579181194305, 0.014528356492519379, -0.01180817186832428, 0.09903104603290558, 0.046954698860645294, -0.23683969676494598, 0.14382657408714294, 0.24361035227775574, -0.22956566512584686, 0.163892924785614, -0.045686058700084686, -0.13261297345161438, 0.11210881918668747, 0.04024603217840195, -0.02658483013510704, 0.04197298735380173, -0.12607744336128235, -0.005805380642414093, 0.11390839517116547, -0.17301635444164276, -0.1685781180858612, -0.3045256733894348, 0.036251820623874664, -0.01858161762356758, 0.17241036891937256, 0.275530606508255, -0.048355333507061005, -0.07861451059579849, 0.089932382106781, -0.023542657494544983, -0.2149306833744049, 0.21664616465568542, -0.01582919806241989, -0.08222858607769012, -0.1836043894290924, 0.02552848681807518, 0.11582504957914352, -0.017682544887065887, -0.08194470405578613, -0.019426073879003525, -0.007529914379119873, -0.1031501293182373, 0.003825061023235321, -0.020720914006233215, -0.029143713414669037, -0.029604613780975342, 0.06007235497236252, 0.034458041191101074, 0.0910739153623581, 0.14559565484523773, -0.18034635484218597, -0.18393026292324066, -0.013340700417757034, 0.0009697936475276947, 0.010700564831495285, 0.19324274361133575, 0.1558040976524353, 0.15923567116260529, 0.047281134873628616, -0.20725104212760925, -0.029591713100671768, 0.08093924820423126, -0.17112012207508087, 0.02112170308828354, 0.1568962037563324, 0.017041198909282684, -0.07152120769023895, -0.011976592242717743, -0.07958289235830307, 0.5262255668640137, 0.10097356140613556, 0.05095365643501282, -0.03029458224773407, 0.0015148073434829712, 0.026656191796064377, 0.06879869103431702, 0.27113237977027893, 0.06118307262659073, -0.03718090057373047, 0.1566905975341797, -0.13495004177093506, -0.06222952902317047, 0.3481321930885315, 0.12702815234661102, 0.05410522222518921, -0.04466733708977699, 0.1622508466243744, 0.12679964303970337, 0.19600607454776764, -0.21586869657039642, -0.10726749897003174, -0.06088976934552193, -0.15615962445735931, -0.17036572098731995, 0.06207564100623131, -0.08719395846128464, -0.01769823208451271, 0.20334190130233765, -0.28737425804138184, 0.135067418217659, -0.2962743639945984, 0.012372929602861404, 0.051414426416158676, 0.06163664907217026, 0.16205614805221558, 0.1799772083759308, -0.08181516081094742, 0.015186041593551636, 0.09022100269794464, -0.13141946494579315, 0.045680154114961624, -0.11490501463413239, 0.11836396157741547, 0.2980843484401703, -0.40431901812553406, -0.17986227571964264, 0.07311096787452698]}"
"{\"sha\": \"8490a88f377d8fed802e4f3b2d1d87a0d6cb81b2\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/sized/cc_array_sized.c\", \"func_name\": \"cc_array_sized_zip_iter_add\", \"original_string\": \"enum cc_stat cc_array_sized_zip_iter_add(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_ArraySized  *ar1  = iter->ar1;\\n    CC_ArraySized  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n        (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK))) {\\n        return CC_ERR_ALLOC;\\n    }\\n    cc_array_sized_add_at(ar1, e1, index);\\n    cc_array_sized_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\", \"code_tokens\": [\"enum\", \"cc_stat\", \"cc_array_sized_zip_iter_add\", \"(\", \"CC_ArraySizedZipIter\", \"*\", \"iter\", \",\", \"uint8_t\", \"*\", \"e1\", \",\", \"uint8_t\", \"*\", \"e2\", \")\", \"{\", \"size_t\", \"index\", \"=\", \"iter\", \"->\", \"index\", \"++\", \";\", \"CC_ArraySized\", \"*\", \"ar1\", \"=\", \"iter\", \"->\", \"ar1\", \";\", \"CC_ArraySized\", \"*\", \"ar2\", \"=\", \"iter\", \"->\", \"ar2\", \";\", \"if\", \"(\", \"(\", \"ar1\", \"->\", \"size\", \"==\", \"ar1\", \"->\", \"capacity\", \"&&\", \"(\", \"expand_capacity\", \"(\", \"ar1\", \")\", \"!=\", \"CC_OK\", \")\", \")\", \"||\", \"(\", \"ar2\", \"->\", \"size\", \"==\", \"ar2\", \"->\", \"capacity\", \"&&\", \"(\", \"expand_capacity\", \"(\", \"ar2\", \")\", \"!=\", \"CC_OK\", \")\", \")\", \")\", \"{\", \"return\", \"CC_ERR_ALLOC\", \";\", \"}\", \"cc_array_sized_add_at\", \"(\", \"ar1\", \",\", \"e1\", \",\", \"index\", \")\", \";\", \"cc_array_sized_add_at\", \"(\", \"ar2\", \",\", \"e2\", \",\", \"index\", \")\", \";\", \"return\", \"CC_OK\", \";\", \"}\"], \"docstring\": \"/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_sized_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_sized_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Adds\", \"a\", \"new\", \"element\", \"pair\", \"to\", \"the\", \"arrays\", \"after\", \"the\", \"last\", \"returned\", \"element\", \"pair\", \"by\", \"*\", \"<code\", \">\", \"cc_array_sized_zip_iter_next\", \"()\", \"<\", \"/\", \"code\", \">\", \"and\", \"immediately\", \"before\", \"an\", \"element\", \"pair\", \"*\", \"that\", \"would\", \"be\", \"returned\", \"by\", \"a\", \"subsequent\", \"call\", \"to\", \"<code\", \">\", \"cc_array_sized_zip_iter_next\", \"()\", \"<\", \"/\", \"code\", \">\", \"*\", \"without\", \"invalidating\", \"the\", \"iterator\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"iter\", \"iterator\", \"on\", \"which\", \"this\", \"operation\", \"is\", \"being\", \"performed\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"e1\", \"element\", \"added\", \"to\", \"the\", \"first\", \"array\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"e2\", \"element\", \"added\", \"to\", \"the\", \"second\", \"array\", \"*\", \"*\", \"@return\", \"CC_OK\", \"if\", \"the\", \"element\", \"pair\", \"was\", \"successfully\", \"added\", \"to\", \"the\", \"arrays\", \"or\", \"*\", \"CC_ERR_ALLOC\", \"if\", \"the\", \"memory\", \"allocation\", \"for\", \"the\", \"new\", \"elements\", \"failed\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2024 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n\\n#include \\\"sized/cc_array_sized.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\n#define INDEX(a, i) a->data_length * i\\n#define BUF_ADDR(a, i) &a->buffer[a->data_length * i]\\n\\n\\nstruct cc_array_sized_s {\\n    size_t   data_length;\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    uint8_t *buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[in] Size of the array element in bytes\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new(size_t element_size, CC_ArraySized **out)\\n{\\n    CC_ArraySizedConf c;\\n    cc_array_sized_conf_init(&c);\\n    return cc_array_sized_new_conf(element_size, &c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_ArraySized based on the specified CC_ArraySizedConf struct \\n * and returns a status code.\\n *\\n * The CC_ArraySized is allocated using the allocators specified in the CC_ArraySizedConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArraySizedConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] element_size the size of the data being stored in bytes\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new_conf(\\n    size_t element_size, \\n    CC_ArraySizedConf const * const conf, \\n    CC_ArraySized **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_ArraySized *ar = conf->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    uint8_t *buff = conf->mem_alloc(conf->capacity * element_size);\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->data_length = element_size;\\n    ar->buffer      = buff;\\n    ar->exp_factor  = ex;\\n    ar->capacity    = conf->capacity;\\n    ar->mem_alloc   = conf->mem_alloc;\\n    ar->mem_calloc  = conf->mem_calloc;\\n    ar->mem_free    = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArraySizedConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArraySizedConf structure that is being initialized\\n */\\nvoid cc_array_sized_conf_init(CC_ArraySizedConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_ArraySized structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_sized_destroy(CC_ArraySized *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n\\n/**\\n * Adds a new element to the CC_ArraySized. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_ArraySized.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add(CC_ArraySized *ar, uint8_t *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    memcpy(BUF_ADDR(ar, ar->size), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add_at(CC_ArraySized *ar, uint8_t *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_sized_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * ar->data_length;\\n\\n    memmove(BUF_ADDR(ar, (index + 1)),\\n            BUF_ADDR(ar, index),\\n            shift);\\n\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_ArraySized.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_replace_at(CC_ArraySized *ar, uint8_t *element, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n* Swaps the values at the specified indices.\\n*\\n* @param[in] ar array whose elements are being swapped\\n* @param[in] index1 first position\\n* @param[in] index2 second position\\n* \\n* @return CC_OK if the operation was successful, or CC_ERR_OUT_OF_RANGE if \\n* one of the indices was out of range.\\n*/\\nenum cc_stat cc_array_sized_swap_at(CC_ArraySized *ar, size_t index1, size_t index2)\\n{\\n    if (index1 >= ar->size || index2 >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n\\n    for (size_t i = 0; i < ar->data_length; i++) {\\n        uint8_t tmp = ar->buffer[INDEX(ar, index1 + i)];\\n        ar->buffer[INDEX(ar, index1 + i)] = ar->buffer[INDEX(ar, index2 + i)];\\n        ar->buffer[INDEX(ar, index2 + i)] = tmp;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_ArraySized if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_sized_remove(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_sized_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n \\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_remove_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_sized_remove_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    return cc_array_sized_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_sized_remove_all(CC_ArraySized *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Copies an CC_ArraySized element from the specified index to the out pointer.\\n * The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] source index of the array element\\n * @param[out] destination address\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_sized_get_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_sized_get_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n    return cc_array_sized_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n* Returns the pointer to the element at the specified index\\n*/\\nenum cc_stat cc_array_sized_peek(CC_ArraySized* ar, size_t index, uint8_t** out)\\n{\\n    if (index > ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    *out = BUF_ADDR(ar, index);\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst uint8_t * const* cc_array_sized_get_buffer(CC_ArraySized *ar)\\n{\\n    return (const uint8_t* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_ArraySized.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_sized_index_of(CC_ArraySized *ar, uint8_t *element, size_t *index)\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) { \\n            // Mismatching byte, skip to next block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            if (j == ar->data_length - 1) {\\n                *index = i;\\n                return CC_OK;\\n            }\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_ArraySized, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_ArraySized, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's allocators\\n *       and it also inherits the configuration of the original CC_ArraySized.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_sized_subarray(CC_ArraySized *ar, size_t b, size_t e, CC_ArraySized **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_ArraySized *sub_ar = ar->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * ar->data_length))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc   = ar->mem_alloc;\\n    sub_ar->mem_calloc  = ar->mem_calloc;\\n    sub_ar->mem_free    = ar->mem_free;\\n    sub_ar->size        = e - b + 1;\\n    sub_ar->capacity    = sub_ar->size;\\n    sub_ar->data_length = ar->data_length;\\n\\n    memcpy(sub_ar->buffer,\\n           BUF_ADDR(ar, b),\\n           sub_ar->size * ar->data_length);\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a copy of the specified CC_ArraySized. \\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's\\n *       allocators and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_sized_copy(CC_ArraySized *ar, CC_ArraySized **out)\\n{\\n    CC_ArraySized *copy = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->data_length = ar->data_length;\\n    copy->exp_factor  = ar->exp_factor;\\n    copy->size        = ar->size;\\n    copy->capacity    = ar->capacity;\\n    copy->mem_alloc   = ar->mem_alloc;\\n    copy->mem_calloc  = ar->mem_calloc;\\n    copy->mem_free    = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * ar->data_length);\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_ArraySized was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_ArraySized is empty.\\n */\\nenum cc_stat cc_array_sized_filter_mut(CC_ArraySized *ar, bool (*pred) (const uint8_t*))\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(BUF_ADDR(ar, i))) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * ar->data_length;\\n                memmove(BUF_ADDR(ar, (i + 1)),\\n                        BUF_ADDR(ar, (i + 1 + rm)),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * ar->data_length;\\n        memmove(BUF_ADDR(ar, 0),\\n                BUF_ADDR(ar, rm),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by creating a new CC_ArraySized that contains all elements\\n * from the original CC_ArraySized that return true on pred(element) without modifying \\n * the original CC_ArraySized.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_sized_filter(CC_ArraySized *ar, bool (*pred) (const uint8_t*), CC_ArraySized **out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    CC_ArraySized *filtered = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!filtered) {\\n        return CC_ERR_ALLOC;\\n    }\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->data_length = ar->data_length;\\n    filtered->exp_factor  = ar->exp_factor;\\n    filtered->size        = 0;\\n    filtered->capacity    = ar->capacity;\\n    filtered->mem_alloc   = ar->mem_alloc;\\n    filtered->mem_calloc  = ar->mem_calloc;\\n    filtered->mem_free    = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(BUF_ADDR(ar, i))) {\\n            memcpy(BUF_ADDR(filtered, f++), \\n                   BUF_ADDR(ar, i),\\n                   ar->data_length);\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_sized_reverse(CC_ArraySized *ar, uint8_t *tmp)\\n{\\n    if (ar->size == 0) {\\n        return;\\n    }\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        memcpy(tmp, BUF_ADDR(ar, i), ar->data_length);\\n        memcpy(BUF_ADDR(ar, i), BUF_ADDR(ar, j), ar->data_length);\\n        memcpy(BUF_ADDR(ar, j), tmp, ar->data_length);\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_ArraySized, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_sized_trim_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->size == ar->capacity) {\\n        return CC_OK;\\n    }\\n    uint8_t *new_buff = ar->mem_calloc(ar->size, ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * ar->data_length);\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_ArraySized.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_sized_contains(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t o = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) {\\n            // Mismatching byte, skip block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            // Last byte is equal, match found\\n            if (j == ar->data_length - 1) {\\n                o++;\\n            }\\n        }\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_ArraySized. The size of the array is the\\n * number of elements contained within the CC_ArraySized.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_ArraySized.\\n */\\nsize_t cc_array_sized_size(CC_ArraySized *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_ArraySized. The capacity of the CC_ArraySized is\\n * the maximum number of elements an CC_ArraySized can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_ArraySized.\\n */\\nsize_t cc_array_sized_capacity(CC_ArraySized *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sized_sort(CC_ArraySized *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, ar->data_length, cmp);\\n}\\n\\n/**\\n * Expands the CC_ArraySized capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS) {\\n        return CC_ERR_MAX_CAPACITY;\\n    }\\n\\n    size_t new_capacity = (size_t) (ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity) {\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    } else {\\n        ar->capacity = new_capacity;\\n    }\\n    uint8_t *new_buff = ar->mem_alloc(ar->capacity * ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    memcpy(new_buff, ar->buffer, ar->size * ar->data_length);\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_sized_map(CC_ArraySized *ar, void (*fn) (uint8_t *e))\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        fn(BUF_ADDR(ar, i));\\n    }\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_sized_reduce(CC_ArraySized *ar, void (*fn) (uint8_t*, uint8_t*, uint8_t*), uint8_t *result)\\n{\\n    if (ar->size == 1) {\\n        fn(BUF_ADDR(ar, 0), NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1) {\\n        fn(BUF_ADDR(ar, 0), BUF_ADDR(ar, 1), result);\\n    }\\n    for (size_t i = 2; i < ar->size; i++) {\\n        fn(result, BUF_ADDR(ar, i), result);\\n    }\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_sized_iter_init(CC_ArraySizedIter *iter, CC_ArraySized *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the reference of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_sized_iter_next(CC_ArraySizedIter *iter, uint8_t **out)\\n{\\n    if (iter->index >= iter->ar->size) {\\n        return CC_ITER_END;\\n    }\\n    *out = BUF_ADDR(iter->ar, iter->index);\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_sized_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_sized_iter_remove(CC_ArraySizedIter *iter, uint8_t *out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_sized_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK) {\\n            iter->last_removed = true;\\n        }\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_ArraySized after the last returned element by\\n * <code>cc_array_sized_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_iter_add(CC_ArraySizedIter *iter, uint8_t *element)\\n{\\n    return cc_array_sized_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_sized_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_iter_replace(CC_ArraySizedIter *iter, uint8_t *element, uint8_t *out)\\n{\\n    return cc_array_sized_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_sized_iter_index(CC_ArraySizedIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_sized_zip_iter_init(CC_ArraySizedZipIter *iter, CC_ArraySized *ar1, CC_ArraySized *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_sized_zip_iter_next(CC_ArraySizedZipIter *iter, uint8_t **out1, uint8_t **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size) {\\n        return CC_ITER_END;\\n    }\\n    *out1 = BUF_ADDR(iter->ar1, iter->index);\\n    *out2 = BUF_ADDR(iter->ar2, iter->index);\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_sized_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_remove(CC_ArraySizedZipIter *iter, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (!iter->last_removed) {\\n        cc_array_sized_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_sized_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_sized_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_sized_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_add(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_ArraySized  *ar1  = iter->ar1;\\n    CC_ArraySized  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n        (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK))) {\\n        return CC_ERR_ALLOC;\\n    }\\n    cc_array_sized_add_at(ar1, e1, index);\\n    cc_array_sized_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_zip_iter_replace(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    cc_array_sized_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_sized_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_sized_zip_iter_index(CC_ArraySizedZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_sized_struct_size()\\n{\\n    return sizeof(CC_ArraySized);\\n}\", \"embeddings\": [0.01686708629131317, 0.016637392342090607, 0.02351117692887783, 0.12348416447639465, 0.4298144280910492, -0.19224423170089722, 0.17396217584609985, 0.36714106798171997, -0.02603122964501381, -0.29268333315849304, -0.013923808932304382, -0.09651384502649307, 0.08181247860193253, 0.18602651357650757, -0.037587158381938934, 0.06148287653923035, 0.06192222982645035, -0.09514821320772171, 0.02201647311449051, -0.4483835697174072, -0.20561730861663818, 0.100888691842556, 0.14769494533538818, 0.1484057903289795, 0.2975200414657593, 0.13221128284931183, 0.25922301411628723, 0.06925096362829208, 0.36676132678985596, -0.21635664999485016, 0.08546334505081177, -0.13334622979164124, 0.05949873849749565, -0.21425658464431763, 0.09784587472677231, -0.03078131377696991, 0.0073889195919036865, 0.06541142612695694, -0.06897097826004028, 0.012121723964810371, -0.17583324015140533, 0.07754004001617432, 0.07487131655216217, 0.17061153054237366, 0.11865059286355972, -0.05623079836368561, 0.04255204275250435, 0.2975641191005707, -0.049731407314538956, 0.10882610082626343, 0.10239382088184357, -0.10948531329631805, 0.015392810106277466, -0.14870458841323853, -0.0769304484128952, -0.1204199567437172, 0.031407713890075684, 0.39438873529434204, 0.014519823715090752, -0.07186935096979141, -0.11700011789798737, -0.16372765600681305, -0.24840812385082245, 0.18719740211963654, 0.14442262053489685, 0.04555029794573784, -0.17714738845825195, -0.32451316714286804, 0.016617149114608765, -0.06051168590784073, 0.10960879176855087, 0.12461018562316895, 0.12953323125839233, -0.1674755960702896, -0.1657235473394394, -0.10636340081691742, -0.01641979068517685, 0.4844418168067932, -0.04792392998933792, 0.24584728479385376, 0.16257087886333466, -0.0879555493593216, 0.17293080687522888, 0.2009938657283783, 0.21555139124393463, 0.0357433520257473, -0.2080693244934082, 0.13662585616111755, -0.046059541404247284, 0.26046517491340637, 0.06399379670619965, 0.14130447804927826, -0.11550638824701309, -0.11129528284072876, -0.01128394901752472, -0.02272505685687065, 0.06277858465909958, -0.076141856610775, 0.08173432946205139, 0.525668740272522, -0.1502854824066162, -0.14205603301525116, -0.3325643539428711, -0.15887236595153809, -0.09504758566617966, 0.021153490990400314, -0.12960690259933472, 0.08649313449859619, 0.10321086645126343, 0.02184075489640236, 0.23380617797374725, 0.07186359167098999, 0.04899081960320473, 0.013242453336715698, -0.049664631485939026, -0.03718368336558342, 0.12542086839675903, -0.05847136676311493, 0.25705966353416443, -0.20236694812774658, 0.09927459806203842, -0.048409901559352875, 0.06603208184242249, -0.07285115122795105, -0.12371054291725159, 0.041113074868917465, 0.09893003106117249, -0.3119560182094574, 0.16043883562088013, -0.002344690263271332, -0.038269877433776855, -0.022957945242524147, -0.016948461532592773, -0.07751210033893585, 0.1271374374628067, 0.034769754856824875, 0.13916438817977905, -9.305030107498169e-05, 0.07174370437860489, -0.03310950845479965, -0.1191135123372078, 0.041662558913230896, 0.3257673680782318, -0.0435064397752285, 0.3438063859939575, -0.21750490367412567, 0.23818999528884888, 0.14384983479976654, -0.35240045189857483, -0.2712347209453583, -0.01382463425397873, -0.15690070390701294, 0.011812414973974228, 0.06161200627684593, -0.1985289752483368, 0.7664804458618164, 0.08076786994934082, -0.144699364900589, -0.03361877053976059, 0.02171330153942108, 0.028208494186401367, -0.30756810307502747, -0.10541394352912903, 0.22369666397571564, 0.058590881526470184, 0.14414022862911224, 0.10409830510616302, 0.10270360112190247, 0.1932116448879242, 0.04107814282178879, 0.12605945765972137, -0.12605887651443481, -0.08338375389575958, 0.18588943779468536, 0.02198753133416176, -0.07965896278619766, -0.140381321310997, 0.07239387929439545, -0.030033688992261887, -0.003998599946498871, -0.11422087252140045, 0.015372063964605331, -0.221263587474823, -0.0030372366309165955, -0.091512031853199, 0.005817066878080368, -0.03863710165023804, -0.016783135011792183, 0.06185118854045868, -0.004846528172492981, 0.11496996134519577, -0.007683934643864632, 0.18774057924747467, -0.09264209866523743, -0.12285841256380081, 0.02346189320087433, -0.13846144080162048, -0.07663358747959137, 0.24504569172859192, -0.020506277680397034, 0.030330095440149307, -0.23380780220031738, 0.25040698051452637, -0.1356332153081894, -0.12243878841400146, 0.13777802884578705, -0.28370094299316406, -0.03726445883512497, -0.029781606048345566, -0.1745046079158783, -0.10786576569080353, 0.10985973477363586, 0.17139315605163574, 0.005874761380255222, -0.03340687230229378, -0.14106130599975586, 0.02244376763701439, 0.16159331798553467, 0.11769313365221024, -0.06522686034440994, 0.1539458930492401, 0.26822978258132935, -0.11241673678159714, -0.09637151658535004, -0.27397483587265015, 0.21874788403511047, 0.23667359352111816, 0.12454697489738464, -0.04485320299863815, 0.12125264108181, 0.1601695716381073, 0.2948567271232605, -0.28361746668815613, 0.16637156903743744, -0.0038016140460968018, -0.1591743528842926, -0.04501010477542877, 0.029606647789478302, -0.0028124675154685974, -0.11859019100666046, 0.01085592806339264, 0.18951529264450073, 0.1925164759159088, 0.30107030272483826, -0.013709355145692825, 0.03657955676317215, -0.14990250766277313, 0.029990017414093018, -0.14897465705871582, -0.020421437919139862, -0.041960492730140686, -0.02024495229125023, -0.039442285895347595, -0.22327247262001038, -0.16300812363624573, 0.021835017949342728, -0.1494257003068924, -0.05536205694079399, 0.07350751012563705, 0.35153448581695557, -0.003968831151723862, -0.038913801312446594, 0.14501655101776123, -0.045675523579120636, -0.20144858956336975, -0.41257375478744507, -0.03910820186138153, 0.05122136324644089, 0.06327882409095764, -0.0489225909113884, 0.07249007374048233, -0.12220380455255508, 0.3430388569831848, 0.07612127810716629, 0.11097323894500732, -0.04627645015716553, -0.08570443838834763, -0.032589588314294815, -0.25504472851753235, 0.01837306097149849, 0.0004290752112865448, 0.1112203449010849, -0.1842241734266281, 0.1402394026517868, 0.008407711051404476, 0.057312048971652985, 0.18770651519298553, -0.004331400617957115, -0.006186343729496002, 0.022589661180973053, 0.07430724799633026, 0.08313056826591492, 0.14193062484264374, 0.18007652461528778, 0.0963895320892334, 0.06999753415584564, 0.2420130968093872, -0.053320616483688354, 0.02909555658698082, -0.31178340315818787, 0.14278754591941833, -0.39219048619270325, 0.0055608609691262245, -0.028819065541028976, 0.4047892391681671, -0.0415322370827198, 0.014249783009290695, 0.010860741138458252, 0.21529704332351685, 0.029724590480327606, 0.13888587057590485, 0.08429622650146484, -0.17412623763084412, 0.10747305303812027, -0.16726334393024445, 0.16986072063446045, -0.14071738719940186, -0.006694022566080093, 0.12976276874542236, -0.01660667359828949, -0.0419958271086216, 0.13126102089881897, 0.3388569951057434, 0.15892653167247772, 0.12180104851722717, 0.012453190982341766, 0.10840906202793121, -0.03220733255147934, -0.1915844976902008, 0.6557568907737732, -0.5699251890182495, 0.23186787962913513, -0.2742355763912201, 0.4845484495162964, -0.12092557549476624, 0.4307538866996765, -0.05699940025806427, 0.08450722694396973, 0.0762370303273201, 0.18847590684890747, -0.15347999334335327, -0.1152411550283432, -0.1883612424135208, 0.2701907455921173, 0.20726273953914642, 0.16286781430244446, 0.25197386741638184, -0.026220370084047318, 0.12311576306819916, -0.11091918498277664, -0.12098909914493561, 0.19479481875896454, 0.11741822212934494, -0.06199600547552109, 0.13293138146400452, 0.3996729254722595, -0.13662540912628174, -0.09661759436130524, 0.04787404462695122, -0.02310355380177498, 0.1989782452583313, -0.2719237506389618, 0.12057125568389893, -0.12081392854452133, 0.3404010534286499, -0.5893972516059875, -0.430893212556839, 0.057685792446136475, -0.14966174960136414, 0.034696463495492935, 0.1952284872531891, 0.22170722484588623, 0.17774535715579987, -0.27144673466682434, 0.1010623574256897, -0.03217163309454918, 0.028844136744737625, -0.024790383875370026, 0.04728183522820473, 0.14161622524261475, 0.03558271750807762, 0.07501791417598724, 0.08888483047485352, -0.001868177205324173, 0.051985159516334534, -0.1933540403842926, 0.2955680191516876, 0.1834586262702942, 0.2472175657749176, -0.07218030095100403, 0.136850506067276, -0.22419041395187378, 0.13761037588119507, -0.10268442332744598, 0.0603213906288147, 0.026555299758911133, -0.1091480553150177, 0.21821293234825134, -0.11308281868696213, -0.13152211904525757, 0.19286352396011353, 0.3192858099937439, -0.012461934238672256, 0.30337268114089966, 0.04482726380228996, -0.012438572943210602, 0.23532527685165405, -0.15076756477355957, -0.1532447189092636, -0.16068781912326813, 0.0694715678691864, 0.1325065940618515, 0.14105704426765442, 0.06772339344024658, 0.1816546469926834, -0.17110714316368103, 0.05194023996591568, -0.40163880586624146, -0.17234084010124207, 0.22673457860946655, 0.32152169942855835, 0.17046424746513367, -0.016182631254196167, -0.21622619032859802, -0.09992662072181702, -0.008002884685993195, -0.0753265768289566, -0.028915833681821823, 0.06161409243941307, -0.1912156045436859, 0.061732809990644455, 0.3593623638153076, 0.10088416934013367, 0.05040727183222771, 0.0643593817949295, -0.0499664768576622, -0.13194149732589722, 0.0019848719239234924, 0.0703636109828949, 0.05912050977349281, -0.03478502854704857, 0.1274060755968094, 0.06996076554059982, 0.11320624500513077, 0.02112395316362381, -0.05941192805767059, 0.40345439314842224, 0.15488897264003754, -0.07088103145360947, 0.06277302652597427, -0.14311812818050385, 0.010530613362789154, -0.08501526713371277, -0.3376390337944031, 0.1337713748216629, 0.20734426379203796, 0.1233540028333664, 0.07265826314687729, 0.10436614602804184, 0.04088415578007698, -0.04737698286771774, 0.08695964515209198, -0.1281231790781021, -0.16778066754341125, 0.020470082759857178, -0.11055467277765274, 0.12501093745231628, 0.035548560321331024, 0.2729344069957733, 0.10633856058120728, 0.06410682201385498, 0.21673482656478882, 0.013604603707790375, 0.01955176144838333, -0.03739538788795471, 0.025226138532161713, -0.09106118977069855, -0.2355227917432785, 0.03117331489920616, -0.1805265247821808, 0.01412010658532381, 0.10273774713277817, 0.13511186838150024, 0.024617556482553482, 0.0559869259595871, -0.2619677186012268, 0.3610233664512634, 0.1287059783935547, -0.18787580728530884, 0.010506130754947662, -0.048756785690784454, 0.12055930495262146, 0.11166225373744965, 0.10814627259969711, 0.256560742855072, 0.1843799650669098, -0.02061818167567253, 0.15247270464897156, 0.38611406087875366, -0.16897137463092804, 0.018417511135339737, 0.1419752836227417, -0.010287009179592133, -0.12854065001010895, -0.17104442417621613, -0.1494574248790741, -0.03228185325860977, 0.0445556715130806, 0.1872136890888214, -0.17939072847366333, -0.1090441569685936, -0.15568453073501587, 0.12510383129119873, 0.010273605585098267, 0.024395588785409927, 0.0880613923072815, -0.011092215776443481, -0.02885671705007553, -0.13660717010498047, 0.4380183219909668, -0.139277845621109, -0.17601726949214935, -0.0851355791091919, -0.09313399344682693, -0.05477768927812576, 0.020570842549204826, 0.12349778413772583, 0.028065264225006104, 0.17961490154266357, 0.17274686694145203, -0.04644716531038284, -0.03938017413020134, 0.1272582709789276, 0.2557700276374817, -0.11229342222213745, 0.01658068783581257, 0.06027660891413689, 0.042829062789678574, 0.27983877062797546, -0.104680635035038, -0.1759643703699112, -0.1600838601589203, 0.19550389051437378, -0.11168894171714783, 0.18753117322921753, 0.010319504886865616, 0.22582146525382996, 0.16011977195739746, -0.08844903111457825, -0.05021056532859802, -0.0816996693611145, -0.6913273930549622, -0.05769640579819679, 0.15877431631088257, 0.021728966385126114, 0.07327850908041, 0.1814652979373932, 0.08674029260873795, 0.07911120355129242, 0.10836951434612274, 0.07190147042274475, -0.0006756819784641266, 0.15576928853988647, 0.26546597480773926, -0.10217003524303436, -0.10832090675830841, 0.15399125218391418, 0.14361421763896942, -0.26960957050323486, 0.27804672718048096, -0.11731558293104172, -0.2101261019706726, 0.07449006289243698, 0.4466541111469269, 0.004074722528457642, 0.010212481021881104, 0.24510467052459717, 0.05380788445472717, 0.2355920821428299, -0.0893150120973587, 0.038227636367082596, 0.4244750142097473, 0.19146694242954254, -0.39267852902412415, 0.04396916925907135, 0.1907329112291336, 0.13823245465755463, 0.031124453991651535, 13.879777908325195, -0.07658956944942474, 0.3129447102546692, -0.24912691116333008, -0.09964872151613235, 0.03964091092348099, -0.11958669871091843, 0.0051755234599113464, 0.006260104477405548, -0.07806536555290222, 0.07051438838243484, -0.12355269491672516, -0.09184729307889938, -0.03614617511630058, -0.09857377409934998, -0.030538126826286316, -0.035896942019462585, -0.1326625645160675, 0.15849998593330383, 0.00899583101272583, -0.2341567873954773, -0.0709260106086731, -0.09842514991760254, -0.40229132771492004, 0.014628550037741661, -0.10006553679704666, 0.08998081088066101, 0.14460687339305878, 0.007506661117076874, 0.14999258518218994, 0.2089480757713318, 0.18954578042030334, 0.10940994322299957, -0.018139995634555817, 0.013606719672679901, -0.08344683796167374, -0.40664058923721313, -0.18028877675533295, 0.09124129265546799, 0.020740512758493423, -0.019728288054466248, 0.016732461750507355, 0.18022696673870087, -0.07799013704061508, 0.12896908819675446, 0.0891861841082573, -0.32147786021232605, 0.14572353661060333, -0.10598134249448776, -0.040037475526332855, 0.24322491884231567, 0.09510935842990875, 0.3665856122970581, 0.07881765067577362, -0.13278377056121826, -0.24415090680122375, 0.3454926311969757, -0.09549981355667114, -0.06727492809295654, 0.49688291549682617, 0.014167241752147675, -0.055149950087070465, -0.07668153941631317, 0.015115384012460709, -0.0071161407977342606, 0.03764475882053375, 0.045744165778160095, 0.0004349052906036377, -0.3723791241645813, 0.15520033240318298, 0.27309736609458923, -0.313691645860672, 0.23030678927898407, -0.01741167902946472, -0.10497868806123734, 0.12846210598945618, 0.07106296718120575, -0.06797517836093903, 0.052088357508182526, -0.17323124408721924, -0.004297591745853424, 0.10210102051496506, -0.20259840786457062, -0.18304668366909027, -0.3566306233406067, 0.020517498254776, 0.05963787063956261, 0.34201204776763916, 0.2529427707195282, -0.08994455635547638, 0.019588850438594818, 0.09306365996599197, 0.022291284054517746, -0.23740512132644653, 0.199966698884964, 0.024374034255743027, -0.14763693511486053, -0.23042504489421844, 0.02533148042857647, 0.19182714819908142, -0.031290799379348755, -0.09610971808433533, 0.018816310912370682, -0.004126057028770447, -0.0971449613571167, -0.03199908882379532, -0.04776231199502945, -0.03671307861804962, -0.039117760956287384, 0.06967569887638092, 0.08281248807907104, 0.10751849412918091, 0.1932229846715927, -0.21300284564495087, -0.1871068924665451, -0.03814676031470299, -0.0386299304664135, 0.04935456067323685, 0.20439258217811584, 0.13716477155685425, 0.19332663714885712, 0.09051844477653503, -0.15376371145248413, -0.0035991370677948, 0.09157859534025192, -0.26041704416275024, 0.0059685856103897095, 0.15125901997089386, 0.0073950160294771194, -0.060080062597990036, 0.0055904872715473175, -0.06333809345960617, 0.533291220664978, 0.10661951452493668, 0.08076096326112747, -0.08519712090492249, 0.06070122867822647, 0.008632674813270569, 0.1354639232158661, 0.34368208050727844, 0.06329643726348877, -0.08279500901699066, 0.1713150143623352, -0.18535318970680237, -0.02232910692691803, 0.40958794951438904, 0.14005309343338013, 0.055059514939785004, -0.16802285611629486, 0.18753401935100555, 0.13944406807422638, 0.24667057394981384, -0.3447721004486084, -0.1452254056930542, -0.09837694466114044, -0.1957084685564041, -0.2399357706308365, 0.03427346050739288, -0.0806555524468422, 0.003045717254281044, 0.19076362252235413, -0.306841641664505, 0.2152353972196579, -0.3417196571826935, 0.015557844191789627, -0.00041208416223526, 0.014665864408016205, 0.18086978793144226, 0.22746922075748444, -0.08505051583051682, 0.05909791961312294, 0.10137319564819336, -0.1370118111371994, 0.0687200203537941, -0.12058423459529877, 0.10854049026966095, 0.35909393429756165, -0.502016544342041, -0.19084006547927856, 0.082147516310215]}"
"{\"sha\": \"8490a88f377d8fed802e4f3b2d1d87a0d6cb81b2\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"src/sized/cc_array_sized.c\", \"func_name\": \"cc_array_sized_zip_iter_replace\", \"original_string\": \"enum cc_stat cc_array_sized_zip_iter_replace(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    cc_array_sized_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_sized_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\", \"code_tokens\": [\"enum\", \"cc_stat\", \"cc_array_sized_zip_iter_replace\", \"(\", \"CC_ArraySizedZipIter\", \"*\", \"iter\", \",\", \"uint8_t\", \"*\", \"e1\", \",\", \"uint8_t\", \"*\", \"e2\", \",\", \"uint8_t\", \"*\", \"out1\", \",\", \"uint8_t\", \"*\", \"out2\", \")\", \"{\", \"if\", \"(\", \"(\", \"iter\", \"->\", \"index\", \"-\", \"1\", \")\", \">=\", \"iter\", \"->\", \"ar1\", \"->\", \"size\", \"||\", \"(\", \"iter\", \"->\", \"index\", \"-\", \"1\", \")\", \">=\", \"iter\", \"->\", \"ar2\", \"->\", \"size\", \")\", \"{\", \"return\", \"CC_ERR_OUT_OF_RANGE\", \";\", \"}\", \"cc_array_sized_replace_at\", \"(\", \"iter\", \"->\", \"ar1\", \",\", \"e1\", \",\", \"iter\", \"->\", \"index\", \"-\", \"1\", \",\", \"out1\", \")\", \";\", \"cc_array_sized_replace_at\", \"(\", \"iter\", \"->\", \"ar2\", \",\", \"e2\", \",\", \"iter\", \"->\", \"index\", \"-\", \"1\", \",\", \"out2\", \")\", \";\", \"return\", \"CC_OK\", \";\", \"}\"], \"docstring\": \"/**\\n * Replaces the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\", \"docstring_tokens\": [\"/\", \"**\", \"*\", \"Replaces\", \"the\", \"last\", \"returned\", \"element\", \"pair\", \"by\", \"<code\", \">\", \"cc_array_sized_zip_iter_next\", \"()\", \"<\", \"/\", \"code\", \">\", \"*\", \"with\", \"the\", \"specified\", \"replacement\", \"element\", \"pair\", \".\", \"*\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"iter\", \"iterator\", \"on\", \"which\", \"this\", \"operation\", \"is\", \"being\", \"performed\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"e1\", \"first\", \"array\", \"'\", \"s\", \"replacement\", \"element\", \"*\", \"@param\", \"[\", \"in\", \"]\", \"e2\", \"second\", \"array\", \"'\", \"s\", \"replacement\", \"element\", \"*\", \"@param\", \"[\", \"out\", \"]\", \"out1\", \"output\", \"of\", \"the\", \"replaced\", \"element\", \"from\", \"the\", \"first\", \"array\", \"*\", \"@param\", \"[\", \"out\", \"]\", \"out2\", \"output\", \"of\", \"the\", \"replaced\", \"element\", \"from\", \"the\", \"second\", \"array\", \"*\", \"*\", \"@return\", \"CC_OK\", \"if\", \"the\", \"element\", \"was\", \"successfully\", \"replaced\", \"or\", \"CC_ERR_OUT_OF_RANGE\", \".\", \"*\", \"/\"], \"raw_contents\": \"/*\\n * Collections-C\\n * Copyright (C) 2013-2024 Sr\\u0111an Pani\\u0107 <srdja.panic@gmail.com>\\n *\\n * This file is part of Collections-C.\\n *\\n * Collections-C is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Lesser General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n *\\n * Collections-C is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n * GNU Lesser General Public License for more details.\\n *\\n * You should have received a copy of the GNU Lesser General Public License\\n * along with Collections-C.  If not, see <http://www.gnu.org/licenses/>.\\n */\\n\\n\\n#include \\\"sized/cc_array_sized.h\\\"\\n\\n#define DEFAULT_CAPACITY 8\\n#define DEFAULT_EXPANSION_FACTOR 2\\n\\n#define INDEX(a, i) a->data_length * i\\n#define BUF_ADDR(a, i) &a->buffer[a->data_length * i]\\n\\n\\nstruct cc_array_sized_s {\\n    size_t   data_length;\\n    size_t   size;\\n    size_t   capacity;\\n    float    exp_factor;\\n    uint8_t *buffer;\\n\\n    void *(*mem_alloc)  (size_t size);\\n    void *(*mem_calloc) (size_t blocks, size_t size);\\n    void  (*mem_free)   (void *block);\\n};\\n\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar);\\n\\n\\n/**\\n * Creates a new empty array and returns a status code.\\n *\\n * @param[in] Size of the array element in bytes\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, or CC_ERR_ALLOC if the\\n * memory allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new(size_t element_size, CC_ArraySized **out)\\n{\\n    CC_ArraySizedConf c;\\n    cc_array_sized_conf_init(&c);\\n    return cc_array_sized_new_conf(element_size, &c, out);\\n}\\n\\n/**\\n * Creates a new empty CC_ArraySized based on the specified CC_ArraySizedConf struct \\n * and returns a status code.\\n *\\n * The CC_ArraySized is allocated using the allocators specified in the CC_ArraySizedConf\\n * struct. The allocation may fail if underlying allocator fails. It may also\\n * fail if the values of exp_factor and capacity in the CC_ArraySizedConf do not meet\\n * the following condition: <code>exp_factor < (CC_MAX_ELEMENTS / capacity)</code>.\\n *\\n * @param[in] element_size the size of the data being stored in bytes\\n * @param[in] conf array configuration structure\\n * @param[out] out pointer to where the newly created CC_ArraySized is to be stored\\n *\\n * @return CC_OK if the creation was successful, CC_ERR_INVALID_CAPACITY if\\n * the above mentioned condition is not met, or CC_ERR_ALLOC if the memory\\n * allocation for the new CC_ArraySized structure failed.\\n */\\nenum cc_stat cc_array_sized_new_conf(\\n    size_t element_size, \\n    CC_ArraySizedConf const * const conf, \\n    CC_ArraySized **out)\\n{\\n    float ex;\\n\\n    /* The expansion factor must be greater than one for the\\n     * array to grow */\\n    if (conf->exp_factor <= 1)\\n        ex = DEFAULT_EXPANSION_FACTOR;\\n    else\\n        ex = conf->exp_factor;\\n\\n    /* Needed to avoid an integer overflow on the first resize and\\n     * to easily check for any future overflows. */\\n    if (!conf->capacity || ex >= CC_MAX_ELEMENTS / conf->capacity)\\n        return CC_ERR_INVALID_CAPACITY;\\n\\n    CC_ArraySized *ar = conf->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!ar)\\n        return CC_ERR_ALLOC;\\n\\n    uint8_t *buff = conf->mem_alloc(conf->capacity * element_size);\\n\\n    if (!buff) {\\n        conf->mem_free(ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    ar->data_length = element_size;\\n    ar->buffer      = buff;\\n    ar->exp_factor  = ex;\\n    ar->capacity    = conf->capacity;\\n    ar->mem_alloc   = conf->mem_alloc;\\n    ar->mem_calloc  = conf->mem_calloc;\\n    ar->mem_free    = conf->mem_free;\\n\\n    *out = ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Initializes the fields of the CC_ArraySizedConf struct to default values.\\n *\\n * @param[in, out] conf CC_ArraySizedConf structure that is being initialized\\n */\\nvoid cc_array_sized_conf_init(CC_ArraySizedConf *conf)\\n{\\n    conf->exp_factor = DEFAULT_EXPANSION_FACTOR;\\n    conf->capacity   = DEFAULT_CAPACITY;\\n    conf->mem_alloc  = malloc;\\n    conf->mem_calloc = calloc;\\n    conf->mem_free   = free;\\n}\\n\\n/**\\n * Destroys the CC_ArraySized structure, but leaves the data it used to hold intact.\\n *\\n * @param[in] ar the array that is to be destroyed\\n */\\nvoid cc_array_sized_destroy(CC_ArraySized *ar)\\n{\\n    ar->mem_free(ar->buffer);\\n    ar->mem_free(ar);\\n}\\n\\n\\n/**\\n * Adds a new element to the CC_ArraySized. The element is appended to the array making\\n * it the last element (the one with the highest index) of the CC_ArraySized.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add(CC_ArraySized *ar, uint8_t *element)\\n{\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    memcpy(BUF_ADDR(ar, ar->size), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Adds a new element to the array at a specified position by shifting all\\n * subsequent elements by one. The specified index must be within the bounds\\n * of the array. This function may also fail if the memory allocation for\\n * the new element was unsuccessful.\\n *\\n * @param[in] ar the array to which the element is being added\\n * @param[in] element the element that is being added\\n * @param[in] index the position in the array at which the element is being\\n *            added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_OUT_OF_RANGE if\\n * the specified index was not in range, CC_ERR_ALLOC if the memory\\n * allocation for the new element failed, or CC_ERR_MAX_CAPACITY if the\\n * array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_add_at(CC_ArraySized *ar, uint8_t *element, size_t index)\\n{\\n    if (index == ar->size)\\n        return cc_array_sized_add(ar, element);\\n\\n    if ((ar->size == 0 && index != 0) || index > (ar->size - 1))\\n        return CC_ERR_OUT_OF_RANGE;\\n\\n    if (ar->size >= ar->capacity) {\\n        enum cc_stat status = expand_capacity(ar);\\n        if (status != CC_OK)\\n            return status;\\n    }\\n\\n    size_t shift = (ar->size - index) * ar->data_length;\\n\\n    memmove(BUF_ADDR(ar, (index + 1)),\\n            BUF_ADDR(ar, index),\\n            shift);\\n\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n    ar->size++;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces an array element at the specified index and optionally sets the out\\n * parameter to the value of the replaced element. The specified index must be\\n * within the bounds of the CC_ArraySized.\\n *\\n * @param[in]  ar      array whose element is being replaced\\n * @param[in]  element replacement element\\n * @param[in]  index   index at which the replacement element should be inserted\\n * @param[out] out     pointer to where the replaced element is stored, or NULL if\\n *                     it is to be ignored\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE\\n *         if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_replace_at(CC_ArraySized *ar, uint8_t *element, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n    memcpy(BUF_ADDR(ar, index), element, ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n* Swaps the values at the specified indices.\\n*\\n* @param[in] ar array whose elements are being swapped\\n* @param[in] index1 first position\\n* @param[in] index2 second position\\n* \\n* @return CC_OK if the operation was successful, or CC_ERR_OUT_OF_RANGE if \\n* one of the indices was out of range.\\n*/\\nenum cc_stat cc_array_sized_swap_at(CC_ArraySized *ar, size_t index1, size_t index2)\\n{\\n    if (index1 >= ar->size || index2 >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n\\n    for (size_t i = 0; i < ar->data_length; i++) {\\n        uint8_t tmp = ar->buffer[INDEX(ar, index1 + i)];\\n        ar->buffer[INDEX(ar, index1 + i)] = ar->buffer[INDEX(ar, index2 + i)];\\n        ar->buffer[INDEX(ar, index2 + i)] = tmp;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the specified element from the CC_ArraySized if such element exists and\\n * optionally sets the out parameter to the value of the removed element.\\n *\\n * @param[in] ar array from which the element is being removed\\n * @param[in] element element being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND if the element was not found.\\n */\\nenum cc_stat cc_array_sized_remove(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t index;\\n    enum cc_stat status = cc_array_sized_index_of(ar, element, &index);\\n\\n    if (status == CC_ERR_OUT_OF_RANGE) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n \\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the specified index and optionally sets the\\n * out parameter to the value of the removed element. The index must be within\\n * the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being removed\\n * @param[in] index the index of the element being removed.\\n * @param[out] out  pointer to where the removed value is stored,\\n *                  or NULL if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the index was out of range.\\n */\\nenum cc_stat cc_array_sized_remove_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (out) {\\n        memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n    }\\n\\n    if (index != ar->size - 1) {\\n        size_t block_size = (ar->size - 1 - index) * ar->data_length;\\n\\n        memmove(BUF_ADDR(ar, index),\\n                BUF_ADDR(ar, (index + 1)),\\n                block_size);\\n    }\\n    ar->size--;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes an CC_ArraySized element from the end of the array and optionally sets the\\n * out parameter to the value of the removed element.\\n *\\n * @param[in] ar the array whose last element is being removed\\n * @param[out] out pointer to where the removed value is stored, or NULL if it is\\n *                 to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is already empty.\\n */\\nenum cc_stat cc_array_sized_remove_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    return cc_array_sized_remove_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n * Removes all elements from the specified array. This function does not shrink\\n * the array capacity.\\n *\\n * @param[in] ar array from which all elements are to be removed\\n */\\nvoid cc_array_sized_remove_all(CC_ArraySized *ar)\\n{\\n    ar->size = 0;\\n}\\n\\n/**\\n * Copies an CC_ArraySized element from the specified index to the out pointer.\\n * The specified index must be within the bounds of the array.\\n *\\n * @param[in] ar the array from which the element is being retrieved\\n * @param[in] source index of the array element\\n * @param[out] destination address\\n *\\n * @return CC_OK if the element was found, or CC_ERR_OUT_OF_RANGE if the index\\n * was out of range.\\n */\\nenum cc_stat cc_array_sized_get_at(CC_ArraySized *ar, size_t index, uint8_t *out)\\n{\\n    if (index >= ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    memcpy(out, BUF_ADDR(ar, index), ar->data_length);\\n\\n    return CC_OK;\\n}\\n\\n\\n/**\\n * Gets the last element of the array or the element at the highest index\\n * and sets the out parameter to its value.\\n *\\n * @param[in] ar the array whose last element is being returned\\n * @param[out] out pointer to where the element is stored\\n *\\n * @return CC_OK if the element was found, or CC_ERR_VALUE_NOT_FOUND if the\\n * CC_Array is empty.\\n */\\nenum cc_stat cc_array_sized_get_last(CC_ArraySized *ar, uint8_t *out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_VALUE_NOT_FOUND;\\n    }\\n    return cc_array_sized_get_at(ar, ar->size - 1, out);\\n}\\n\\n/**\\n* Returns the pointer to the element at the specified index\\n*/\\nenum cc_stat cc_array_sized_peek(CC_ArraySized* ar, size_t index, uint8_t** out)\\n{\\n    if (index > ar->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    *out = BUF_ADDR(ar, index);\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the underlying array buffer.\\n *\\n * @note Any direct modification of the buffer may invalidate the CC_Array.\\n *\\n * @param[in] ar array whose underlying buffer is being returned\\n *\\n * @return array's internal buffer.\\n */\\nconst uint8_t * const* cc_array_sized_get_buffer(CC_ArraySized *ar)\\n{\\n    return (const uint8_t* const*) ar->buffer;\\n}\\n\\n/**\\n * Gets the index of the specified element. The returned index is the index\\n * of the first occurrence of the element starting from the beginning of the\\n * CC_ArraySized.\\n *\\n * @param[in] ar array being searched\\n * @param[in] element the element whose index is being looked up\\n * @param[out] index  pointer to where the index is stored\\n *\\n * @return CC_OK if the index was found, or CC_OUT_OF_RANGE if not.\\n */\\nenum cc_stat cc_array_sized_index_of(CC_ArraySized *ar, uint8_t *element, size_t *index)\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) { \\n            // Mismatching byte, skip to next block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            if (j == ar->data_length - 1) {\\n                *index = i;\\n                return CC_OK;\\n            }\\n        }\\n    }\\n    return CC_ERR_OUT_OF_RANGE;\\n}\\n\\n/**\\n * Creates a subarray of the specified CC_ArraySized, ranging from <code>b</code>\\n * index (inclusive) to <code>e</code> index (inclusive). The range indices\\n * must be within the bounds of the CC_ArraySized, while the <code>e</code> index\\n * must be greater or equal to the <code>b</code> index.\\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's allocators\\n *       and it also inherits the configuration of the original CC_ArraySized.\\n *\\n * @param[in] ar array from which the subarray is being created\\n * @param[in] b the beginning index (inclusive) of the subarray that must be\\n *              within the bounds of the array and must not exceed the\\n *              the end index\\n * @param[in] e the end index (inclusive) of the subarray that must be within\\n *              the bounds of the array and must be greater or equal to the\\n *              beginning index\\n * @param[out] out pointer to where the new sublist is stored\\n *\\n * @return CC_OK if the subarray was successfully created, CC_ERR_INVALID_RANGE\\n * if the specified index range is invalid, or CC_ERR_ALLOC if the memory allocation\\n * for the new subarray failed.\\n */\\nenum cc_stat cc_array_sized_subarray(CC_ArraySized *ar, size_t b, size_t e, CC_ArraySized **out)\\n{\\n    if (b > e || e >= ar->size)\\n        return CC_ERR_INVALID_RANGE;\\n\\n    CC_ArraySized *sub_ar = ar->mem_calloc(1, sizeof(CC_ArraySized));\\n\\n    if (!sub_ar)\\n        return CC_ERR_ALLOC;\\n\\n    /* Try to allocate the buffer */\\n    if (!(sub_ar->buffer = ar->mem_alloc(ar->capacity * ar->data_length))) {\\n        ar->mem_free(sub_ar);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    sub_ar->mem_alloc   = ar->mem_alloc;\\n    sub_ar->mem_calloc  = ar->mem_calloc;\\n    sub_ar->mem_free    = ar->mem_free;\\n    sub_ar->size        = e - b + 1;\\n    sub_ar->capacity    = sub_ar->size;\\n    sub_ar->data_length = ar->data_length;\\n\\n    memcpy(sub_ar->buffer,\\n           BUF_ADDR(ar, b),\\n           sub_ar->size * ar->data_length);\\n\\n    *out = sub_ar;\\n    return CC_OK;\\n}\\n\\n/**\\n * Creates a copy of the specified CC_ArraySized. \\n *\\n * @note The new CC_ArraySized is allocated using the original CC_ArraySized's\\n *       allocators and it also inherits the configuration of the original array.\\n *\\n * @param[in] ar the array to be copied\\n * @param[out] out pointer to where the newly created copy is stored\\n *\\n * @return CC_OK if the copy was successfully created, or CC_ERR_ALLOC if the\\n * memory allocation for the copy failed.\\n */\\nenum cc_stat cc_array_sized_copy(CC_ArraySized *ar, CC_ArraySized **out)\\n{\\n    CC_ArraySized *copy = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!copy)\\n        return CC_ERR_ALLOC;\\n\\n    if (!(copy->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(copy);\\n        return CC_ERR_ALLOC;\\n    }\\n    copy->data_length = ar->data_length;\\n    copy->exp_factor  = ar->exp_factor;\\n    copy->size        = ar->size;\\n    copy->capacity    = ar->capacity;\\n    copy->mem_alloc   = ar->mem_alloc;\\n    copy->mem_calloc  = ar->mem_calloc;\\n    copy->mem_free    = ar->mem_free;\\n\\n    memcpy(copy->buffer,\\n           ar->buffer,\\n           copy->size * ar->data_length);\\n\\n    *out = copy;\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by modifying it. It removes all elements that don't\\n * return true on pred(element).\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the CC_Array\\n *\\n * @return CC_OK if the CC_ArraySized was filtered successfully, or CC_ERR_OUT_OF_RANGE\\n * if the CC_ArraySized is empty.\\n */\\nenum cc_stat cc_array_sized_filter_mut(CC_ArraySized *ar, bool (*pred) (const uint8_t*))\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    size_t rm   = 0;\\n    size_t keep = 0;\\n\\n    /* Look for clusters of non matching elements before moving\\n     * in order to minimize the number of memmoves */\\n    for (size_t i = ar->size - 1; i != ((size_t) - 1); i--) {\\n        if (!pred(BUF_ADDR(ar, i))) {\\n            rm++;\\n            continue;\\n        }\\n        if (rm > 0) {\\n            if (keep > 0) {\\n                size_t block_size = keep * ar->data_length;\\n                memmove(BUF_ADDR(ar, (i + 1)),\\n                        BUF_ADDR(ar, (i + 1 + rm)),\\n                        block_size);\\n            }\\n            ar->size -= rm;\\n            rm = 0;\\n        }\\n        keep++;\\n    }\\n    /* Remove any remaining elements*/\\n    if (rm > 0) {\\n        size_t block_size = keep * ar->data_length;\\n        memmove(BUF_ADDR(ar, 0),\\n                BUF_ADDR(ar, rm),\\n                block_size);\\n\\n        ar->size -= rm;\\n    }\\n    return CC_OK;\\n}\\n\\n/**\\n * Filters the CC_ArraySized by creating a new CC_ArraySized that contains all elements\\n * from the original CC_ArraySized that return true on pred(element) without modifying \\n * the original CC_ArraySized.\\n *\\n * @param[in] ar   array that is to be filtered\\n * @param[in] pred predicate function which returns true if the element should\\n *                 be kept in the filtered array\\n * @param[out] out pointer to where the new filtered CC_Array is to be stored\\n *\\n * @return CC_OK if the CC_Array was filtered successfully, CC_ERR_OUT_OF_RANGE\\n * if the CC_Array is empty, or CC_ERR_ALLOC if the memory allocation for the\\n * new CC_Array failed.\\n */\\nenum cc_stat cc_array_sized_filter(CC_ArraySized *ar, bool (*pred) (const uint8_t*), CC_ArraySized **out)\\n{\\n    if (ar->size == 0) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    CC_ArraySized *filtered = ar->mem_alloc(sizeof(CC_ArraySized));\\n\\n    if (!filtered) {\\n        return CC_ERR_ALLOC;\\n    }\\n    if (!(filtered->buffer = ar->mem_calloc(ar->capacity, ar->data_length))) {\\n        ar->mem_free(filtered);\\n        return CC_ERR_ALLOC;\\n    }\\n\\n    filtered->data_length = ar->data_length;\\n    filtered->exp_factor  = ar->exp_factor;\\n    filtered->size        = 0;\\n    filtered->capacity    = ar->capacity;\\n    filtered->mem_alloc   = ar->mem_alloc;\\n    filtered->mem_calloc  = ar->mem_calloc;\\n    filtered->mem_free    = ar->mem_free;\\n\\n    size_t f = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        if (pred(BUF_ADDR(ar, i))) {\\n            memcpy(BUF_ADDR(filtered, f++), \\n                   BUF_ADDR(ar, i),\\n                   ar->data_length);\\n            filtered->size++;\\n        }\\n    }\\n    *out = filtered;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Reverses the order of elements in the specified array.\\n *\\n * @param[in] ar array that is being reversed\\n */\\nvoid cc_array_sized_reverse(CC_ArraySized *ar, uint8_t *tmp)\\n{\\n    if (ar->size == 0) {\\n        return;\\n    }\\n    size_t i;\\n    size_t j;\\n    for (i = 0, j = ar->size - 1; i < ar->size / 2; i++, j--) {\\n        memcpy(tmp, BUF_ADDR(ar, i), ar->data_length);\\n        memcpy(BUF_ADDR(ar, i), BUF_ADDR(ar, j), ar->data_length);\\n        memcpy(BUF_ADDR(ar, j), tmp, ar->data_length);\\n    }\\n}\\n\\n/**\\n * Trims the array's capacity, in other words, it shrinks the capacity to match\\n * the number of elements in the CC_ArraySized, however the capacity will never shrink\\n * below 1.\\n *\\n * @param[in] ar array whose capacity is being trimmed\\n *\\n * @return CC_OK if the capacity was trimmed successfully, or CC_ERR_ALLOC if\\n * the reallocation failed.\\n */\\nenum cc_stat cc_array_sized_trim_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->size == ar->capacity) {\\n        return CC_OK;\\n    }\\n    uint8_t *new_buff = ar->mem_calloc(ar->size, ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    size_t size = ar->size < 1 ? 1 : ar->size;\\n\\n    memcpy(new_buff, ar->buffer, size * ar->data_length);\\n    ar->mem_free(ar->buffer);\\n\\n    ar->buffer   = new_buff;\\n    ar->capacity = ar->size;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the number of occurrences of the element within the specified CC_ArraySized.\\n *\\n * @param[in] ar array that is being searched\\n * @param[in] element the element that is being searched for\\n *\\n * @return the number of occurrences of the element.\\n */\\nsize_t cc_array_sized_contains(CC_ArraySized *ar, uint8_t *element)\\n{\\n    size_t o = 0;\\n    for (size_t i = 0; i < ar->size; i++) {\\n        for (size_t j = 0; j < ar->data_length; j++) {\\n            // Mismatching byte, skip block\\n            if (ar->buffer[INDEX(ar, i + j)] != *(element + j)) {\\n                break;\\n            }\\n            // Last byte is equal, match found\\n            if (j == ar->data_length - 1) {\\n                o++;\\n            }\\n        }\\n    }\\n    return o;\\n}\\n\\n/**\\n * Returns the size of the specified CC_ArraySized. The size of the array is the\\n * number of elements contained within the CC_ArraySized.\\n *\\n * @param[in] ar array whose size is being returned\\n *\\n * @return the the number of element within the CC_ArraySized.\\n */\\nsize_t cc_array_sized_size(CC_ArraySized *ar)\\n{\\n    return ar->size;\\n}\\n\\n/**\\n * Returns the capacity of the specified CC_ArraySized. The capacity of the CC_ArraySized is\\n * the maximum number of elements an CC_ArraySized can hold before it has to be resized.\\n *\\n * @param[in] ar array whose capacity is being returned\\n *\\n * @return the capacity of the CC_ArraySized.\\n */\\nsize_t cc_array_sized_capacity(CC_ArraySized *ar)\\n{\\n    return ar->capacity;\\n}\\n\\n/**\\n * Sorts the specified array.\\n *\\n * @note\\n * Pointers passed to the comparator function will be pointers to the array\\n * elements that are of type (void*) ie. void**. So an extra step of\\n * dereferencing will be required before the data can be used for comparison:\\n * eg. <code>my_type e = *(*((my_type**) ptr));</code>.\\n *\\n * @code\\n * enum cc_stat mycmp(const void *e1, const void *e2) {\\n *     MyType el1 = *(*((enum cc_stat**) e1));\\n *     MyType el2 = *(*((enum cc_stat**) e2));\\n *\\n *     if (el1 < el2) return -1;\\n *     if (el1 > el2) return 1;\\n *     return 0;\\n * }\\n *\\n * ...\\n *\\n * cc_array_sort(array, mycmp);\\n * @endcode\\n *\\n * @param[in] ar  array to be sorted\\n * @param[in] cmp the comparator function that must be of type <code>\\n *                enum cc_stat cmp(const void e1*, const void e2*)</code> that\\n *                returns < 0 if the first element goes before the second,\\n *                0 if the elements are equal and > 0 if the second goes\\n *                before the first\\n */\\nvoid cc_array_sized_sort(CC_ArraySized *ar, int (*cmp) (const void*, const void*))\\n{\\n    qsort(ar->buffer, ar->size, ar->data_length, cmp);\\n}\\n\\n/**\\n * Expands the CC_ArraySized capacity. This might fail if the the new buffer\\n * cannot be allocated. In case the expansion would overflow the index\\n * range, a maximum capacity buffer is allocated instead. If the capacity\\n * is already at the maximum capacity, no new buffer is allocated.\\n *\\n * @param[in] ar array whose capacity is being expanded\\n *\\n * @return CC_OK if the buffer was expanded successfully, CC_ERR_ALLOC if\\n * the memory allocation for the new buffer failed, or CC_ERR_MAX_CAPACITY\\n * if the array is already at maximum capacity.\\n */\\nstatic enum cc_stat expand_capacity(CC_ArraySized *ar)\\n{\\n    if (ar->capacity == CC_MAX_ELEMENTS) {\\n        return CC_ERR_MAX_CAPACITY;\\n    }\\n\\n    size_t new_capacity = (size_t) (ar->capacity * ar->exp_factor);\\n\\n    /* As long as the capacity is greater that the expansion factor\\n     * at the point of overflow, this is check is valid. */\\n    if (new_capacity <= ar->capacity) {\\n        ar->capacity = CC_MAX_ELEMENTS;\\n    } else {\\n        ar->capacity = new_capacity;\\n    }\\n    uint8_t *new_buff = ar->mem_alloc(ar->capacity * ar->data_length);\\n\\n    if (!new_buff) {\\n        return CC_ERR_ALLOC;\\n    }\\n    memcpy(new_buff, ar->buffer, ar->size * ar->data_length);\\n\\n    ar->mem_free(ar->buffer);\\n    ar->buffer = new_buff;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Applies the function fn to each element of the CC_Array.\\n *\\n * @param[in] ar array on which this operation is performed\\n * @param[in] fn operation function that is to be invoked on each CC_Array\\n *               element\\n */\\nvoid cc_array_sized_map(CC_ArraySized *ar, void (*fn) (uint8_t *e))\\n{\\n    for (size_t i = 0; i < ar->size; i++) {\\n        fn(BUF_ADDR(ar, i));\\n    }\\n}\\n\\n/**\\n * A fold/reduce function that collects all of the elements in the array\\n * together. For example, if we have an array of [a,b,c...] the end result\\n * will be (...((a+b)+c)+...).\\n *\\n * @param[in] ar the array on which this operation is performed\\n * @param[in] fn the operation function that is to be invoked on each array\\n *               element\\n * @param[in] result the pointer which will collect the end result\\n */\\nvoid cc_array_sized_reduce(CC_ArraySized *ar, void (*fn) (uint8_t*, uint8_t*, uint8_t*), uint8_t *result)\\n{\\n    if (ar->size == 1) {\\n        fn(BUF_ADDR(ar, 0), NULL, result);\\n        return;\\n    }\\n    if (ar->size > 1) {\\n        fn(BUF_ADDR(ar, 0), BUF_ADDR(ar, 1), result);\\n    }\\n    for (size_t i = 2; i < ar->size; i++) {\\n        fn(result, BUF_ADDR(ar, i), result);\\n    }\\n}\\n\\n/**\\n * Initializes the iterator.\\n *\\n * @param[in] iter the iterator that is being initialized\\n * @param[in] ar the array to iterate over\\n */\\nvoid cc_array_sized_iter_init(CC_ArraySizedIter *iter, CC_ArraySized *ar)\\n{\\n    iter->ar    = ar;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Advances the iterator and sets the out parameter to the reference of the\\n * next element in the sequence.\\n *\\n * @param[in] iter the iterator that is being advanced\\n * @param[out] out pointer to where the next element is set\\n *\\n * @return CC_OK if the iterator was advanced, or CC_ITER_END if the\\n * end of the CC_Array has been reached.\\n */\\nenum cc_stat cc_array_sized_iter_next(CC_ArraySizedIter *iter, uint8_t **out)\\n{\\n    if (iter->index >= iter->ar->size) {\\n        return CC_ITER_END;\\n    }\\n    *out = BUF_ADDR(iter->ar, iter->index);\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes the last returned element by <code>cc_array_sized_iter_next()</code>\\n * function without invalidating the iterator and optionally sets the out\\n * parameter to the value of the removed element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[out] out pointer to where the removed element is stored, or NULL\\n *                 if it is to be ignored\\n *\\n * @return CC_OK if the element was successfully removed, or\\n * CC_ERR_VALUE_NOT_FOUND.\\n */\\nenum cc_stat cc_array_sized_iter_remove(CC_ArraySizedIter *iter, uint8_t *out)\\n{\\n    enum cc_stat status = CC_ERR_VALUE_NOT_FOUND;\\n\\n    if (!iter->last_removed) {\\n        status = cc_array_sized_remove_at(iter->ar, iter->index - 1, out);\\n        if (status == CC_OK) {\\n            iter->last_removed = true;\\n        }\\n    }\\n    return status;\\n}\\n\\n/**\\n * Adds a new element to the CC_ArraySized after the last returned element by\\n * <code>cc_array_sized_iter_next()</code> function without invalidating the\\n * iterator.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the element being added\\n *\\n * @return CC_OK if the element was successfully added, CC_ERR_ALLOC if the\\n * memory allocation for the new element failed, or CC_ERR_MAX_CAPACITY if\\n * the array is already at maximum capacity.\\n */\\nenum cc_stat cc_array_sized_iter_add(CC_ArraySizedIter *iter, uint8_t *element)\\n{\\n    return cc_array_sized_add_at(iter->ar, element, iter->index++);\\n}\\n\\n/**\\n * Replaces the last returned element by <code>cc_array_sized_iter_next()</code>\\n * with the specified element and optionally sets the out parameter to\\n * the value of the replaced element.\\n *\\n * @note This function should only ever be called after a call to <code>\\n * cc_array_sized_iter_next()</code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n * @param[in] element the replacement element\\n * @param[out] out pointer to where the replaced element is stored, or NULL\\n *                if it is to be ignored\\n *\\n * @return CC_OK if the element was replaced successfully, or\\n * CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_iter_replace(CC_ArraySizedIter *iter, uint8_t *element, uint8_t *out)\\n{\\n    return cc_array_sized_replace_at(iter->ar, element, iter->index - 1, out);\\n}\\n\\n/**\\n * Returns the index of the last returned element by <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @note\\n * This function should not be called before a call to <code>cc_array_sized_iter_next()\\n * </code>.\\n *\\n * @param[in] iter the iterator on which this operation is being performed\\n *\\n * @return the index.\\n */\\nsize_t cc_array_sized_iter_index(CC_ArraySizedIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n/**\\n * Initializes the zip iterator.\\n *\\n * @param[in] iter iterator that is being initialized\\n * @param[in] ar1  first array\\n * @param[in] ar2  second array\\n */\\nvoid cc_array_sized_zip_iter_init(CC_ArraySizedZipIter *iter, CC_ArraySized *ar1, CC_ArraySized *ar2)\\n{\\n    iter->ar1 = ar1;\\n    iter->ar2 = ar2;\\n    iter->index = 0;\\n    iter->last_removed = false;\\n}\\n\\n/**\\n * Outputs the next element pair in the sequence and advances the iterator.\\n *\\n * @param[in]  iter iterator that is being advanced\\n * @param[out] out1 output of the first array element\\n * @param[out] out2 output of the second array element\\n *\\n * @return CC_OK if a next element pair is returned, or CC_ITER_END if the end of one\\n * of the arrays has been reached.\\n */\\nenum cc_stat cc_array_sized_zip_iter_next(CC_ArraySizedZipIter *iter, uint8_t **out1, uint8_t **out2)\\n{\\n    if (iter->index >= iter->ar1->size || iter->index >= iter->ar2->size) {\\n        return CC_ITER_END;\\n    }\\n    *out1 = BUF_ADDR(iter->ar1, iter->index);\\n    *out2 = BUF_ADDR(iter->ar2, iter->index);\\n\\n    iter->index++;\\n    iter->last_removed = false;\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Removes and outputs the last returned element pair by <code>cc_array_sized_zip_iter_next()\\n * </code> without invalidating the iterator.\\n *\\n * @param[in]  iter iterator on which this operation is being performed\\n * @param[out] out1 output of the removed element from the first array\\n * @param[out] out2 output of the removed element from the second array\\n *\\n * @return CC_OK if the element was successfully removed, CC_ERR_OUT_OF_RANGE if the\\n * state of the iterator is invalid, or CC_ERR_VALUE_NOT_FOUND if the element was\\n * already removed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_remove(CC_ArraySizedZipIter *iter, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    if (!iter->last_removed) {\\n        cc_array_sized_remove_at(iter->ar1, iter->index - 1, out1);\\n        cc_array_sized_remove_at(iter->ar2, iter->index - 1, out2);\\n        iter->last_removed = true;\\n        return CC_OK;\\n    }\\n    return CC_ERR_VALUE_NOT_FOUND;\\n}\\n\\n/**\\n * Adds a new element pair to the arrays after the last returned element pair by\\n * <code>cc_array_sized_zip_iter_next()</code> and immediately before an element pair\\n * that would be returned by a subsequent call to <code>cc_array_sized_zip_iter_next()</code>\\n * without invalidating the iterator.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n * @param[in] e1   element added to the first array\\n * @param[in] e2   element added to the second array\\n *\\n * @return CC_OK if the element pair was successfully added to the arrays, or\\n * CC_ERR_ALLOC if the memory allocation for the new elements failed.\\n */\\nenum cc_stat cc_array_sized_zip_iter_add(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2)\\n{\\n    size_t index = iter->index++;\\n    CC_ArraySized  *ar1  = iter->ar1;\\n    CC_ArraySized  *ar2  = iter->ar2;\\n\\n    /* Make sure both array buffers have room */\\n    if ((ar1->size == ar1->capacity && (expand_capacity(ar1) != CC_OK)) ||\\n        (ar2->size == ar2->capacity && (expand_capacity(ar2) != CC_OK))) {\\n        return CC_ERR_ALLOC;\\n    }\\n    cc_array_sized_add_at(ar1, e1, index);\\n    cc_array_sized_add_at(ar2, e2, index);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Replaces the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>\\n * with the specified replacement element pair.\\n *\\n * @param[in] iter  iterator on which this operation is being performed\\n * @param[in]  e1   first array's replacement element\\n * @param[in]  e2   second array's replacement element\\n * @param[out] out1 output of the replaced element from the first array\\n * @param[out] out2 output of the replaced element from the second array\\n *\\n * @return CC_OK if the element was successfully replaced, or CC_ERR_OUT_OF_RANGE.\\n */\\nenum cc_stat cc_array_sized_zip_iter_replace(CC_ArraySizedZipIter *iter, uint8_t *e1, uint8_t *e2, uint8_t *out1, uint8_t *out2)\\n{\\n    if ((iter->index - 1) >= iter->ar1->size || (iter->index - 1) >= iter->ar2->size) {\\n        return CC_ERR_OUT_OF_RANGE;\\n    }\\n    cc_array_sized_replace_at(iter->ar1, e1, iter->index - 1, out1);\\n    cc_array_sized_replace_at(iter->ar2, e2, iter->index - 1, out2);\\n\\n    return CC_OK;\\n}\\n\\n/**\\n * Returns the index of the last returned element pair by <code>cc_array_sized_zip_iter_next()</code>.\\n *\\n * @param[in] iter iterator on which this operation is being performed\\n *\\n * @return current iterator index.\\n */\\nsize_t cc_array_sized_zip_iter_index(CC_ArraySizedZipIter *iter)\\n{\\n    return iter->index - 1;\\n}\\n\\n\\nsize_t cc_array_sized_struct_size()\\n{\\n    return sizeof(CC_ArraySized);\\n}\", \"embeddings\": [0.028283067047595978, 0.0644647479057312, 0.048305537551641464, 0.11831606924533844, 0.38410118222236633, -0.18642309308052063, 0.09315317124128342, 0.3603998124599457, 0.05775774270296097, -0.2380548119544983, -0.005863077938556671, -0.10535558313131332, 0.011526836082339287, 0.12830409407615662, -0.014152005314826965, 0.07574636489152908, 0.02960091084241867, -0.044820211827754974, 0.04927137494087219, -0.3196670711040497, -0.17482994496822357, 0.10287578403949738, 0.16545672714710236, 0.10345401614904404, 0.21430198848247528, 0.08915174752473831, 0.23741959035396576, 0.13198339939117432, 0.2519483268260956, -0.1646907776594162, 0.05223855376243591, -0.05668407678604126, 0.05964064970612526, -0.1974775195121765, 0.049279648810625076, -0.04708400368690491, 0.05296114832162857, 0.022758495062589645, -0.027902698144316673, 0.013361779972910881, -0.154474675655365, 0.06904345005750656, 0.05778932943940163, 0.20234256982803345, 0.06615433096885681, -0.0004975013434886932, 0.052534062415361404, 0.17912781238555908, -0.06676165759563446, 0.0659111887216568, 0.09824787825345993, -0.04497677460312843, 0.014709193259477615, -0.05921183526515961, -0.0523173026740551, -0.06864962726831436, -0.004877997562289238, 0.40205270051956177, -0.010172002017498016, -0.01606316864490509, -0.03556906431913376, -0.11987283825874329, -0.1548210084438324, 0.15671533346176147, 0.13599833846092224, 0.02930002100765705, -0.10440574586391449, -0.23041677474975586, -0.016570668667554855, -0.0034716613590717316, 0.1016341894865036, 0.032976552844047546, 0.12174256145954132, -0.18546617031097412, -0.11969177424907684, -0.048117369413375854, 0.023391373455524445, 0.5409136414527893, -0.002722490578889847, 0.1787935495376587, 0.20248715579509735, -0.08301743865013123, 0.08604585379362106, 0.18415242433547974, 0.11285820603370667, 0.016294091939926147, -0.09471426159143448, 0.09713224321603775, 0.0276511050760746, 0.18811501562595367, 0.09231451153755188, 0.14156943559646606, -0.08747541159391403, -0.022692624479532242, -0.028622351586818695, 0.019400371238589287, 0.04861629754304886, -0.1678485870361328, 0.06610772013664246, 0.39492011070251465, -0.062358636409044266, -0.09586499631404877, -0.16830196976661682, -0.06517751514911652, -0.031081892549991608, -0.011774707585573196, -0.10306959599256516, 0.0829586386680603, 0.06188632547855377, -0.008978404104709625, 0.16938595473766327, 0.07031042873859406, -0.002083379775285721, 0.034369394183158875, -0.019456155598163605, -0.06998929381370544, 0.09782516956329346, -0.06287819147109985, 0.20586395263671875, -0.11966005712747574, 0.1132185161113739, 0.0029014497995376587, 0.049138665199279785, -0.047962650656700134, -0.07681085169315338, 0.09714297950267792, 0.0016209185123443604, -0.24927332997322083, 0.1541256606578827, 0.06644836068153381, -0.04205910116434097, -0.09365186095237732, -0.012243799865245819, 0.03202863037586212, 0.09011302888393402, 0.04573811590671539, 0.06000102311372757, 0.0009669139981269836, 0.044803813099861145, -0.006575725972652435, -0.02360333502292633, 0.02918478101491928, 0.2807747721672058, -0.057334836572408676, 0.26886987686157227, -0.20092891156673431, 0.14933335781097412, 0.11922349035739899, -0.2784956097602844, -0.24466659128665924, 0.08225264400243759, -0.12321822345256805, 0.007292957976460457, 0.03331849351525307, -0.13785682618618011, 0.8691306710243225, 0.13412535190582275, -0.1378391981124878, -0.056117646396160126, -0.009038046002388, 0.0392548143863678, -0.2994745969772339, -0.07460685074329376, 0.16477635502815247, 0.06578028202056885, 0.13929253816604614, 0.05129435285925865, 0.06956752389669418, 0.16196870803833008, 0.08251402527093887, 0.10778273642063141, -0.06778976321220398, -0.09923827648162842, 0.17919380962848663, 0.028227508068084717, -0.06074858456850052, -0.10627971589565277, 0.08660514652729034, -0.07368580251932144, 0.0072636678814888, -0.09683282673358917, -0.0007241815328598022, -0.16039083898067474, 0.003508627414703369, -0.05588573217391968, 0.01724175363779068, -0.011603519320487976, -0.05803290009498596, 0.04948078840970993, 0.003164127469062805, 0.06488718092441559, 0.06288086622953415, 0.13832439482212067, -0.02858974039554596, -0.0782572403550148, 0.03766116499900818, -0.12061337381601334, -0.09838420897722244, 0.14076893031597137, -0.06588345766067505, 0.023912163451313972, -0.21957695484161377, 0.2255801260471344, -0.1274905800819397, 0.023498449474573135, 0.10288088023662567, -0.2366911619901657, 0.010839879512786865, 0.007137138396501541, -0.15709958970546722, -0.06927454471588135, 0.09602116793394089, 0.09400155395269394, 0.00865877140313387, -0.03786766156554222, -0.10961402952671051, 0.07625707983970642, 0.0528445765376091, 0.07019029557704926, -0.150886669754982, 0.1324005424976349, 0.22382989525794983, -0.05715160071849823, -0.06136026978492737, -0.146835058927536, 0.18311837315559387, 0.21216276288032532, 0.06427982449531555, -0.02102484181523323, 0.05852566286921501, 0.16306746006011963, 0.21264436841011047, -0.2289748340845108, 0.09672758728265762, 0.0333627425134182, -0.2065136879682541, -0.053083159029483795, 0.03470732644200325, 0.0078267902135849, -0.086890310049057, -0.04002230614423752, 0.15178358554840088, 0.20064106583595276, 0.2906831204891205, 0.029320474714040756, 0.040300317108631134, -0.20035530626773834, -0.034589432179927826, -0.07980727404356003, -0.024859532713890076, -0.037615664303302765, -0.014787294901907444, -0.002705451101064682, -0.12374469637870789, -0.11726388335227966, -0.022847790271043777, -0.17587685585021973, 0.016218066215515137, 0.07822570204734802, 0.2517963945865631, -0.005485255271196365, -0.049012959003448486, 0.08658452332019806, -0.0592733770608902, -0.10150177776813507, -0.40096423029899597, -0.02010328322649002, 0.06220642104744911, -0.008142177015542984, -0.03916117548942566, 0.03714502230286598, -0.0836658850312233, 0.2618403732776642, 0.08297765254974365, 0.08181926608085632, -0.017989374697208405, -0.010512853041291237, 0.023193534463644028, -0.1513742208480835, -0.0038740672171115875, -0.03865809366106987, 0.06759576499462128, -0.11898235976696014, 0.11808973550796509, 0.024654600769281387, 0.0018698535859584808, 0.16197384893894196, -0.012873111292719841, 0.053865157067775726, 0.04969557747244835, 0.049575988203287125, 0.054696813225746155, 0.10782510042190552, 0.12437441945075989, 0.034608423709869385, 0.14486785233020782, 0.1941666156053543, -0.07934379577636719, 0.008743733167648315, -0.3070755898952484, 0.091054767370224, -0.26438355445861816, 0.022771403193473816, -0.04181871563196182, 0.36173126101493835, -0.03438561037182808, 0.08112655580043793, 0.0021440833806991577, 0.2640795409679413, 0.008561059832572937, 0.01382400095462799, 0.060229863971471786, -0.16299325227737427, 0.1326349973678589, -0.18367742002010345, 0.052570417523384094, -0.11147931963205338, -0.0590730644762516, 0.11154409497976303, 0.01855730265378952, -0.021443966776132584, 0.14151689410209656, 0.2149268388748169, 0.14073385298252106, 0.01082643587142229, 0.08046268671751022, 0.07142046093940735, 0.013054221868515015, -0.17545539140701294, 0.7075729370117188, -0.556415319442749, 0.21739912033081055, -0.19990283250808716, 0.3117195963859558, -0.05349622666835785, 0.3361263871192932, -0.059933245182037354, 0.0912720113992691, 0.06379291415214539, 0.11126333475112915, -0.13562209904193878, -0.03153569623827934, -0.12444038689136505, 0.276705265045166, 0.14300566911697388, 0.12864670157432556, 0.18607471883296967, -0.019395094364881516, 0.12621445953845978, -0.12406651675701141, -0.16560259461402893, 0.14920641481876373, 0.07569486647844315, -0.06294140219688416, 0.11235983669757843, 0.30804458260536194, -0.10348785668611526, -0.14721432328224182, 0.04555913060903549, 0.019452929496765137, 0.15594853460788727, -0.20956206321716309, 0.13227227330207825, -0.09648625552654266, 0.27131223678588867, -0.4654623866081238, -0.374847948551178, -0.0006570257246494293, -0.10698899626731873, 0.07367373257875443, 0.13894858956336975, 0.2991442382335663, 0.16052529215812683, -0.18726205825805664, 0.08227439969778061, -0.043968651443719864, -0.023955047130584717, 0.00844017043709755, 0.01545628160238266, 0.09828349947929382, 0.08376511931419373, 0.04327711462974548, 0.05976065993309021, 0.02213015966117382, 0.04555293172597885, -0.15447193384170532, 0.2607857882976532, 0.16174101829528809, 0.22518789768218994, -0.10121852159500122, 0.0876593291759491, -0.12330710887908936, 0.06649082154035568, -0.06319580972194672, 0.06210366263985634, 0.04720008373260498, -0.13399364054203033, 0.20417359471321106, -0.11070513725280762, -0.08160717785358429, 0.1942378133535385, 0.23423689603805542, 0.019073646515607834, 0.17713488638401031, 0.08426586538553238, 0.0734097883105278, 0.18455766141414642, -0.14713548123836517, -0.15991844236850739, -0.14313066005706787, 0.10919222235679626, 0.07152672857046127, 0.0883641317486763, 0.02127905935049057, 0.14090782403945923, -0.18797150254249573, -0.0282621867954731, -0.36830973625183105, -0.14858666062355042, 0.15312699973583221, 0.22997136414051056, 0.11694139242172241, -0.011721640825271606, -0.1516534984111786, -0.037957750260829926, -0.021018855273723602, -0.06147138774394989, -0.06221391260623932, 0.04291428625583649, -0.13166974484920502, 0.04166260361671448, 0.24823640286922455, 0.07890773564577103, 0.09066984057426453, 0.08149516582489014, -0.07403556257486343, -0.09531563520431519, -0.00828065350651741, 0.022570503875613213, 0.05083649232983589, -0.10489478707313538, 0.06758227199316025, 0.0483827069401741, 0.11780302971601486, 0.002545342780649662, -0.09037087112665176, 0.4132577180862427, 0.09915386140346527, -0.029199881479144096, 0.03934403881430626, -0.16472163796424866, 0.00623399019241333, -0.03950798884034157, -0.272588312625885, 0.12400417774915695, 0.2045629769563675, 0.07675924897193909, 0.01859550178050995, 0.0981794074177742, 0.02571558952331543, -0.059495098888874054, 0.06822218745946884, -0.06838783621788025, -0.1422836035490036, 0.03681018203496933, -0.09501750022172928, 0.15885259211063385, 0.008137593045830727, 0.22931703925132751, 0.13497519493103027, 0.0667959451675415, 0.14895567297935486, 0.0484035462141037, -0.0717243179678917, 0.006368421018123627, 0.03647945076227188, -0.05889726057648659, -0.16911238431930542, 0.07592038065195084, -0.14497269690036774, -0.034510109573602676, 0.09573626518249512, 0.1302318274974823, 0.007038973271846771, 0.03877085819840431, -0.1623052954673767, 0.26714596152305603, 0.11523498594760895, -0.12975718080997467, 0.008738085627555847, -0.03185245767235756, 0.13887280225753784, 0.06364549696445465, 0.058507174253463745, 0.263447105884552, 0.15613824129104614, 0.07139505445957184, 0.10409252345561981, 0.29588189721107483, -0.1336347609758377, 0.015524771064519882, 0.11473353207111359, 0.04632582515478134, -0.09162487089633942, -0.10128198564052582, -0.10190641134977341, -0.022582434117794037, 0.06434725224971771, 0.17218317091464996, -0.2221401035785675, -0.04499829560518265, -0.1134619191288948, 0.16162315011024475, -0.018627218902111053, 0.05335298925638199, 0.06027696281671524, 0.017145387828350067, 0.0010791346430778503, -0.13425225019454956, 0.3135052025318146, -0.1733749508857727, -0.10150720179080963, -0.058711860328912735, -0.024065883830189705, -0.10352721065282822, 0.014247249811887741, 0.10646973550319672, -0.011244110763072968, 0.1291179656982422, 0.054037973284721375, -0.0007505714893341064, 0.024167954921722412, 0.09791658073663712, 0.20125865936279297, -0.11346998810768127, 0.021024273708462715, 0.06298073381185532, 0.04703288525342941, 0.2199285477399826, -0.1137966737151146, -0.21680177748203278, -0.07706024497747421, 0.17456358671188354, -0.05592862144112587, 0.1632264405488968, 0.03390932083129883, 0.15500396490097046, 0.09149538725614548, -0.036958180367946625, -0.04687356948852539, -0.09223255515098572, -0.7277952432632446, -0.052127655595541, 0.11652779579162598, -0.019217703491449356, 0.10500143468379974, 0.11916005611419678, 0.08046532422304153, 0.04433257877826691, 0.10618925094604492, 0.06246234476566315, -0.009418446570634842, 0.15060646831989288, 0.23230667412281036, -0.1003614217042923, -0.11053241789340973, 0.11383258551359177, 0.10034732520580292, -0.2122691571712494, 0.2588140368461609, -0.0758800134062767, -0.15219905972480774, 0.0940261259675026, 0.3344627618789673, 0.02309124916791916, 0.047829434275627136, 0.24347832798957825, 0.05230211094021797, 0.19374293088912964, -0.05425176024436951, 0.057501014322042465, 0.3499288558959961, 0.15481671690940857, -0.3328813314437866, 0.026531986892223358, 0.22441445291042328, 0.18245616555213928, 0.06922321021556854, 13.91015625, -0.08458656072616577, 0.2778312563896179, -0.1032436415553093, -0.09063959866762161, -0.02595631033182144, -0.08551261574029922, 0.04908736050128937, -0.00362289696931839, 0.0009373053908348083, 0.11609495431184769, -0.07298605889081955, -0.08190388977527618, -0.00027325376868247986, -0.07861891388893127, -0.013573408126831055, -0.015278704464435577, -0.10466529428958893, 0.13603968918323517, 0.0207064151763916, -0.2090436816215515, -0.051632970571517944, -0.03596363216638565, -0.3938242495059967, -0.025718091055750847, -0.04708913713693619, 0.09408076107501984, 0.07677283138036728, 0.03794626146554947, 0.10284832864999771, 0.17289337515830994, 0.1958288997411728, 0.10706460475921631, -0.05083578824996948, 0.002541057765483856, -0.05333949998021126, -0.3612769842147827, -0.18166901171207428, 0.09287084639072418, -0.026245757937431335, -0.018493905663490295, 0.007466204464435577, 0.15253296494483948, -0.006994262337684631, 0.12328293919563293, 0.10154219716787338, -0.2344144880771637, 0.11824032664299011, -0.11812864989042282, -0.017658159136772156, 0.2183436155319214, 0.10032093524932861, 0.3376190662384033, 0.010561484843492508, -0.1261589229106903, -0.17582285404205322, 0.31171852350234985, 0.0006628632545471191, -0.06807290017604828, 0.31402575969696045, 0.012720037251710892, -0.05693643540143967, -0.059182655066251755, 0.027225300669670105, -0.03138774633407593, 0.00671657919883728, 0.1076633483171463, 0.02687641978263855, -0.1561608761548996, 0.15472577512264252, 0.23199623823165894, -0.2367057204246521, 0.1428251564502716, 0.0016924794763326645, -0.10355549305677414, 0.11368776112794876, 0.0070917606353759766, -0.012933269143104553, 0.04559316486120224, -0.1264650523662567, 0.0030693411827087402, 0.08342302590608597, -0.14669835567474365, -0.15445439517498016, -0.27596014738082886, 0.057272206991910934, -0.06862163543701172, 0.20792269706726074, 0.24151727557182312, -0.04625352472066879, -0.08817918598651886, 0.0694810003042221, -0.03168244659900665, -0.18415352702140808, 0.1939394474029541, -0.03671463578939438, -0.11026284098625183, -0.17778994143009186, 0.04043078050017357, 0.1318758726119995, -0.012276880443096161, -0.0903661698102951, -0.008061666041612625, 0.032664552330970764, -0.11848919093608856, -0.04169244319200516, 0.017589813098311424, -0.02610548585653305, -0.032368674874305725, 0.06385757774114609, 0.02577645145356655, 0.09062542021274567, 0.12616364657878876, -0.18591053783893585, -0.16834771633148193, -0.006371390074491501, 0.010422743856906891, 0.009985726326704025, 0.19990386068820953, 0.14321798086166382, 0.15153123438358307, 0.04123491793870926, -0.1801406741142273, -0.050074201077222824, 0.08323680609464645, -0.18833984434604645, 0.022027693688869476, 0.16549764573574066, 0.026870740577578545, -0.057535428553819656, 0.02158695086836815, -0.07481040805578232, 0.48258987069129944, 0.09403848648071289, 0.01864338293671608, -0.033414989709854126, -0.022510752081871033, 0.008853912353515625, 0.10023743659257889, 0.2521032691001892, 0.07356634736061096, -0.019171029329299927, 0.17778196930885315, -0.12993453443050385, -0.029619835317134857, 0.32318875193595886, 0.12981301546096802, 0.04675472527742386, -0.03398497775197029, 0.15477466583251953, 0.14135538041591644, 0.1904047727584839, -0.17713609337806702, -0.11673200130462646, -0.08315154910087585, -0.1727234125137329, -0.16883690655231476, 0.028547940775752068, -0.07996075600385666, -0.004586267285048962, 0.20899483561515808, -0.32222452759742737, 0.10887187719345093, -0.2800433933734894, -0.005535092204809189, 0.03141956776380539, 0.049284979701042175, 0.14185351133346558, 0.21312139928340912, -0.09199165552854538, 0.030576815828680992, 0.10560616850852966, -0.16419892013072968, 0.04653317853808403, -0.09055939316749573, 0.11236164718866348, 0.26913225650787354, -0.39317166805267334, -0.18025168776512146, 0.08046635240316391]}"
"{\"sha\": \"9b2ef2fe01df6141769bd1661c8938d29607aed9\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"test/unit/hashtable_test.c\", \"func_name\": \"collision_hash\", \"original_string\": \"static size_t collision_hash(const void* k, int l, uint32_t s)\\n{\\n    (void)k;\\n    (void)l;\\n    (void)s;\\n\\n    return 1;\\n}\", \"code_tokens\": [\"static\", \"size_t\", \"collision_hash\", \"(\", \"const\", \"void\", \"*\", \"k\", \",\", \"int\", \"l\", \",\", \"uint32_t\", \"s\", \")\", \"{\", \"(\", \"void\", \")\", \"k\", \";\", \"(\", \"void\", \")\", \"l\", \";\", \"(\", \"void\", \")\", \"s\", \";\", \"return\", \"1\", \";\", \"}\"], \"docstring\": \"/* a dummy hash function used to force collisions */\", \"docstring_tokens\": [\"/\", \"*\", \"a\", \"dummy\", \"hash\", \"function\", \"used\", \"to\", \"force\", \"collisions\", \"*\", \"/\"], \"raw_contents\": \"#include \\\"munit.h\\\"\\n#include \\\"cc_hashtable.h\\\"\\n#include <stdlib.h>\\n\\nstruct table {\\n    CC_HashTableConf c;\\n    CC_HashTable* t;\\n};\\n\\nint stat;\\n\\n/* a dummy hash function used to force collisions */\\nstatic size_t collision_hash(const void* k, int l, uint32_t s)\\n{\\n    (void)k;\\n    (void)l;\\n    (void)s;\\n\\n    return 1;\\n}\\n\\nstatic size_t zero_hash(const void* k, int l, uint32_t s)\\n{\\n    (void)k;\\n    (void)l;\\n    (void)s;\\n    return 0;\\n}\\n\\n\\nstatic void* default_conf_table(const MunitParameter params[], void* user_data)\\n{\\n    (void)params;\\n    (void)user_data;\\n\\n    struct table* t = malloc(sizeof(struct table));\\n    munit_assert_not_null(t);\\n    cc_hashtable_conf_init(&t->c);\\n    t->c.initial_capacity = 7;\\n    stat = cc_hashtable_new_conf(&t->c, &t->t);\\n    return (void*)t;\\n}\\n\\nstatic void default_conf_table_teardown(void* fixture) \\n{\\n    struct table* t = (struct table*)fixture;\\n    cc_hashtable_destroy(t->t);\\n}\\n\\nstatic void* default_table(const MunitParameter params[], void* user_data)\\n{\\n    (void)params;\\n    (void)user_data;\\n\\n    CC_HashTable* table;\\n    cc_hashtable_new(&table);\\n    return (void*)table;\\n}\\n\\nstatic void default_table_teardown(void* fixture)\\n{\\n    CC_HashTable* table = (CC_HashTable*)fixture;\\n    cc_hashtable_destroy(table);\\n}\\n\\nstatic void* default_collision_table(const MunitParameter params[], void* user_data)\\n{\\n    (void)params;\\n    (void)user_data;\\n\\n    struct table* t = malloc(sizeof(struct table));\\n    munit_assert_not_null(t);\\n    cc_hashtable_conf_init(&t->c);\\n    t->c.hash = collision_hash;\\n    cc_hashtable_new_conf(&t->c, &t->t);\\n    return (void*)t;\\n}\\n\\nstatic void default_collision_table_teardown(void* fixture)\\n{\\n    struct table* t = (struct table*)fixture;\\n    cc_hashtable_destroy(t->t);\\n}\\n\\nstatic void* default_zero_hash_table(const MunitParameter params[], void* user_data)\\n{\\n    (void)params;\\n    (void)user_data;\\n\\n    struct table* t = malloc(sizeof(struct table));\\n    munit_assert_not_null(t);\\n    cc_hashtable_conf_init(&t->c);\\n    t->c.hash = zero_hash;\\n    cc_hashtable_new_conf(&t->c, &t->t);\\n    return (void*)t;\\n}\\n\\nstatic void default_zero_hash_table_teardown(void* fixture)\\n{\\n    struct table* t = (struct table*)fixture;\\n    cc_hashtable_destroy(t->t);\\n}\\n\\n/***********************************************\\n                TESTS\\n***********************************************/\\n\\nstatic MunitResult test_new(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n\\n    struct table* t = (struct table*)fixture;\\n    munit_assert_int(CC_OK, == , stat);\\n    munit_assert_size(0, == , cc_hashtable_size(t->t));\\n\\n    /* power of 2 rounding */\\n    munit_assert_size(8, ==, cc_hashtable_capacity(t->t));\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_add(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n    CC_HashTable *table = (CC_HashTable*)fixture;\\n\\n    char* a = \\\"value\\\";\\n    char* b = \\\"cookies\\\";\\n    char* c = \\\"m31\\\";\\n\\n    cc_hashtable_add(table, \\\"key\\\", a);\\n    cc_hashtable_add(table, \\\"randomstring\\\", b);\\n    cc_hashtable_add(table, \\\"5\\\", c);\\n\\n    munit_assert_size(3, == , cc_hashtable_size(table));\\n\\n    char* r;\\n    cc_hashtable_get(table, \\\"key\\\", (void*)&r);\\n    munit_assert_ptr_equal(r, a);\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_collision_get(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n    struct table* t = (struct table*)fixture;\\n\\n    char* a = \\\"value\\\";\\n    char* c = \\\"m31\\\";\\n\\n    cc_hashtable_add(t->t, \\\"key\\\", a);\\n    cc_hashtable_add(t->t, \\\"randomstring\\\", c);\\n\\n    munit_assert_size(2, == , cc_hashtable_size(t->t));\\n\\n    char* r;\\n    cc_hashtable_get(t->t, \\\"randomstring\\\", (void*)&r);\\n    munit_assert_ptr_equal(r, c);\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_collision_remove(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n    struct table* t = (struct table*)fixture;\\n\\n    char* a = \\\"value\\\";\\n    char* c = \\\"m31\\\";\\n\\n    cc_hashtable_add(t->t, \\\"key\\\", a);\\n    cc_hashtable_add(t->t, \\\"randomstring\\\", c);\\n    cc_hashtable_add(t->t, \\\"5\\\", c);\\n\\n    char* rm;\\n    cc_hashtable_remove(t->t, \\\"randomstring\\\", (void*)&rm);\\n    munit_assert_size(2, == , cc_hashtable_size(t->t));\\n    void* g;\\n\\n    munit_assert_int(CC_ERR_KEY_NOT_FOUND, == , \\n    cc_hashtable_get(t->t, \\\"randomstring\\\", (void*)&g));\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_null_key_add(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n    struct table* t = (struct table*)fixture;\\n\\n    char* a = \\\"value\\\";\\n    char* b = \\\"cookies\\\";\\n    char* c = \\\"m31\\\";\\n\\n    cc_hashtable_add(t->t, \\\"key\\\", a);\\n    cc_hashtable_add(t->t, NULL, c);\\n    cc_hashtable_add(t->t, \\\"randomstring\\\", b);\\n    cc_hashtable_add(t->t, \\\"5\\\", c);\\n\\n    void* val = NULL;\\n    munit_assert_int(CC_OK, ==, cc_hashtable_get(t->t, NULL, &val));\\n    munit_assert_not_null(val);\\n    munit_assert_string_equal(val, c);\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_null_key_remove(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n    struct table* t = (struct table*)fixture;\\n\\n    char* a = \\\"value\\\";\\n    char* b = \\\"cookies\\\";\\n    char* c = \\\"m31\\\";\\n\\n    cc_hashtable_add(t->t, \\\"key\\\", a);\\n    cc_hashtable_add(t->t, \\\"randomstring\\\", b);\\n    cc_hashtable_add(t->t, NULL, c);\\n    cc_hashtable_add(t->t, \\\"5\\\", c);\\n\\n    void* out = NULL;\\n    munit_assert_int(CC_OK, == , cc_hashtable_remove(t->t, \\\"randomstring\\\", &out));\\n    munit_assert_ptr_not_null(out);\\n    munit_assert_string_equal(out, b);\\n\\n    out = NULL;\\n    munit_assert_int(CC_OK, == , cc_hashtable_remove(t->t, NULL, &out));\\n    munit_assert_ptr_not_null(out);\\n    munit_assert_string_equal(out, c);\\n\\n    out = NULL;\\n    munit_assert_int(CC_ERR_KEY_NOT_FOUND, == , cc_hashtable_get(t->t, \\\"randomstring\\\", &out));\\n    munit_assert_int(CC_ERR_KEY_NOT_FOUND, == , cc_hashtable_get(t->t, NULL, &out));\\n    munit_assert_ptr_null(out);\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_null_key_get(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n    struct table* t = (struct table*)fixture;\\n\\n    char* a = \\\"value\\\";\\n    char* b = \\\"cookies\\\";\\n    char* c = \\\"m31\\\";\\n\\n    cc_hashtable_add(t->t, \\\"key\\\", a);\\n    cc_hashtable_add(t->t, \\\"randomstring\\\", b);\\n    cc_hashtable_add(t->t, NULL, c);\\n    cc_hashtable_add(t->t, \\\"5\\\", c);\\n\\n    void* out = NULL;\\n    munit_assert_int(CC_OK, ==, cc_hashtable_get(t->t, \\\"randomstring\\\", &out));\\n    munit_assert_ptr_not_null(out);\\n    munit_assert_string_equal(out, b);\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_remove(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n    CC_HashTable *table = (CC_HashTable*)fixture;\\n\\n    char* a = \\\"value\\\";\\n    char* b = \\\"cookies\\\";\\n    char* c = \\\"m31\\\";\\n\\n    cc_hashtable_add(table, \\\"key\\\", a);\\n    cc_hashtable_add(table, \\\"randomstring\\\", b);\\n    cc_hashtable_add(table, \\\"5\\\", c);\\n\\n    char* rm = NULL;\\n    cc_hashtable_remove(table, \\\"randomstring\\\", (void*)&rm);\\n    munit_assert_ptr_not_null(rm);\\n    munit_assert_size(2, == , cc_hashtable_size(table));\\n    munit_assert_string_equal(rm, b);\\n\\n    char* g = NULL;\\n    munit_assert_int(CC_ERR_KEY_NOT_FOUND, == , cc_hashtable_get(table, \\\"randomstring\\\", (void*)&g));\\n    munit_assert_ptr_null(g);\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_remove_all(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n    CC_HashTable* table = (CC_HashTable*)fixture;\\n\\n    cc_hashtable_add(table, \\\"key\\\", \\\"value\\\");\\n    cc_hashtable_add(table, \\\"randomkey\\\", \\\"randomvalue\\\");\\n\\n    munit_assert_size(2, == , cc_hashtable_size(table));\\n\\n    cc_hashtable_remove_all(table);\\n    munit_assert_size(0, ==, cc_hashtable_size(table));\\n\\n    char* g;\\n    munit_assert_int(CC_ERR_KEY_NOT_FOUND, ==, cc_hashtable_get(table, \\\"key\\\", (void*)&g));\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_remove_get(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n    CC_HashTable* table = (CC_HashTable*)fixture;\\n\\n    char* val = \\\"567\\\";\\n\\n    cc_hashtable_add(table, \\\"key\\\", \\\"value\\\");\\n    cc_hashtable_add(table, \\\"123\\\", val);\\n\\n    char* ret = NULL;\\n    munit_assert_int(CC_OK, == , cc_hashtable_get(table, \\\"123\\\", (void*)&ret));\\n    munit_assert_ptr_not_null(ret);\\n    munit_assert_string_equal(ret, val);\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_size(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n    CC_HashTable* table = (CC_HashTable*)fixture;\\n\\n    cc_hashtable_add(table, \\\"key\\\", \\\"value\\\");\\n    cc_hashtable_add(table, \\\"randomstring\\\", \\\"cookies\\\");\\n    cc_hashtable_add(table, \\\"5\\\", \\\"asdf\\\");\\n\\n    munit_assert_size(3, == , cc_hashtable_size(table));\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_capacity(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n    (void)fixture;\\n\\n    CC_HashTable* table;\\n    CC_HashTableConf conf;\\n\\n    cc_hashtable_conf_init(&conf);\\n\\n    conf.load_factor = 0.5f;\\n    conf.initial_capacity = 2;\\n    cc_hashtable_new_conf(&conf, &table);\\n\\n    cc_hashtable_add(table, \\\"a\\\", NULL);\\n    munit_assert_size(2, == , cc_hashtable_capacity(table));\\n\\n    cc_hashtable_add(table, \\\"b\\\", NULL);\\n    munit_assert_size(4, == , cc_hashtable_capacity(table));\\n\\n    cc_hashtable_add(table, \\\"c\\\", NULL);\\n    cc_hashtable_add(table, \\\"d\\\", NULL);\\n    munit_assert_size(8, == , cc_hashtable_capacity(table));\\n\\n    cc_hashtable_destroy(table);\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_contains_key(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n    CC_HashTable* table = (CC_HashTable*)fixture;\\n\\n    cc_hashtable_add(table, \\\"key\\\", \\\"value\\\");\\n    cc_hashtable_add(table, \\\"randomstring\\\", \\\"cookies\\\");\\n    cc_hashtable_add(table, \\\"5\\\", \\\"m31\\\");\\n\\n    munit_assert_int(1, ==, cc_hashtable_contains_key(table, \\\"key\\\"));\\n\\n    cc_hashtable_remove(table, \\\"key\\\", NULL);\\n    munit_assert_int(0, == , cc_hashtable_contains_key(table, \\\"key\\\"));\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic int cmp_k(const void* k1, const void* k2)\\n{\\n    char* key1 = (char*)k1;\\n    char* key2 = (char*)k2;\\n    int i;\\n    for (i = 0; i < (sizeof(int) * 7); i++) {\\n        if (*key1 != *key2)\\n            return 1;\\n        key1++;\\n        key2++;\\n    }\\n    return 0;\\n}\\n\\nstatic MunitResult test_memory_chunk_key(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n    (void)fixture;\\n\\n    CC_HashTable* table;\\n    CC_HashTableConf conf;\\n\\n    cc_hashtable_conf_init(&conf);\\n\\n    conf.hash = GENERAL_HASH;\\n    conf.key_length = sizeof(int) * 7;\\n    conf.key_compare = cmp_k;\\n\\n    cc_hashtable_new_conf(&conf, &table);\\n\\n    int array1[] = { 1,2,3,4,5,6,7 };\\n    int array2[] = { 34,1,4,1111,456,234,0 };\\n    int array3[] = { 0,9,8,7,6,5,4 };\\n\\n    cc_hashtable_add(table, array1, \\\"one\\\");\\n    cc_hashtable_add(table, array2, \\\"two\\\");\\n    cc_hashtable_add(table, array3, \\\"three\\\");\\n\\n    char* a;\\n    char* b;\\n\\n    cc_hashtable_get(table, array1, (void*)&a);\\n    cc_hashtable_get(table, array3, (void*)&b);\\n\\n    munit_assert_string_equal(\\\"one\\\", a);\\n    munit_assert_string_equal(\\\"three\\\", b);\\n\\n    cc_hashtable_destroy(table);\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_iter_next(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n\\n    CC_HashTable* table = (CC_HashTable*)fixture;\\n\\n    cc_hashtable_add(table, \\\"one\\\", \\\"1\\\");\\n    cc_hashtable_add(table, \\\"two\\\", \\\"2\\\");\\n    cc_hashtable_add(table, \\\"three\\\", \\\"3\\\");\\n    cc_hashtable_add(table, \\\"four\\\", \\\"4\\\");\\n    cc_hashtable_add(table, \\\"five\\\", \\\"5\\\");\\n\\n    int one = 0;\\n    int two = 0;\\n    int three = 0;\\n    int four = 0;\\n    int five = 0;\\n\\n    CC_HashTableIter iter;\\n    cc_hashtable_iter_init(&iter, table);\\n\\n    TableEntry* entry;\\n    while (cc_hashtable_iter_next(&iter, &entry) != CC_ITER_END) {\\n        char const* key = entry->key;\\n\\n        if (!strcmp(key, \\\"one\\\"))\\n            one++;\\n\\n        if (!strcmp(key, \\\"two\\\"))\\n            two++;\\n\\n        if (!strcmp(key, \\\"three\\\"))\\n            three++;\\n\\n        if (!strcmp(key, \\\"four\\\"))\\n            four++;\\n\\n        if (!strcmp(key, \\\"five\\\"))\\n            five++;\\n    }\\n\\n    munit_assert_int(1, ==, one);\\n    munit_assert_int(1, == , two);\\n    munit_assert_int(1, == , three);\\n    munit_assert_int(1, == , four);\\n    munit_assert_int(1, == , five);\\n\\n    return MUNIT_OK;\\n}\\n\\nstatic MunitResult test_iter_remove(const MunitParameter params[], void* fixture)\\n{\\n    (void)params;\\n\\n    CC_HashTable* table = (CC_HashTable*)fixture;\\n\\n    char* a = \\\"foo\\\";\\n    char* b = \\\"bar\\\";\\n    char* c = \\\"baz\\\";\\n\\n    cc_hashtable_add(table, a, \\\"a\\\");\\n    cc_hashtable_add(table, b, \\\"a\\\");\\n    cc_hashtable_add(table, c, \\\"a\\\");\\n\\n    CC_HashTableIter iter;\\n    cc_hashtable_iter_init(&iter, table);\\n\\n    TableEntry* entry;\\n    while (cc_hashtable_iter_next(&iter, &entry) != CC_ITER_END) {\\n        char const* key = entry->key;\\n\\n        if (!strcmp(key, \\\"bar\\\"))\\n            cc_hashtable_iter_remove(&iter, NULL);\\n    }\\n\\n    munit_assert_size(2, == , cc_hashtable_size(table));\\n    munit_assert_false(cc_hashtable_contains_key(table, \\\"bar\\\"));\\n\\n    return MUNIT_OK;\\n}\\n\\n\\nstatic MunitTest test_suite_tests[] = {\\n    {(char*)\\\"/hashtable/test_new\\\", test_new, default_conf_table, default_conf_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_add\\\", test_add, default_table, default_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_collision_get\\\", test_collision_get, default_collision_table, default_collision_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_collision_remove\\\", test_collision_remove, default_collision_table, default_collision_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_null_key_add\\\", test_null_key_add, default_zero_hash_table, default_zero_hash_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_null_key_remove\\\", test_null_key_remove, default_zero_hash_table, default_zero_hash_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_null_key_get\\\", test_null_key_get, default_zero_hash_table, default_zero_hash_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_remove\\\", test_remove, default_table, default_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_remove_all\\\", test_remove_all, default_table, default_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_remove_get\\\", test_remove_get, default_table, default_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_size\\\", test_size, default_table, default_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_capacity\\\", test_capacity, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_contains_key\\\", test_contains_key, default_table, default_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_iter_next\\\", test_iter_next, default_table, default_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_iter_remove\\\", test_iter_remove, default_table, default_table_teardown, MUNIT_TEST_OPTION_NONE, NULL},\\n    {(char*)\\\"/hashtable/test_memory_chunk_key\\\", test_memory_chunk_key, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},\\n    { NULL, NULL, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL }\\n};\\n\\nstatic const MunitSuite test_suite = {\\n    (char*)\\\"\\\", test_suite_tests, NULL, 1, MUNIT_SUITE_OPTION_NONE\\n};\\n\\nint main(int argc, char* argv[MUNIT_ARRAY_PARAM(argc + 1)])\\n{\\n    return munit_suite_main(&test_suite, (void*)\\\"test\\\", argc, argv);\\n}\", \"embeddings\": [0.019974321126937866, 0.02383016049861908, -0.029198724776506424, 0.03837902843952179, 0.24279820919036865, -0.239194855093956, 0.06804715842008591, 0.23620352149009705, 0.06105619668960571, -0.04603130370378494, 0.01619785465300083, -0.005236625671386719, -0.08615116775035858, 0.07022100687026978, 0.06846071034669876, -0.08088638633489609, 0.008880075067281723, -0.006541065871715546, 0.11330784857273102, -0.16458547115325928, -0.038246385753154755, -0.055837079882621765, 0.17553217709064484, 0.1411900818347931, 0.16192315518856049, -0.05406339094042778, 0.26268452405929565, 0.2236487716436386, 0.13331139087677002, -0.05225004628300667, 0.09056240320205688, 0.09427374601364136, 0.1703936606645584, -0.12692901492118835, -0.05102255567908287, 0.025721600279211998, 0.1235373318195343, 0.13037574291229248, -0.029658840969204903, 0.044441089034080505, -0.19137418270111084, -0.06387156248092651, 0.09325128048658371, 0.19654543697834015, 0.03410695120692253, 0.021613644436001778, -0.0038598403334617615, 0.11912013590335846, -0.11166846752166748, -0.023847367614507675, 0.09985613822937012, 0.04938856139779091, -0.09347888827323914, 0.05041899532079697, -0.2030969262123108, -0.01793278381228447, 0.07259480655193329, 0.32530757784843445, 0.13695506751537323, -0.037187784910202026, -0.04641064256429672, 0.08228108286857605, -0.20599819719791412, 0.030280478298664093, 0.14939439296722412, -0.06622212380170822, -0.15304987132549286, -0.11128297448158264, -0.04695643112063408, -0.08139460533857346, 0.14767560362815857, 0.00016383454203605652, 0.053497374057769775, -0.16192880272865295, -0.10201308131217957, 0.032029520720243454, 0.1077369824051857, 0.5535219311714172, -0.20628198981285095, 0.007043033838272095, 0.21464553475379944, -0.03237133473157883, -0.14096161723136902, 0.17123284935951233, 0.07418181747198105, -0.05389900505542755, 0.00340980663895607, 0.04950399324297905, 0.09641894698143005, 0.12873661518096924, 0.036958761513233185, 0.07511863857507706, 0.03211948275566101, -0.04227972403168678, 0.029222236946225166, -0.05793094262480736, 0.015110071748495102, -0.4727136492729187, 0.02177155390381813, 0.17677298188209534, -0.017123211175203323, -0.07120659947395325, -0.11688972264528275, 0.005405724048614502, -0.017583996057510376, 0.06500166654586792, 0.07253389060497284, -0.02824878692626953, 0.07783011347055435, -0.03906127065420151, 0.0232439786195755, 0.10657902806997299, 0.03857775032520294, 0.136305570602417, 0.1423058807849884, -0.13227972388267517, 0.12723419070243835, -0.017325639724731445, -0.11763130128383636, 0.03513661399483681, 0.11006061732769012, 0.09399693459272385, -0.10888636857271194, -0.031926944851875305, 0.04658316820859909, 0.0888926237821579, 0.08278945088386536, -0.1358020305633545, 0.12810556590557098, 0.09699203073978424, 0.029172327369451523, -0.24388296902179718, 0.02061961218714714, 0.016008295118808746, 0.20430722832679749, 0.047758474946022034, 0.16216960549354553, -0.05379173904657364, -0.08452411741018295, 0.09086333215236664, -0.10798559337854385, 0.05424118414521217, 0.2875255346298218, 0.04470296949148178, 0.17850852012634277, -0.10912153124809265, 0.11455430090427399, 0.08248850703239441, -0.13947667181491852, -0.08096282929182053, 0.05765698105096817, -0.05241766571998596, 0.09412777423858643, 0.06279376149177551, -0.2879798710346222, 0.6135494709014893, 0.08212240785360336, -0.15314075350761414, -0.08588409423828125, -0.027426838874816895, 0.08301527053117752, -0.11490833759307861, 0.03218267858028412, 0.10444000363349915, 0.06257805973291397, 0.07831548899412155, 0.04656004160642624, 0.13278214633464813, 0.12564948201179504, 0.07755370438098907, 0.06494727730751038, -0.11355903744697571, -0.06012546271085739, 0.16003663837909698, -0.04516381025314331, -0.0978841707110405, -0.19163355231285095, 0.03719707578420639, 0.04171541705727577, 0.13530327379703522, -0.0708053931593895, 0.02550162374973297, -0.07058405131101608, -0.04579252004623413, 0.07924733310937881, 0.03788748383522034, 0.09143903851509094, -0.11464206129312515, 0.16630618274211884, 0.03977318853139877, -0.17188890278339386, 0.13343679904937744, -0.006785865873098373, 0.08949679136276245, 0.013601414859294891, 0.0045909583568573, -0.05963100492954254, -0.05789998173713684, 0.13355684280395508, -0.11480040848255157, -0.02965838648378849, -0.04674298316240311, 0.07340819388628006, -0.0707230269908905, 0.11284008622169495, 0.08240863680839539, -0.059843309223651886, 0.0010510385036468506, 0.07684600353240967, -0.046357836574316025, -0.024692829698324203, 0.3271545469760895, 0.10738849639892578, 0.02059013769030571, -0.13010220229625702, -0.04261673614382744, -0.0465417318046093, -0.030846253037452698, -0.007774379104375839, -0.2193925380706787, 0.10701189190149307, 0.17486920952796936, -0.0540037676692009, -0.04822370409965515, -0.028847910463809967, 0.1999320089817047, 0.25726020336151123, -0.04602514207363129, -0.020763494074344635, -0.02580081671476364, 0.19797682762145996, 0.0672776848077774, -0.038870472460985184, 0.11041171848773956, 0.04857809841632843, -0.12245050072669983, -0.15200981497764587, 0.14948537945747375, -0.08494725078344345, -0.0232357457280159, -0.0484166257083416, 0.03271450102329254, 0.025779027491807938, 0.2810431718826294, 0.044563841074705124, 0.09697173535823822, -0.1721993237733841, -0.08996917307376862, -0.07835651934146881, 0.01106482744216919, -0.01711791567504406, -0.1702793687582016, 0.12164580821990967, 0.02207275852560997, -0.06289224326610565, -0.07894226908683777, -0.13793659210205078, 0.08632511645555496, 0.013173926621675491, 0.035333357751369476, -0.11165861040353775, -0.11566144227981567, 0.027446694672107697, -0.0034881383180618286, 0.04584543779492378, -0.3453080356121063, -0.0023749135434627533, -0.0013278424739837646, 0.03019055724143982, 0.0814102441072464, 0.052493248134851456, -0.014997106045484543, 0.19838392734527588, 0.12778370082378387, 0.06233407184481621, -0.02605072408914566, 0.10562725365161896, -0.05867311730980873, -0.02677220106124878, 0.02277471497654915, 0.025429129600524902, 0.1736854612827301, -0.0006371978670358658, 0.03628034144639969, -0.05807454511523247, 0.09619315713644028, -0.07368963956832886, -0.09879346936941147, 0.07076483219861984, 0.0034006983041763306, 0.03950486332178116, 0.015959221869707108, -0.009343394078314304, 0.1946699321269989, -0.0040512047708034515, 0.18961843848228455, 0.18477250635623932, -0.11018601059913635, 0.12829697132110596, -0.0941130742430687, 0.03375430777668953, -0.024501774460077286, -0.0020556384697556496, -0.16745565831661224, 0.256283164024353, -0.15699502825737, 0.04388836398720741, -0.004900217056274414, 0.20692001283168793, -0.11133614182472229, -0.015011829324066639, 0.11048904061317444, -0.023520352318882942, 0.14623485505580902, -0.02884315326809883, -0.022041019052267075, 0.012801518663764, -0.09805117547512054, -0.06970184296369553, -0.024937421083450317, -0.06709377467632294, 0.15044616162776947, 0.06202203407883644, 0.11438529193401337, 0.013654503040015697, 0.2188536822795868, 0.10266657918691635, 0.013793042860925198, -0.07577130943536758, 0.6482155919075012, -0.3580440282821655, 0.13157278299331665, -0.1349758803844452, 0.2399902641773224, 0.08395548909902573, 0.15252983570098877, 0.005996152758598328, 0.0046967193484306335, 0.10933229327201843, 0.06791824847459793, -0.1011207103729248, 0.09773474931716919, -0.03775539994239807, 0.1991548240184784, -0.014738358557224274, 0.03137823939323425, 0.15016314387321472, -0.0008581243455410004, 0.1492377519607544, -0.08219578862190247, -0.1771942526102066, 0.0720432698726654, -0.0961959958076477, -0.1481809914112091, 0.08069989085197449, 0.23489388823509216, -0.01948634162545204, -0.05521320179104805, 0.037606317549943924, 0.11676538735628128, 0.07146602869033813, 0.01433112844824791, 0.0908520370721817, -0.10224516689777374, 0.2322184443473816, -0.23631541430950165, -0.26949164271354675, 0.05099533870816231, -0.0032930225133895874, 0.02133399248123169, 0.14646194875240326, 0.2170320749282837, 0.10505460947751999, -0.0708325058221817, 0.036886632442474365, 0.033709194511175156, -0.077185720205307, 0.07597463577985764, 0.0917278379201889, 0.09184607863426208, 0.01817331463098526, 0.12530119717121124, -0.04682692885398865, 0.05484325811266899, -0.00815960019826889, -0.17563435435295105, 0.2429785281419754, 0.05343212932348251, 0.05713008716702461, -0.041444551199674606, 0.0740293636918068, -0.11646544933319092, 0.05745719000697136, 0.07895620167255402, 0.00876867026090622, 0.02252514287829399, -0.06855498254299164, 0.10545726120471954, -0.1228962391614914, -0.07281830906867981, 0.04259436950087547, 0.06717053055763245, 0.024388577789068222, 0.1033787876367569, 0.13202515244483948, 0.1325465738773346, -0.11950912326574326, -0.10122092068195343, -0.06407450139522552, -0.18481981754302979, -0.0029030069708824158, -0.06074465811252594, 0.05863744020462036, 0.06647494435310364, 0.04387415945529938, -0.02683570235967636, 0.04950542375445366, -0.17732590436935425, -0.08694398403167725, 0.1467471867799759, 0.04109679162502289, 0.1522878110408783, -0.1008504256606102, -0.04335871338844299, -0.08566959202289581, -0.07036598771810532, -0.02401670068502426, -0.14561130106449127, 0.19616377353668213, -0.0714661180973053, -0.040939413011074066, 0.2523844838142395, 0.07077845931053162, 0.17145425081253052, 0.09514762461185455, -0.03703045845031738, -0.09853494167327881, -0.08684328198432922, 0.006622038781642914, 0.06577377021312714, -0.09252776205539703, -0.048379674553871155, 0.047085314989089966, 0.039024487137794495, -0.06685902178287506, -0.058934636414051056, 0.3740667402744293, 0.06941965967416763, -0.1557161509990692, 0.0796375498175621, -0.0072639696300029755, -0.042416222393512726, -0.10887542366981506, -0.5542542338371277, 0.11015510559082031, 0.15743067860603333, 0.13656412065029144, 0.051522523164749146, 0.07720653712749481, 0.042346611618995667, 0.056861162185668945, 0.18656884133815765, 0.08645429462194443, -0.10636778920888901, 0.06284479796886444, 0.047154270112514496, 0.13770030438899994, 0.025208525359630585, 0.04760774224996567, 0.07770335674285889, 0.03738144785165787, 0.05942894518375397, -0.07292092591524124, -0.13524480164051056, -0.011966343969106674, 0.00231102854013443, -0.19528068602085114, -0.11627690494060516, 0.17503580451011658, -0.1508815437555313, -0.013457238674163818, 0.021587714552879333, 0.1007213369011879, -0.08173426985740662, -0.028069833293557167, -0.0904134139418602, 0.15751953423023224, 0.13033515214920044, -0.09488536417484283, -0.0919979065656662, 0.025210443884134293, -0.13461166620254517, 0.026708509773015976, 0.1031876876950264, 0.2712234854698181, 0.12103796005249023, 0.16331090033054352, -0.009725239127874374, 0.08773919194936752, -0.028271768242120743, 0.05515489727258682, 0.08406361192464828, 0.11946094036102295, -0.06259538233280182, -0.054288703948259354, 0.010331498458981514, 0.020817816257476807, 0.11662154644727707, 0.05848485231399536, -0.04105649143457413, -0.023970860987901688, 0.05759202688932419, 0.14744587242603302, 0.04081771522760391, 0.035075441002845764, 0.024026725441217422, 0.09599590301513672, 0.0815846174955368, 0.02960478514432907, 0.13966228067874908, -0.11979851126670837, -0.1222313940525055, 0.06219974905252457, 0.015910228714346886, -0.031701505184173584, -0.030070673674345016, 0.1582126021385193, -0.08268869668245316, 0.05594022199511528, 0.016199486330151558, 0.16261541843414307, 0.033592887222766876, 0.019538551568984985, 0.023388687521219254, -0.033415939658880234, 0.024464692920446396, 0.0050507802516222, -0.07441633939743042, 0.0038117561489343643, 0.004300042521208525, -0.10477155447006226, -0.06627101451158524, 0.13145171105861664, -0.11494942009449005, 0.07343079149723053, -0.11506617069244385, 0.22944530844688416, -0.05856679379940033, 0.08151881396770477, -0.045549407601356506, -0.056387919932603836, -0.7441742420196533, -0.004044156521558762, 0.12663765251636505, -0.07125747203826904, 0.03049447014927864, 0.10863900184631348, 0.06698916852474213, 0.01860925182700157, 0.0847693532705307, 0.057596176862716675, -0.04456665366888046, 0.1365251988172531, 0.149383082985878, -0.2929746210575104, 0.05951446667313576, 0.06403302401304245, 0.0416693352162838, -0.08152838796377182, 0.053652409464120865, -0.09039276838302612, 0.0043731629848480225, -0.0165935680270195, 0.04977398365736008, 0.15217582881450653, 0.02783029153943062, 0.2246686816215515, 0.07647331058979034, 0.13749998807907104, -0.09333781898021698, 0.14842727780342102, 0.2734774053096771, -0.0665326714515686, -0.15997949242591858, 0.12055781483650208, 0.05778668820858002, 0.05734139680862427, 0.15859109163284302, 13.661033630371094, -0.11494281888008118, 0.11934921145439148, 0.11613423377275467, -0.10799402743577957, -0.01859624683856964, -0.037988223135471344, 0.09142439067363739, -0.02839478850364685, 0.013675428926944733, 0.08454715460538864, 0.01200894545763731, -0.008673606440424919, 0.12232351303100586, -0.0005763620138168335, -0.025072388350963593, 0.0396035835146904, -0.023150062188506126, 0.19471846520900726, 0.005465395748615265, 0.05549292266368866, -0.04632021486759186, 0.0038123205304145813, -0.2690386176109314, -0.18143825232982635, 0.13046756386756897, 0.13859263062477112, 0.06966768205165863, 0.07575429975986481, 0.07834582030773163, 0.13679999113082886, 0.13776779174804688, -0.03488742187619209, -0.06681607663631439, -0.25106456875801086, -0.15872623026371002, -0.46989041566848755, -0.06330369412899017, 0.06976468116044998, -0.054362647235393524, 0.09304917603731155, 0.0359593890607357, 0.15941214561462402, -0.07440225780010223, 0.010973308235406876, -0.03830081969499588, -0.08674882352352142, 0.0979263037443161, 0.12742885947227478, -0.054152317345142365, 0.11452731490135193, 0.07080584764480591, 0.2594083547592163, 0.05883371829986572, -0.07797623425722122, -0.2164054960012436, 0.1937611699104309, 0.11671768128871918, 0.07058142870664597, 0.2334686815738678, -0.03594297170639038, -0.0691201314330101, -0.06074923649430275, -0.05062944069504738, -0.10382650047540665, 0.14851433038711548, 0.20217956602573395, 0.06658262014389038, 0.2138494998216629, 0.12550200521945953, 0.11531715095043182, -0.0488976389169693, 0.03992416709661484, 0.11201045662164688, -0.21872437000274658, 0.08616503328084946, -0.14504596590995789, 0.005455764010548592, 0.040721628814935684, -0.19531695544719696, 0.05942057818174362, -0.018083132803440094, -0.1392088681459427, -0.009881401434540749, -0.09280240535736084, 0.16166871786117554, -0.16582486033439636, 0.19951091706752777, 0.16009338200092316, 0.02917482517659664, -0.04808787629008293, 0.0285854022949934, -0.02815520018339157, -0.04958915710449219, 0.22395914793014526, -0.10153143852949142, 0.11521488428115845, -0.22102920711040497, 0.09281948953866959, -0.032220616936683655, -0.14949917793273926, -0.12175677716732025, 0.010498307645320892, 0.07172015309333801, -0.08093494921922684, -0.004101205617189407, 0.04245380684733391, -0.014495477080345154, -0.04988040030002594, 0.036413077265024185, 0.07213474810123444, 0.24027913808822632, 0.07810667157173157, -0.17941491305828094, -0.06703217327594757, -0.03752632066607475, 0.03726975619792938, 0.0280475877225399, 0.12142754346132278, 0.015738442540168762, 0.16883428394794464, -0.00660325214266777, -0.0072922855615615845, -0.08221547305583954, 0.17879128456115723, -0.0012210663408041, 0.039357393980026245, 0.21832142770290375, 0.19362062215805054, -0.039619412273168564, 0.09406498074531555, -0.13358908891677856, 0.25184333324432373, 0.14135268330574036, -0.05494038015604019, 0.08565716445446014, -0.07338664680719376, 0.03589486703276634, 0.1496342420578003, 0.11816130578517914, 0.05731917545199394, 0.10452546179294586, 0.17608071863651276, -0.14255093038082123, -0.1062430888414383, 0.09336380660533905, 0.29980501532554626, -0.06973503530025482, -0.037222158163785934, 0.0950281023979187, 0.1546441912651062, 0.27466845512390137, -0.0607495978474617, -0.11397294700145721, -0.07599836587905884, -0.15199361741542816, -0.07392169535160065, 0.10549129545688629, 0.05465826019644737, -0.029385298490524292, 0.23920470476150513, -0.5454986095428467, -0.09027557820081711, -0.2695845365524292, -0.1806664615869522, 0.05202827602624893, 0.1520891785621643, -0.0673249363899231, 0.03871312737464905, -0.07888706773519516, 0.23292940855026245, 0.02049899287521839, -0.19487205147743225, 0.00770733505487442, -0.04611852392554283, 0.0274294875562191, 0.2308758795261383, -0.2993185520172119, -0.14562085270881653, -0.02562689781188965]}"
"{\"sha\": \"00ede07ca6c77e3b71aaa699b2c48b9718700cc8\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"test/unit/munit.c\", \"func_name\": \"psnip_uint32_t\\npsnip_clock_get_precision\", \"original_string\": \"PSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_get_precision (enum PsnipClockType clock_type) {\\n  switch (clock_type) {\\n    case PSNIP_CLOCK_TYPE_MONOTONIC:\\n      return psnip_clock_monotonic_get_precision ();\\n    case PSNIP_CLOCK_TYPE_CPU:\\n      return psnip_clock_cpu_get_precision ();\\n    case PSNIP_CLOCK_TYPE_WALL:\\n      return psnip_clock_wall_get_precision ();\\n  }\\n\\n  PSNIP_CLOCK_UNREACHABLE();\\n  return 0;\\n}\", \"code_tokens\": [\"PSNIP_CLOCK__FUNCTION\", \"psnip_uint32_t\", \"\", \"psnip_clock_get_precision\", \"(\", \"enum\", \"PsnipClockType\", \"clock_type\", \")\", \"{\", \"switch\", \"(\", \"clock_type\", \")\", \"{\", \"case\", \"PSNIP_CLOCK_TYPE_MONOTONIC\", \":\", \"return\", \"psnip_clock_monotonic_get_precision\", \"(\", \")\", \";\", \"case\", \"PSNIP_CLOCK_TYPE_CPU\", \":\", \"return\", \"psnip_clock_cpu_get_precision\", \"(\", \")\", \";\", \"case\", \"PSNIP_CLOCK_TYPE_WALL\", \":\", \"return\", \"psnip_clock_wall_get_precision\", \"(\", \")\", \";\", \"}\", \"PSNIP_CLOCK_UNREACHABLE\", \"(\", \")\", \";\", \"return\", \"0\", \";\", \"}\"], \"docstring\": \"/* Returns the number of ticks per second for the specified clock.\\n * For example, a clock with millisecond precision would return 1000,\\n * and a clock with 1 second (such as the time() function) would\\n * return 1.\\n *\\n * If the requested clock isn't available, it will return 0.\\n * Hopefully this will be rare, but if it happens to you please let us\\n * know so we can work on finding a way to support your system.\\n *\\n * Note that different clocks on the same system often have a\\n * different precisions.\\n */\", \"docstring_tokens\": [\"/\", \"*\", \"Returns\", \"the\", \"number\", \"of\", \"ticks\", \"per\", \"second\", \"for\", \"the\", \"specified\", \"clock\", \".\", \"*\", \"For\", \"example\", \"a\", \"clock\", \"with\", \"millisecond\", \"precision\", \"would\", \"return\", \"1000\", \"*\", \"and\", \"a\", \"clock\", \"with\", \"1\", \"second\", \"(\", \"such\", \"as\", \"the\", \"time\", \"()\", \"function\", \")\", \"would\", \"*\", \"return\", \"1\", \".\", \"*\", \"*\", \"If\", \"the\", \"requested\", \"clock\", \"isn\", \"'\", \"t\", \"available\", \"it\", \"will\", \"return\", \"0\", \".\", \"*\", \"Hopefully\", \"this\", \"will\", \"be\", \"rare\", \"but\", \"if\", \"it\", \"happens\", \"to\", \"you\", \"please\", \"let\", \"us\", \"*\", \"know\", \"so\", \"we\", \"can\", \"work\", \"on\", \"finding\", \"a\", \"way\", \"to\", \"support\", \"your\", \"system\", \".\", \"*\", \"*\", \"Note\", \"that\", \"different\", \"clocks\", \"on\", \"the\", \"same\", \"system\", \"often\", \"have\", \"a\", \"*\", \"different\", \"precisions\", \".\", \"*\", \"/\"], \"raw_contents\": \"/* Copyright (c) 2013-2018 Evan Nemerson <evan@nemerson.com>\\n *\\n * Permission is hereby granted, free of charge, to any person\\n * obtaining a copy of this software and associated documentation\\n * files (the \\\"Software\\\"), to deal in the Software without\\n * restriction, including without limitation the rights to use, copy,\\n * modify, merge, publish, distribute, sublicense, and/or sell copies\\n * of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be\\n * included in all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND,\\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n * SOFTWARE.\\n */\\n\\n/*** Configuration ***/\\n\\n/* This is just where the output from the test goes.  It's really just\\n * meant to let you choose stdout or stderr, but if anyone really want\\n * to direct it to a file let me know, it would be fairly easy to\\n * support. */\\n#if !defined(MUNIT_OUTPUT_FILE)\\n#  define MUNIT_OUTPUT_FILE stdout\\n#endif\\n\\n/* This is a bit more useful; it tells \\u00b5nit how to format the seconds in\\n * timed tests.  If your tests run for longer you might want to reduce\\n * it, and if your computer is really fast and your tests are tiny you\\n * can increase it. */\\n#if !defined(MUNIT_TEST_TIME_FORMAT)\\n#  define MUNIT_TEST_TIME_FORMAT \\\"0.8f\\\"\\n#endif\\n\\n/* If you have long test names you might want to consider bumping\\n * this.  The result information takes 43 characters. */\\n#if !defined(MUNIT_TEST_NAME_LEN)\\n#  define MUNIT_TEST_NAME_LEN 37\\n#endif\\n\\n/* If you don't like the timing information, you can disable it by\\n * defining MUNIT_DISABLE_TIMING. */\\n#if !defined(MUNIT_DISABLE_TIMING)\\n#  define MUNIT_ENABLE_TIMING\\n#endif\\n\\n/*** End configuration ***/\\n\\n#if defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE < 200809L)\\n#  undef _POSIX_C_SOURCE\\n#endif\\n#if !defined(_POSIX_C_SOURCE)\\n#  define _POSIX_C_SOURCE 200809L\\n#endif\\n\\n/* Solaris freaks out if you try to use a POSIX or SUS standard without\\n * the \\\"right\\\" C standard. */\\n#if defined(_XOPEN_SOURCE)\\n#  undef _XOPEN_SOURCE\\n#endif\\n\\n#if defined(__STDC_VERSION__)\\n#  if __STDC_VERSION__ >= 201112L\\n#    define _XOPEN_SOURCE 700\\n#  elif __STDC_VERSION__ >= 199901L\\n#    define _XOPEN_SOURCE 600\\n#  endif\\n#endif\\n\\n/* Because, according to Microsoft, POSIX is deprecated.  You've got\\n * to appreciate the chutzpah. */\\n#if defined(_MSC_VER) && !defined(_CRT_NONSTDC_NO_DEPRECATE)\\n#  define _CRT_NONSTDC_NO_DEPRECATE\\n#endif\\n\\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\\n#  include <stdbool.h>\\n#elif defined(_WIN32)\\n/* https://msdn.microsoft.com/en-us/library/tf4dy80a.aspx */\\n#endif\\n\\n#include <limits.h>\\n#include <time.h>\\n#include <errno.h>\\n#include <string.h>\\n#include <stdlib.h>\\n#include <stdio.h>\\n#include <stdarg.h>\\n#include <setjmp.h>\\n\\n#if !defined(MUNIT_NO_NL_LANGINFO) && !defined(_WIN32)\\n#define MUNIT_NL_LANGINFO\\n#include <locale.h>\\n#include <langinfo.h>\\n#include <strings.h>\\n#endif\\n\\n#if !defined(_WIN32)\\n#  include <unistd.h>\\n#  include <sys/types.h>\\n#  include <sys/wait.h>\\n#else\\n#  include <windows.h>\\n#  include <io.h>\\n#  include <fcntl.h>\\n#  if !defined(STDERR_FILENO)\\n#    define STDERR_FILENO _fileno(stderr)\\n#  endif\\n#endif\\n\\n#include \\\"munit.h\\\"\\n\\n#define MUNIT_STRINGIFY(x) #x\\n#define MUNIT_XSTRINGIFY(x) MUNIT_STRINGIFY(x)\\n\\n#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__SUNPRO_CC) || defined(__IBMCPP__)\\n#  define MUNIT_THREAD_LOCAL __thread\\n#elif (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201102L)) || defined(_Thread_local)\\n#  define MUNIT_THREAD_LOCAL _Thread_local\\n#elif defined(_WIN32)\\n#  define MUNIT_THREAD_LOCAL __declspec(thread)\\n#endif\\n\\n/* MSVC 12.0 will emit a warning at /W4 for code like 'do { ... }\\n * while (0)', or 'do { ... } while (1)'.  I'm pretty sure nobody\\n * at Microsoft compiles with /W4. */\\n#if defined(_MSC_VER) && (_MSC_VER <= 1800)\\n#pragma warning(disable: 4127)\\n#endif\\n\\n#if defined(_WIN32) || defined(__EMSCRIPTEN__)\\n#  define MUNIT_NO_FORK\\n#endif\\n\\n#if defined(__EMSCRIPTEN__)\\n#  define MUNIT_NO_BUFFER\\n#endif\\n\\n/*** Logging ***/\\n\\nstatic MunitLogLevel munit_log_level_visible = MUNIT_LOG_INFO;\\nstatic MunitLogLevel munit_log_level_fatal = MUNIT_LOG_ERROR;\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\nstatic MUNIT_THREAD_LOCAL munit_bool munit_error_jmp_buf_valid = 0;\\nstatic MUNIT_THREAD_LOCAL jmp_buf munit_error_jmp_buf;\\n#endif\\n\\n/* At certain warning levels, mingw will trigger warnings about\\n * suggesting the format attribute, which we've explicity *not* set\\n * because it will then choke on our attempts to use the MS-specific\\n * I64 modifier for size_t (which we have to use since MSVC doesn't\\n * support the C99 z modifier). */\\n\\n#if defined(__MINGW32__) || defined(__MINGW64__)\\n#  pragma GCC diagnostic push\\n#  pragma GCC diagnostic ignored \\\"-Wsuggest-attribute=format\\\"\\n#endif\\n\\nMUNIT_PRINTF(5,0)\\nstatic void\\nmunit_logf_exv(MunitLogLevel level, FILE* fp, const char* filename, int line, const char* format, va_list ap) {\\n  if (level < munit_log_level_visible)\\n    return;\\n\\n  switch (level) {\\n    case MUNIT_LOG_DEBUG:\\n      fputs(\\\"Debug\\\", fp);\\n      break;\\n    case MUNIT_LOG_INFO:\\n      fputs(\\\"Info\\\", fp);\\n      break;\\n    case MUNIT_LOG_WARNING:\\n      fputs(\\\"Warning\\\", fp);\\n      break;\\n    case MUNIT_LOG_ERROR:\\n      fputs(\\\"Error\\\", fp);\\n      break;\\n    default:\\n      munit_logf_ex(MUNIT_LOG_ERROR, filename, line, \\\"Invalid log level (%d)\\\", level);\\n      return;\\n  }\\n\\n  fputs(\\\": \\\", fp);\\n  if (filename != NULL)\\n    fprintf(fp, \\\"%s:%d: \\\", filename, line);\\n  vfprintf(fp, format, ap);\\n  fputc('\\\\n', fp);\\n}\\n\\nMUNIT_PRINTF(3,4)\\nstatic void\\nmunit_logf_internal(MunitLogLevel level, FILE* fp, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(level, fp, NULL, 0, format, ap);\\n  va_end(ap);\\n}\\n\\nstatic void\\nmunit_log_internal(MunitLogLevel level, FILE* fp, const char* message) {\\n  munit_logf_internal(level, fp, \\\"%s\\\", message);\\n}\\n\\nvoid\\nmunit_logf_ex(MunitLogLevel level, const char* filename, int line, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(level, stderr, filename, line, format, ap);\\n  va_end(ap);\\n\\n  if (level >= munit_log_level_fatal) {\\n#if defined(MUNIT_THREAD_LOCAL)\\n    if (munit_error_jmp_buf_valid)\\n      longjmp(munit_error_jmp_buf, 1);\\n#endif\\n    abort();\\n  }\\n}\\n\\nvoid\\nmunit_errorf_ex(const char* filename, int line, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(MUNIT_LOG_ERROR, stderr, filename, line, format, ap);\\n  va_end(ap);\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\n  if (munit_error_jmp_buf_valid)\\n    longjmp(munit_error_jmp_buf, 1);\\n#endif\\n  abort();\\n}\\n\\n#if defined(__MINGW32__) || defined(__MINGW64__)\\n#pragma GCC diagnostic pop\\n#endif\\n\\n#if !defined(MUNIT_STRERROR_LEN)\\n#  define MUNIT_STRERROR_LEN 80\\n#endif\\n\\nstatic void\\nmunit_log_errno(MunitLogLevel level, FILE* fp, const char* msg) {\\n#if defined(MUNIT_NO_STRERROR_R) || (defined(__MINGW32__) && !defined(MINGW_HAS_SECURE_API))\\n  munit_logf_internal(level, fp, \\\"%s: %s (%d)\\\", msg, strerror(errno), errno);\\n#else\\n  char munit_error_str[MUNIT_STRERROR_LEN];\\n  munit_error_str[0] = '\\\\0';\\n\\n#if !defined(_WIN32)\\n  strerror_r(errno, munit_error_str, MUNIT_STRERROR_LEN);\\n#else\\n  strerror_s(munit_error_str, MUNIT_STRERROR_LEN, errno);\\n#endif\\n\\n  munit_logf_internal(level, fp, \\\"%s: %s (%d)\\\", msg, munit_error_str, errno);\\n#endif\\n}\\n\\n/*** Memory allocation ***/\\n\\nvoid*\\nmunit_malloc_ex(const char* filename, int line, size_t size) {\\n  void* ptr;\\n\\n  if (size == 0)\\n    return NULL;\\n\\n  ptr = calloc(1, size);\\n  if (MUNIT_UNLIKELY(ptr == NULL)) {\\n    munit_logf_ex(MUNIT_LOG_ERROR, filename, line, \\\"Failed to allocate %\\\" MUNIT_SIZE_MODIFIER \\\"u bytes.\\\", size);\\n  }\\n\\n  return ptr;\\n}\\n\\n/*** Timer code ***/\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n\\n#define psnip_uint64_t munit_uint64_t\\n#define psnip_uint32_t munit_uint32_t\\n\\n/* Code copied from portable-snippets\\n * <https://github.com/nemequ/portable-snippets/>.  If you need to\\n * change something, please do it there so we can keep the code in\\n * sync. */\\n\\n/* Clocks (v1)\\n * Portable Snippets - https://gitub.com/nemequ/portable-snippets\\n * Created by Evan Nemerson <evan@nemerson.com>\\n *\\n *   To the extent possible under law, the authors have waived all\\n *   copyright and related or neighboring rights to this code.  For\\n *   details, see the Creative Commons Zero 1.0 Universal license at\\n *   https://creativecommons.org/publicdomain/zero/1.0/\\n */\\n\\n#if !defined(PSNIP_CLOCK_H)\\n#define PSNIP_CLOCK_H\\n\\n#if !defined(psnip_uint64_t)\\n#  include \\\"../exact-int/exact-int.h\\\"\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_STATIC_INLINE)\\n#  if defined(__GNUC__)\\n#    define PSNIP_CLOCK__COMPILER_ATTRIBUTES __attribute__((__unused__))\\n#  else\\n#    define PSNIP_CLOCK__COMPILER_ATTRIBUTES\\n#  endif\\n\\n#  define PSNIP_CLOCK__FUNCTION PSNIP_CLOCK__COMPILER_ATTRIBUTES static\\n#endif\\n\\nenum PsnipClockType {\\n  /* This clock provides the current time, in units since 1970-01-01\\n   * 00:00:00 UTC not including leap seconds.  In other words, UNIX\\n   * time.  Keep in mind that this clock doesn't account for leap\\n   * seconds, and can go backwards (think NTP adjustments). */\\n  PSNIP_CLOCK_TYPE_WALL = 1,\\n  /* The CPU time is a clock which increases only when the current\\n   * process is active (i.e., it doesn't increment while blocking on\\n   * I/O). */\\n  PSNIP_CLOCK_TYPE_CPU = 2,\\n  /* Monotonic time is always running (unlike CPU time), but it only\\n     ever moves forward unless you reboot the system.  Things like NTP\\n     adjustments have no effect on this clock. */\\n  PSNIP_CLOCK_TYPE_MONOTONIC = 3\\n};\\n\\nstruct PsnipClockTimespec {\\n  psnip_uint64_t seconds;\\n  psnip_uint64_t nanoseconds;\\n};\\n\\n/* Methods we support: */\\n\\n#define PSNIP_CLOCK_METHOD_CLOCK_GETTIME                   1\\n#define PSNIP_CLOCK_METHOD_TIME                            2\\n#define PSNIP_CLOCK_METHOD_GETTIMEOFDAY                    3\\n#define PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER         4\\n#define PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME              5\\n#define PSNIP_CLOCK_METHOD_CLOCK                           6\\n#define PSNIP_CLOCK_METHOD_GETPROCESSTIMES                 7\\n#define PSNIP_CLOCK_METHOD_GETRUSAGE                       8\\n#define PSNIP_CLOCK_METHOD_GETSYSTEMTIMEPRECISEASFILETIME  9\\n#define PSNIP_CLOCK_METHOD_GETTICKCOUNT64                 10\\n\\n#include <assert.h>\\n\\n#if defined(HEDLEY_UNREACHABLE)\\n#  define PSNIP_CLOCK_UNREACHABLE() HEDLEY_UNREACHABLE()\\n#else\\n#  define PSNIP_CLOCK_UNREACHABLE() assert(0)\\n#endif\\n\\n/* Choose an implementation */\\n\\n/* #undef PSNIP_CLOCK_WALL_METHOD */\\n/* #undef PSNIP_CLOCK_CPU_METHOD */\\n/* #undef PSNIP_CLOCK_MONOTONIC_METHOD */\\n\\n/* We want to be able to detect the libc implementation, so we include\\n   <limits.h> (<features.h> isn't available everywhere). */\\n\\n#if defined(__unix__) || defined(__unix) || defined(__linux__)\\n#  include <limits.h>\\n#  include <unistd.h>\\n#endif\\n\\n#if defined(_POSIX_TIMERS) && (_POSIX_TIMERS > 0)\\n/* These are known to work without librt.  If you know of others\\n * please let us know so we can add them. */\\n#  if \\\\\\n  (defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 17))) || \\\\\\n  (defined(__FreeBSD__))\\n#    define PSNIP_CLOCK_HAVE_CLOCK_GETTIME\\n#  elif !defined(PSNIP_CLOCK_NO_LIBRT)\\n#    define PSNIP_CLOCK_HAVE_CLOCK_GETTIME\\n#  endif\\n#endif\\n\\n#if defined(_WIN32)\\n#  if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#    define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n#  endif\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n#  endif\\n#endif\\n\\n#if defined(__MACH__) && !defined(__gnu_hurd__)\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n#  endif\\n#endif\\n\\n#if defined(PSNIP_CLOCK_HAVE_CLOCK_GETTIME)\\n#  include <time.h>\\n#  if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#    if defined(CLOCK_REALTIME_PRECISE)\\n#      define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_WALL CLOCK_REALTIME_PRECISE\\n#    elif !defined(__sun)\\n#      define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_WALL CLOCK_REALTIME\\n#    endif\\n#  endif\\n#  if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#    if defined(_POSIX_CPUTIME) || defined(CLOCK_PROCESS_CPUTIME_ID)\\n#      define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_CPU CLOCK_PROCESS_CPUTIME_ID\\n#    elif defined(CLOCK_VIRTUAL)\\n#      define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_CPU CLOCK_VIRTUAL\\n#    endif\\n#  endif\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    if defined(CLOCK_MONOTONIC_RAW)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC\\n#    elif defined(CLOCK_MONOTONIC_PRECISE)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC_PRECISE\\n#    elif defined(_POSIX_MONOTONIC_CLOCK) || defined(CLOCK_MONOTONIC)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC\\n#    endif\\n#  endif\\n#endif\\n\\n#if defined(_POSIX_VERSION) && (_POSIX_VERSION >= 200112L)\\n#  if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#    define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n#  endif\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#  define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_TIME\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#  define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK\\n#endif\\n\\n/* Primarily here for testing. */\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD) && defined(PSNIP_CLOCK_REQUIRE_MONOTONIC)\\n#  error No monotonic clock found.\\n#endif\\n\\n/* Implementations */\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_TIME))\\n#  include <time.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETTIMEOFDAY)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETTIMEOFDAY)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY))\\n#  include <sys/time.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETTICKCOUNT64)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETTICKCOUNT64)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64))\\n#  include <windows.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETRUSAGE)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETRUSAGE)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETRUSAGE))\\n#  include <sys/time.h>\\n#  include <sys/resource.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME))\\n#  include <CoreServices/CoreServices.h>\\n#  include <mach/mach.h>\\n#  include <mach/mach_time.h>\\n#endif\\n\\n/*** Implementations ***/\\n\\n#define PSNIP_CLOCK_NSEC_PER_SEC ((psnip_uint32_t) (1000000000ULL))\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME))\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock__clock_getres (clockid_t clk_id) {\\n  struct timespec res;\\n  int r;\\n\\n  r = clock_getres(clk_id, &res);\\n  if (r != 0)\\n    return 0;\\n\\n  return (psnip_uint32_t) (PSNIP_CLOCK_NSEC_PER_SEC / res.tv_nsec);\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock__clock_gettime (clockid_t clk_id, struct PsnipClockTimespec* res) {\\n  struct timespec ts;\\n\\n  if (clock_gettime(clk_id, &ts) != 0)\\n    return -10;\\n\\n  res->seconds = (psnip_uint64_t) (ts.tv_sec);\\n  res->nanoseconds = (psnip_uint64_t) (ts.tv_nsec);\\n\\n  return 0;\\n}\\n#endif\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_wall_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_WALL);\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n  return 1000000;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_TIME\\n  return 1;\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_wall_get_time (struct PsnipClockTimespec* res) {\\n  (void) res;\\n\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n  return -2;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_WALL, res);\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_TIME\\n  res->seconds = time(NULL);\\n  res->nanoseconds = 0;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n  struct timeval tv;\\n\\n  if (gettimeofday(&tv, NULL) != 0)\\n    return -6;\\n\\n  res->seconds = tv.tv_sec;\\n  res->nanoseconds = tv.tv_usec * 1000;\\n#else\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_cpu_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_CPU);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK\\n  return CLOCKS_PER_SEC;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n  return PSNIP_CLOCK_NSEC_PER_SEC / 100;\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_cpu_get_time (struct PsnipClockTimespec* res) {\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n  (void) res;\\n  return -2;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_CPU, res);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK\\n  clock_t t = clock();\\n  if (t == ((clock_t) -1))\\n    return -5;\\n  res->seconds = t / CLOCKS_PER_SEC;\\n  res->nanoseconds = (t % CLOCKS_PER_SEC) * (PSNIP_CLOCK_NSEC_PER_SEC / CLOCKS_PER_SEC);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n  FILETIME CreationTime, ExitTime, KernelTime, UserTime;\\n  LARGE_INTEGER date, adjust;\\n\\n  if (!GetProcessTimes(GetCurrentProcess(), &CreationTime, &ExitTime, &KernelTime, &UserTime))\\n    return -7;\\n\\n  /* http://www.frenk.com/2009/12/convert-filetime-to-unix-timestamp/ */\\n  date.HighPart = UserTime.dwHighDateTime;\\n  date.LowPart = UserTime.dwLowDateTime;\\n  adjust.QuadPart = 11644473600000 * 10000;\\n  date.QuadPart -= adjust.QuadPart;\\n\\n  res->seconds = date.QuadPart / 10000000;\\n  res->nanoseconds = (date.QuadPart % 10000000) * (PSNIP_CLOCK_NSEC_PER_SEC / 100);\\n#elif PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETRUSAGE\\n  struct rusage usage;\\n  if (getrusage(RUSAGE_SELF, &usage) != 0)\\n    return -8;\\n\\n  res->seconds = usage.ru_utime.tv_sec;\\n  res->nanoseconds = tv.tv_usec * 1000;\\n#else\\n  (void) res;\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_monotonic_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n  static mach_timebase_info_data_t tbi = { 0, };\\n  if (tbi.denom == 0)\\n    mach_timebase_info(&tbi);\\n  return (psnip_uint32_t) (tbi.numer / tbi.denom);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64\\n  return 1000;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n  LARGE_INTEGER Frequency;\\n  QueryPerformanceFrequency(&Frequency);\\n  return (psnip_uint32_t) ((Frequency.QuadPart > PSNIP_CLOCK_NSEC_PER_SEC) ? PSNIP_CLOCK_NSEC_PER_SEC : Frequency.QuadPart);\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_monotonic_get_time (struct PsnipClockTimespec* res) {\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n  (void) res;\\n  return -2;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC, res);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n  psnip_uint64_t nsec = mach_absolute_time();\\n  static mach_timebase_info_data_t tbi = { 0, };\\n  if (tbi.denom == 0)\\n    mach_timebase_info(&tbi);\\n  nsec *= ((psnip_uint64_t) tbi.numer) / ((psnip_uint64_t) tbi.denom);\\n  res->seconds = nsec / PSNIP_CLOCK_NSEC_PER_SEC;\\n  res->nanoseconds = nsec % PSNIP_CLOCK_NSEC_PER_SEC;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n  LARGE_INTEGER t, f;\\n  if (QueryPerformanceCounter(&t) == 0)\\n    return -12;\\n\\n  QueryPerformanceFrequency(&f);\\n  res->seconds = t.QuadPart / f.QuadPart;\\n  res->nanoseconds = t.QuadPart % f.QuadPart;\\n  if (f.QuadPart > PSNIP_CLOCK_NSEC_PER_SEC)\\n    res->nanoseconds /= f.QuadPart / PSNIP_CLOCK_NSEC_PER_SEC;\\n  else\\n    res->nanoseconds *= PSNIP_CLOCK_NSEC_PER_SEC / f.QuadPart;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64\\n  const ULONGLONG msec = GetTickCount64();\\n  res->seconds = msec / 1000;\\n  res->nanoseconds = sec % 1000;\\n#else\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\n/* Returns the number of ticks per second for the specified clock.\\n * For example, a clock with millisecond precision would return 1000,\\n * and a clock with 1 second (such as the time() function) would\\n * return 1.\\n *\\n * If the requested clock isn't available, it will return 0.\\n * Hopefully this will be rare, but if it happens to you please let us\\n * know so we can work on finding a way to support your system.\\n *\\n * Note that different clocks on the same system often have a\\n * different precisions.\\n */\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_get_precision (enum PsnipClockType clock_type) {\\n  switch (clock_type) {\\n    case PSNIP_CLOCK_TYPE_MONOTONIC:\\n      return psnip_clock_monotonic_get_precision ();\\n    case PSNIP_CLOCK_TYPE_CPU:\\n      return psnip_clock_cpu_get_precision ();\\n    case PSNIP_CLOCK_TYPE_WALL:\\n      return psnip_clock_wall_get_precision ();\\n  }\\n\\n  PSNIP_CLOCK_UNREACHABLE();\\n  return 0;\\n}\\n\\n/* Set the provided timespec to the requested time.  Returns 0 on\\n * success, or a negative value on failure. */\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_get_time (enum PsnipClockType clock_type, struct PsnipClockTimespec* res) {\\n  assert(res != NULL);\\n\\n  switch (clock_type) {\\n    case PSNIP_CLOCK_TYPE_MONOTONIC:\\n      return psnip_clock_monotonic_get_time (res);\\n    case PSNIP_CLOCK_TYPE_CPU:\\n      return psnip_clock_cpu_get_time (res);\\n    case PSNIP_CLOCK_TYPE_WALL:\\n      return psnip_clock_wall_get_time (res);\\n  }\\n\\n  return -1;\\n}\\n\\n#endif /* !defined(PSNIP_CLOCK_H) */\\n\\nstatic psnip_uint64_t\\nmunit_clock_get_elapsed(struct PsnipClockTimespec* start, struct PsnipClockTimespec* end) {\\n  psnip_uint64_t r = (end->seconds - start->seconds) * PSNIP_CLOCK_NSEC_PER_SEC;\\n  if (end->nanoseconds < start->nanoseconds) {\\n    r -= (start->nanoseconds - end->nanoseconds);\\n  } else {\\n    r += (end->nanoseconds - start->nanoseconds);\\n  }\\n  return r;\\n}\\n\\n#else\\n#  include <time.h>\\n#endif /* defined(MUNIT_ENABLE_TIMING) */\\n\\n/*** PRNG stuff ***/\\n\\n/* This is (unless I screwed up, which is entirely possible) the\\n * version of PCG with 32-bit state.  It was chosen because it has a\\n * small enough state that we should reliably be able to use CAS\\n * instead of requiring a lock for thread-safety.\\n *\\n * If I did screw up, I probably will not bother changing it unless\\n * there is a significant bias.  It's really not important this be\\n * particularly strong, as long as it is fairly random it's much more\\n * important that it be reproducible, so bug reports have a better\\n * chance of being reproducible. */\\n\\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__) && !defined(__EMSCRIPTEN__) && (!defined(__GNUC_MINOR__) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ > 8))\\n#  define HAVE_STDATOMIC\\n#elif defined(__clang__)\\n#  if __has_extension(c_atomic)\\n#    define HAVE_CLANG_ATOMICS\\n#  endif\\n#endif\\n\\n/* Workaround for http://llvm.org/bugs/show_bug.cgi?id=26911 */\\n#if defined(__clang__) && defined(_WIN32)\\n#  undef HAVE_STDATOMIC\\n#  if defined(__c2__)\\n#    undef HAVE_CLANG_ATOMICS\\n#  endif\\n#endif\\n\\n#if defined(_OPENMP)\\n#  define ATOMIC_UINT32_T uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#elif defined(HAVE_STDATOMIC)\\n#  include <stdatomic.h>\\n#  define ATOMIC_UINT32_T _Atomic uint32_t\\n#  define ATOMIC_UINT32_INIT(x) ATOMIC_VAR_INIT(x)\\n#elif defined(HAVE_CLANG_ATOMICS)\\n#  define ATOMIC_UINT32_T _Atomic uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#elif defined(_WIN32)\\n#  define ATOMIC_UINT32_T volatile LONG\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#else\\n#  define ATOMIC_UINT32_T volatile uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#endif\\n\\nstatic ATOMIC_UINT32_T munit_rand_state = ATOMIC_UINT32_INIT(42);\\n\\n#if defined(_OPENMP)\\nstatic inline void\\nmunit_atomic_store(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T value) {\\n#pragma omp critical (munit_atomics)\\n  *dest = value;\\n}\\n\\nstatic inline uint32_t\\nmunit_atomic_load(ATOMIC_UINT32_T* src) {\\n  int ret;\\n#pragma omp critical (munit_atomics)\\n  ret = *src;\\n  return ret;\\n}\\n\\nstatic inline uint32_t\\nmunit_atomic_cas(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T* expected, ATOMIC_UINT32_T desired) {\\n  munit_bool ret;\\n\\n#pragma omp critical (munit_atomics)\\n  {\\n    if (*dest == *expected) {\\n      *dest = desired;\\n      ret = 1;\\n    } else {\\n      ret = 0;\\n    }\\n  }\\n\\n  return ret;\\n}\\n#elif defined(HAVE_STDATOMIC)\\n#  define munit_atomic_store(dest, value)         atomic_store(dest, value)\\n#  define munit_atomic_load(src)                  atomic_load(src)\\n#  define munit_atomic_cas(dest, expected, value) atomic_compare_exchange_weak(dest, expected, value)\\n#elif defined(HAVE_CLANG_ATOMICS)\\n#  define munit_atomic_store(dest, value)         __c11_atomic_store(dest, value, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_load(src)                  __c11_atomic_load(src, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_cas(dest, expected, value) __c11_atomic_compare_exchange_weak(dest, expected, value, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\\n#elif defined(__GNUC__) && (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)\\n#  define munit_atomic_store(dest, value)         __atomic_store_n(dest, value, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_load(src)                  __atomic_load_n(src, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_cas(dest, expected, value) __atomic_compare_exchange_n(dest, expected, value, 1, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\\n#elif defined(__GNUC__) && (__GNUC__ >= 4)\\n#  define munit_atomic_store(dest,value)          do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\n#  define munit_atomic_cas(dest, expected, value) __sync_bool_compare_and_swap(dest, *expected, value)\\n#elif defined(_WIN32) /* Untested */\\n#  define munit_atomic_store(dest,value)          do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\n#  define munit_atomic_cas(dest, expected, value) InterlockedCompareExchange((dest), (value), *(expected))\\n#else\\n#  warning No atomic implementation, PRNG will not be thread-safe\\n#  define munit_atomic_store(dest, value)         do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\nstatic inline munit_bool\\nmunit_atomic_cas(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T* expected, ATOMIC_UINT32_T desired) {\\n  if (*dest == *expected) {\\n    *dest = desired;\\n    return 1;\\n  } else {\\n    return 0;\\n  }\\n}\\n#endif\\n\\n#define MUNIT_PRNG_MULTIPLIER (747796405U)\\n#define MUNIT_PRNG_INCREMENT  (1729U)\\n\\nstatic munit_uint32_t\\nmunit_rand_next_state(munit_uint32_t state) {\\n  return state * MUNIT_PRNG_MULTIPLIER + MUNIT_PRNG_INCREMENT;\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_from_state(munit_uint32_t state) {\\n  munit_uint32_t res = ((state >> ((state >> 28) + 4)) ^ state) * (277803737U);\\n  res ^= res >> 22;\\n  return res;\\n}\\n\\nvoid\\nmunit_rand_seed(munit_uint32_t seed) {\\n  munit_uint32_t state = munit_rand_next_state(seed + MUNIT_PRNG_INCREMENT);\\n  munit_atomic_store(&munit_rand_state, state);\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_generate_seed(void) {\\n  munit_uint32_t seed, state;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  struct PsnipClockTimespec wc = { 0, };\\n\\n  psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wc);\\n  seed = (munit_uint32_t) wc.nanoseconds;\\n#else\\n  seed = (munit_uint32_t) time(NULL);\\n#endif\\n\\n  state = munit_rand_next_state(seed + MUNIT_PRNG_INCREMENT);\\n  return munit_rand_from_state(state);\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_state_uint32(munit_uint32_t* state) {\\n  const munit_uint32_t old = *state;\\n  *state = munit_rand_next_state(old);\\n  return munit_rand_from_state(old);\\n}\\n\\nmunit_uint32_t\\nmunit_rand_uint32(void) {\\n  munit_uint32_t old, state;\\n\\n  do {\\n    old = munit_atomic_load(&munit_rand_state);\\n    state = munit_rand_next_state(old);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return munit_rand_from_state(old);\\n}\\n\\nstatic void\\nmunit_rand_state_memory(munit_uint32_t* state, size_t size, munit_uint8_t data[MUNIT_ARRAY_PARAM(size)]) {\\n  size_t members_remaining = size / sizeof(munit_uint32_t);\\n  size_t bytes_remaining = size % sizeof(munit_uint32_t);\\n  munit_uint8_t* b = data;\\n  munit_uint32_t rv;\\n  while (members_remaining-- > 0) {\\n    rv = munit_rand_state_uint32(state);\\n    memcpy(b, &rv, sizeof(munit_uint32_t));\\n    b += sizeof(munit_uint32_t);\\n  }\\n  if (bytes_remaining != 0) {\\n    rv = munit_rand_state_uint32(state);\\n    memcpy(b, &rv, bytes_remaining);\\n  }\\n}\\n\\nvoid\\nmunit_rand_memory(size_t size, munit_uint8_t data[MUNIT_ARRAY_PARAM(size)]) {\\n  munit_uint32_t old, state;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n    munit_rand_state_memory(&state, size, data);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_state_at_most(munit_uint32_t* state, munit_uint32_t salt, munit_uint32_t max) {\\n  /* We want (UINT32_MAX + 1) % max, which in unsigned arithmetic is the same\\n   * as (UINT32_MAX + 1 - max) % max = -max % max. We compute -max using not\\n   * to avoid compiler warnings.\\n   */\\n  const munit_uint32_t min = (~max + 1U) % max;\\n  munit_uint32_t x;\\n\\n  if (max == (~((munit_uint32_t) 0U)))\\n    return munit_rand_state_uint32(state) ^ salt;\\n\\n  max++;\\n\\n  do {\\n    x = munit_rand_state_uint32(state) ^ salt;\\n  } while (x < min);\\n\\n  return x % max;\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_at_most(munit_uint32_t salt, munit_uint32_t max) {\\n  munit_uint32_t old, state;\\n  munit_uint32_t retval;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n    retval = munit_rand_state_at_most(&state, salt, max);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return retval;\\n}\\n\\nint\\nmunit_rand_int_range(int min, int max) {\\n  munit_uint64_t range = (munit_uint64_t) max - (munit_uint64_t) min;\\n\\n  if (min > max)\\n    return munit_rand_int_range(max, min);\\n\\n  if (range > (~((munit_uint32_t) 0U)))\\n    range = (~((munit_uint32_t) 0U));\\n\\n  return min + munit_rand_at_most(0, (munit_uint32_t) range);\\n}\\n\\ndouble\\nmunit_rand_double(void) {\\n  munit_uint32_t old, state;\\n  double retval = 0.0;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n\\n    /* See http://mumble.net/~campbell/tmp/random_real.c for how to do\\n     * this right.  Patches welcome if you feel that this is too\\n     * biased. */\\n    retval = munit_rand_state_uint32(&state) / ((~((munit_uint32_t) 0U)) + 1.0);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return retval;\\n}\\n\\n/*** Test suite handling ***/\\n\\ntypedef struct {\\n  unsigned int successful;\\n  unsigned int skipped;\\n  unsigned int failed;\\n  unsigned int errored;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  munit_uint64_t cpu_clock;\\n  munit_uint64_t wall_clock;\\n#endif\\n} MunitReport;\\n\\ntypedef struct {\\n  const char* prefix;\\n  const MunitSuite* suite;\\n  const char** tests;\\n  munit_uint32_t seed;\\n  unsigned int iterations;\\n  MunitParameter* parameters;\\n  munit_bool single_parameter_mode;\\n  void* user_data;\\n  MunitReport report;\\n  munit_bool colorize;\\n  munit_bool fork;\\n  munit_bool show_stderr;\\n  munit_bool fatal_failures;\\n} MunitTestRunner;\\n\\nconst char*\\nmunit_parameters_get(const MunitParameter params[], const char* key) {\\n  const MunitParameter* param;\\n\\n  for (param = params ; param != NULL && param->name != NULL ; param++)\\n    if (strcmp(param->name, key) == 0)\\n      return param->value;\\n  return NULL;\\n}\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\nstatic void\\nmunit_print_time(FILE* fp, munit_uint64_t nanoseconds) {\\n  fprintf(fp, \\\"%\\\" MUNIT_TEST_TIME_FORMAT, ((double) nanoseconds) / ((double) PSNIP_CLOCK_NSEC_PER_SEC));\\n}\\n#endif\\n\\n/* Add a paramter to an array of parameters. */\\nstatic MunitResult\\nmunit_parameters_add(size_t* params_size, MunitParameter* params[MUNIT_ARRAY_PARAM(*params_size)], char* name, char* value) {\\n  *params = realloc(*params, sizeof(MunitParameter) * (*params_size + 2));\\n  if (*params == NULL)\\n    return MUNIT_ERROR;\\n\\n  (*params)[*params_size].name = name;\\n  (*params)[*params_size].value = value;\\n  (*params_size)++;\\n  (*params)[*params_size].name = NULL;\\n  (*params)[*params_size].value = NULL;\\n\\n  return MUNIT_OK;\\n}\\n\\n/* Concatenate two strings, but just return one of the components\\n * unaltered if the other is NULL or \\\"\\\". */\\nstatic char*\\nmunit_maybe_concat(size_t* len, char* prefix, char* suffix) {\\n  char* res;\\n  size_t res_l;\\n  const size_t prefix_l = prefix != NULL ? strlen(prefix) : 0;\\n  const size_t suffix_l = suffix != NULL ? strlen(suffix) : 0;\\n  if (prefix_l == 0 && suffix_l == 0) {\\n    res = NULL;\\n    res_l = 0;\\n  } else if (prefix_l == 0 && suffix_l != 0) {\\n    res = suffix;\\n    res_l = suffix_l;\\n  } else if (prefix_l != 0 && suffix_l == 0) {\\n    res = prefix;\\n    res_l = prefix_l;\\n  } else {\\n    res_l = prefix_l + suffix_l;\\n    res = malloc(res_l + 1);\\n    memcpy(res, prefix, prefix_l);\\n    memcpy(res + prefix_l, suffix, suffix_l);\\n    res[res_l] = 0;\\n  }\\n\\n  if (len != NULL)\\n    *len = res_l;\\n\\n  return res;\\n}\\n\\n/* Possbily free a string returned by munit_maybe_concat. */\\nstatic void\\nmunit_maybe_free_concat(char* s, const char* prefix, const char* suffix) {\\n  if (prefix != s && suffix != s)\\n    free(s);\\n}\\n\\n/* Cheap string hash function, just used to salt the PRNG. */\\nstatic munit_uint32_t\\nmunit_str_hash(const char* name) {\\n  const char *p;\\n  munit_uint32_t h = 5381U;\\n\\n  for (p = name; *p != '\\\\0'; p++)\\n    h = (h << 5) + h + *p;\\n\\n  return h;\\n}\\n\\nstatic void\\nmunit_splice(int from, int to) {\\n  munit_uint8_t buf[1024];\\n#if !defined(_WIN32)\\n  ssize_t len;\\n  ssize_t bytes_written;\\n  ssize_t write_res;\\n#else\\n  int len;\\n  int bytes_written;\\n  int write_res;\\n#endif\\n  do {\\n    len = read(from, buf, sizeof(buf));\\n    if (len > 0) {\\n      bytes_written = 0;\\n      do {\\n        write_res = write(to, buf + bytes_written, len - bytes_written);\\n        if (write_res < 0)\\n          break;\\n        bytes_written += write_res;\\n      } while (bytes_written < len);\\n    }\\n    else\\n      break;\\n  } while (1);\\n}\\n\\n/* This is the part that should be handled in the child process */\\nstatic MunitResult\\nmunit_test_runner_exec(MunitTestRunner* runner, const MunitTest* test, const MunitParameter params[], MunitReport* report) {\\n  unsigned int iterations = runner->iterations;\\n  MunitResult result = MUNIT_FAIL;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  struct PsnipClockTimespec wall_clock_begin = { 0, }, wall_clock_end = { 0, };\\n  struct PsnipClockTimespec cpu_clock_begin = { 0, }, cpu_clock_end = { 0, };\\n#endif\\n  unsigned int i = 0;\\n\\n  if ((test->options & MUNIT_TEST_OPTION_SINGLE_ITERATION) == MUNIT_TEST_OPTION_SINGLE_ITERATION)\\n    iterations = 1;\\n  else if (iterations == 0)\\n    iterations = runner->suite->iterations;\\n\\n  munit_rand_seed(runner->seed);\\n\\n  do {\\n    void* data = (test->setup == NULL) ? runner->user_data : test->setup(params, runner->user_data);\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wall_clock_begin);\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_CPU, &cpu_clock_begin);\\n#endif\\n\\n    result = test->test(params, data);\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wall_clock_end);\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_CPU, &cpu_clock_end);\\n#endif\\n\\n    if (test->tear_down != NULL)\\n      test->tear_down(data);\\n\\n    if (MUNIT_LIKELY(result == MUNIT_OK)) {\\n      report->successful++;\\n#if defined(MUNIT_ENABLE_TIMING)\\n      report->wall_clock += munit_clock_get_elapsed(&wall_clock_begin, &wall_clock_end);\\n      report->cpu_clock += munit_clock_get_elapsed(&cpu_clock_begin, &cpu_clock_end);\\n#endif\\n    } else {\\n      switch ((int) result) {\\n        case MUNIT_SKIP:\\n          report->skipped++;\\n          break;\\n        case MUNIT_FAIL:\\n          report->failed++;\\n          break;\\n        case MUNIT_ERROR:\\n          report->errored++;\\n          break;\\n        default:\\n          break;\\n      }\\n      break;\\n    }\\n  } while (++i < iterations);\\n\\n  return result;\\n}\\n\\n#if defined(MUNIT_EMOTICON)\\n#  define MUNIT_RESULT_STRING_OK    \\\":)\\\"\\n#  define MUNIT_RESULT_STRING_SKIP  \\\":|\\\"\\n#  define MUNIT_RESULT_STRING_FAIL  \\\":(\\\"\\n#  define MUNIT_RESULT_STRING_ERROR \\\":o\\\"\\n#  define MUNIT_RESULT_STRING_TODO  \\\":/\\\"\\n#else\\n#  define MUNIT_RESULT_STRING_OK    \\\"OK   \\\"\\n#  define MUNIT_RESULT_STRING_SKIP  \\\"SKIP \\\"\\n#  define MUNIT_RESULT_STRING_FAIL  \\\"FAIL \\\"\\n#  define MUNIT_RESULT_STRING_ERROR \\\"ERROR\\\"\\n#  define MUNIT_RESULT_STRING_TODO  \\\"TODO \\\"\\n#endif\\n\\nstatic void\\nmunit_test_runner_print_color(const MunitTestRunner* runner, const char* string, char color) {\\n  if (runner->colorize)\\n    fprintf(MUNIT_OUTPUT_FILE, \\\"\\\\x1b[3%cm%s\\\\x1b[39m\\\", color, string);\\n  else\\n    fputs(string, MUNIT_OUTPUT_FILE);\\n}\\n\\n#if !defined(MUNIT_NO_BUFFER)\\nstatic int\\nmunit_replace_stderr(FILE* stderr_buf) {\\n  if (stderr_buf != NULL) {\\n    const int orig_stderr = dup(STDERR_FILENO);\\n\\n    int errfd = fileno(stderr_buf);\\n    if (MUNIT_UNLIKELY(errfd == -1)) {\\n      exit(EXIT_FAILURE);\\n    }\\n\\n    dup2(errfd, STDERR_FILENO);\\n\\n    return orig_stderr;\\n  }\\n\\n  return -1;\\n}\\n\\nstatic void\\nmunit_restore_stderr(int orig_stderr) {\\n  if (orig_stderr != -1) {\\n    dup2(orig_stderr, STDERR_FILENO);\\n    close(orig_stderr);\\n  }\\n}\\n#endif /* !defined(MUNIT_NO_BUFFER) */\\n\\n/* Run a test with the specified parameters. */\\nstatic void\\nmunit_test_runner_run_test_with_params(MunitTestRunner* runner, const MunitTest* test, const MunitParameter params[]) {\\n  MunitResult result = MUNIT_OK;\\n  MunitReport report = {\\n    0, 0, 0, 0,\\n#if defined(MUNIT_ENABLE_TIMING)\\n    0, 0\\n#endif\\n  };\\n  unsigned int output_l;\\n  munit_bool first;\\n  const MunitParameter* param;\\n  FILE* stderr_buf;\\n#if !defined(MUNIT_NO_FORK)\\n  int pipefd[2];\\n  pid_t fork_pid;\\n  int orig_stderr;\\n  ssize_t bytes_written = 0;\\n  ssize_t write_res;\\n  ssize_t bytes_read = 0;\\n  ssize_t read_res;\\n  int status = 0;\\n  pid_t changed_pid;\\n#endif\\n\\n  if (params != NULL) {\\n    output_l = 2;\\n    fputs(\\\"  \\\", MUNIT_OUTPUT_FILE);\\n    first = 1;\\n    for (param = params ; param != NULL && param->name != NULL ; param++) {\\n      if (!first) {\\n        fputs(\\\", \\\", MUNIT_OUTPUT_FILE);\\n        output_l += 2;\\n      } else {\\n        first = 0;\\n      }\\n\\n      output_l += fprintf(MUNIT_OUTPUT_FILE, \\\"%s=%s\\\", param->name, param->value);\\n    }\\n    while (output_l++ < MUNIT_TEST_NAME_LEN) {\\n      fputc(' ', MUNIT_OUTPUT_FILE);\\n    }\\n  }\\n\\n  fflush(MUNIT_OUTPUT_FILE);\\n\\n  stderr_buf = NULL;\\n#if !defined(_WIN32) || defined(__MINGW32__)\\n  stderr_buf = tmpfile();\\n#else\\n  tmpfile_s(&stderr_buf);\\n#endif\\n  if (stderr_buf == NULL) {\\n    munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to create buffer for stderr\\\");\\n    result = MUNIT_ERROR;\\n    goto print_result;\\n  }\\n\\n#if !defined(MUNIT_NO_FORK)\\n  if (runner->fork) {\\n    pipefd[0] = -1;\\n    pipefd[1] = -1;\\n    if (pipe(pipefd) != 0) {\\n      munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to create pipe\\\");\\n      result = MUNIT_ERROR;\\n      goto print_result;\\n    }\\n\\n    fork_pid = fork();\\n    if (fork_pid == 0) {\\n      close(pipefd[0]);\\n\\n      orig_stderr = munit_replace_stderr(stderr_buf);\\n      munit_test_runner_exec(runner, test, params, &report);\\n\\n      /* Note that we don't restore stderr.  This is so we can buffer\\n       * things written to stderr later on (such as by\\n       * asan/tsan/ubsan, valgrind, etc.) */\\n      close(orig_stderr);\\n\\n      do {\\n        write_res = write(pipefd[1], ((munit_uint8_t*) (&report)) + bytes_written, sizeof(report) - bytes_written);\\n        if (write_res < 0) {\\n          if (stderr_buf != NULL) {\\n            munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to write to pipe\\\");\\n          }\\n          exit(EXIT_FAILURE);\\n        }\\n        bytes_written += write_res;\\n      } while ((size_t) bytes_written < sizeof(report));\\n\\n      if (stderr_buf != NULL)\\n        fclose(stderr_buf);\\n      close(pipefd[1]);\\n\\n      exit(EXIT_SUCCESS);\\n    } else if (fork_pid == -1) {\\n      close(pipefd[0]);\\n      close(pipefd[1]);\\n      if (stderr_buf != NULL) {\\n        munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to fork\\\");\\n      }\\n      report.errored++;\\n      result = MUNIT_ERROR;\\n    } else {\\n      close(pipefd[1]);\\n      do {\\n        read_res = read(pipefd[0], ((munit_uint8_t*) (&report)) + bytes_read, sizeof(report) - bytes_read);\\n        if (read_res < 1)\\n          break;\\n        bytes_read += read_res;\\n      } while (bytes_read < (ssize_t) sizeof(report));\\n\\n      changed_pid = waitpid(fork_pid, &status, 0);\\n\\n      if (MUNIT_LIKELY(changed_pid == fork_pid) && MUNIT_LIKELY(WIFEXITED(status))) {\\n        if (bytes_read != sizeof(report)) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child exited unexpectedly with status %d\\\", WEXITSTATUS(status));\\n          report.errored++;\\n        } else if (WEXITSTATUS(status) != EXIT_SUCCESS) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child exited with status %d\\\", WEXITSTATUS(status));\\n          report.errored++;\\n        }\\n      } else {\\n        if (WIFSIGNALED(status)) {\\n#if defined(_XOPEN_VERSION) && (_XOPEN_VERSION >= 700)\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child killed by signal %d (%s)\\\", WTERMSIG(status), strsignal(WTERMSIG(status)));\\n#else\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child killed by signal %d\\\", WTERMSIG(status));\\n#endif\\n        } else if (WIFSTOPPED(status)) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child stopped by signal %d\\\", WSTOPSIG(status));\\n        }\\n        report.errored++;\\n      }\\n\\n      close(pipefd[0]);\\n      waitpid(fork_pid, NULL, 0);\\n    }\\n  } else\\n#endif\\n  {\\n#if !defined(MUNIT_NO_BUFFER)\\n    const volatile int orig_stderr = munit_replace_stderr(stderr_buf);\\n#endif\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\n    if (MUNIT_UNLIKELY(setjmp(munit_error_jmp_buf) != 0)) {\\n      result = MUNIT_FAIL;\\n      report.failed++;\\n    } else {\\n      munit_error_jmp_buf_valid = 1;\\n      result = munit_test_runner_exec(runner, test, params, &report);\\n    }\\n#else\\n    result = munit_test_runner_exec(runner, test, params, &report);\\n#endif\\n\\n#if !defined(MUNIT_NO_BUFFER)\\n    munit_restore_stderr(orig_stderr);\\n#endif\\n\\n    /* Here just so that the label is used on Windows and we don't get\\n     * a warning */\\n    goto print_result;\\n  }\\n\\n print_result:\\n\\n  fputs(\\\"[ \\\", MUNIT_OUTPUT_FILE);\\n  if ((test->options & MUNIT_TEST_OPTION_TODO) == MUNIT_TEST_OPTION_TODO) {\\n    if (report.failed != 0 || report.errored != 0 || report.skipped != 0) {\\n      munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_TODO, '3');\\n      result = MUNIT_OK;\\n    } else {\\n      munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_ERROR, '1');\\n      if (MUNIT_LIKELY(stderr_buf != NULL))\\n        munit_log_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"Test marked TODO, but was successful.\\\");\\n      runner->report.failed++;\\n      result = MUNIT_ERROR;\\n    }\\n  } else if (report.failed > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_FAIL, '1');\\n    runner->report.failed++;\\n    result = MUNIT_FAIL;\\n  } else if (report.errored > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_ERROR, '1');\\n    runner->report.errored++;\\n    result = MUNIT_ERROR;\\n  } else if (report.skipped > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_SKIP, '3');\\n    runner->report.skipped++;\\n    result = MUNIT_SKIP;\\n  } else if (report.successful > 1) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_OK, '2');\\n#if defined(MUNIT_ENABLE_TIMING)\\n    fputs(\\\" ] [ \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock / report.successful);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock / report.successful);\\n    fprintf(MUNIT_OUTPUT_FILE, \\\" CPU ]\\\\n  %-\\\" MUNIT_XSTRINGIFY(MUNIT_TEST_NAME_LEN) \\\"s Total: [ \\\", \\\"\\\");\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock);\\n    fputs(\\\" CPU\\\", MUNIT_OUTPUT_FILE);\\n#endif\\n    runner->report.successful++;\\n    result = MUNIT_OK;\\n  } else if (report.successful > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_OK, '2');\\n#if defined(MUNIT_ENABLE_TIMING)\\n    fputs(\\\" ] [ \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock);\\n    fputs(\\\" CPU\\\", MUNIT_OUTPUT_FILE);\\n#endif\\n    runner->report.successful++;\\n    result = MUNIT_OK;\\n  }\\n  fputs(\\\" ]\\\\n\\\", MUNIT_OUTPUT_FILE);\\n\\n  if (stderr_buf != NULL) {\\n    if (result == MUNIT_FAIL || result == MUNIT_ERROR || runner->show_stderr) {\\n      fflush(MUNIT_OUTPUT_FILE);\\n\\n      rewind(stderr_buf);\\n      munit_splice(fileno(stderr_buf), STDERR_FILENO);\\n\\n      fflush(stderr);\\n    }\\n\\n    fclose(stderr_buf);\\n  }\\n}\\n\\nstatic void\\nmunit_test_runner_run_test_wild(MunitTestRunner* runner,\\n                                const MunitTest* test,\\n                                const char* test_name,\\n                                MunitParameter* params,\\n                                MunitParameter* p) {\\n  const MunitParameterEnum* pe;\\n  char** values;\\n  MunitParameter* next;\\n\\n  for (pe = test->parameters ; pe != NULL && pe->name != NULL ; pe++) {\\n    if (p->name == pe->name)\\n      break;\\n  }\\n\\n  if (pe == NULL)\\n    return;\\n\\n  for (values = pe->values ; *values != NULL ; values++) {\\n    next = p + 1;\\n    p->value = *values;\\n    if (next->name == NULL) {\\n      munit_test_runner_run_test_with_params(runner, test, params);\\n    } else {\\n      munit_test_runner_run_test_wild(runner, test, test_name, params, next);\\n    }\\n    if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n      break;\\n  }\\n}\\n\\n/* Run a single test, with every combination of parameters\\n * requested. */\\nstatic void\\nmunit_test_runner_run_test(MunitTestRunner* runner,\\n                           const MunitTest* test,\\n                           const char* prefix) {\\n  char* test_name = munit_maybe_concat(NULL, (char*) prefix, (char*) test->name);\\n  /* The array of parameters to pass to\\n   * munit_test_runner_run_test_with_params */\\n  MunitParameter* params = NULL;\\n  size_t params_l = 0;\\n  /* Wildcard parameters are parameters which have possible values\\n   * specified in the test, but no specific value was passed to the\\n   * CLI.  That means we want to run the test once for every\\n   * possible combination of parameter values or, if --single was\\n   * passed to the CLI, a single time with a random set of\\n   * parameters. */\\n  MunitParameter* wild_params = NULL;\\n  size_t wild_params_l = 0;\\n  const MunitParameterEnum* pe;\\n  const MunitParameter* cli_p;\\n  munit_bool filled;\\n  unsigned int possible;\\n  char** vals;\\n  size_t first_wild;\\n  const MunitParameter* wp;\\n  int pidx;\\n\\n  munit_rand_seed(runner->seed);\\n\\n  fprintf(MUNIT_OUTPUT_FILE, \\\"%-\\\" MUNIT_XSTRINGIFY(MUNIT_TEST_NAME_LEN) \\\"s\\\", test_name);\\n\\n  if (test->parameters == NULL) {\\n    /* No parameters.  Simple, nice. */\\n    munit_test_runner_run_test_with_params(runner, test, NULL);\\n  } else {\\n    fputc('\\\\n', MUNIT_OUTPUT_FILE);\\n\\n    for (pe = test->parameters ; pe != NULL && pe->name != NULL ; pe++) {\\n      /* Did we received a value for this parameter from the CLI? */\\n      filled = 0;\\n      for (cli_p = runner->parameters ; cli_p != NULL && cli_p->name != NULL ; cli_p++) {\\n        if (strcmp(cli_p->name, pe->name) == 0) {\\n          if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, cli_p->value) != MUNIT_OK))\\n            goto cleanup;\\n          filled = 1;\\n          break;\\n        }\\n      }\\n      if (filled)\\n        continue;\\n\\n      /* Nothing from CLI, is the enum NULL/empty?  We're not a\\n       * fuzzer\\u2026 */\\n      if (pe->values == NULL || pe->values[0] == NULL)\\n        continue;\\n\\n      /* If --single was passed to the CLI, choose a value from the\\n       * list of possibilities randomly. */\\n      if (runner->single_parameter_mode) {\\n        possible = 0;\\n        for (vals = pe->values ; *vals != NULL ; vals++)\\n          possible++;\\n        /* We want the tests to be reproducible, even if you're only\\n         * running a single test, but we don't want every test with\\n         * the same number of parameters to choose the same parameter\\n         * number, so use the test name as a primitive salt. */\\n        pidx = munit_rand_at_most(munit_str_hash(test_name), possible - 1);\\n        if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, pe->values[pidx]) != MUNIT_OK))\\n          goto cleanup;\\n      } else {\\n        /* We want to try every permutation.  Put in a placeholder\\n         * entry, we'll iterate through them later. */\\n        if (MUNIT_UNLIKELY(munit_parameters_add(&wild_params_l, &wild_params, pe->name, NULL) != MUNIT_OK))\\n          goto cleanup;\\n      }\\n    }\\n\\n    if (wild_params_l != 0) {\\n      first_wild = params_l;\\n      for (wp = wild_params ; wp != NULL && wp->name != NULL ; wp++) {\\n        for (pe = test->parameters ; pe != NULL && pe->name != NULL && pe->values != NULL ; pe++) {\\n          if (strcmp(wp->name, pe->name) == 0) {\\n            if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, pe->values[0]) != MUNIT_OK))\\n              goto cleanup;\\n          }\\n        }\\n      }\\n\\n      munit_test_runner_run_test_wild(runner, test, test_name, params, params + first_wild);\\n    } else {\\n      munit_test_runner_run_test_with_params(runner, test, params);\\n    }\\n\\n  cleanup:\\n    free(params);\\n    free(wild_params);\\n  }\\n\\n  munit_maybe_free_concat(test_name, prefix, test->name);\\n}\\n\\n/* Recurse through the suite and run all the tests.  If a list of\\n * tests to run was provied on the command line, run only those\\n * tests.  */\\nstatic void\\nmunit_test_runner_run_suite(MunitTestRunner* runner,\\n                            const MunitSuite* suite,\\n                            const char* prefix) {\\n  size_t pre_l;\\n  char* pre = munit_maybe_concat(&pre_l, (char*) prefix, (char*) suite->prefix);\\n  const MunitTest* test;\\n  const char** test_name;\\n  const MunitSuite* child_suite;\\n\\n  /* Run the tests. */\\n  for (test = suite->tests ; test != NULL && test->test != NULL ; test++) {\\n    if (runner->tests != NULL) { /* Specific tests were requested on the CLI */\\n      for (test_name = runner->tests ; test_name != NULL && *test_name != NULL ; test_name++) {\\n        if ((pre_l == 0 || strncmp(pre, *test_name, pre_l) == 0) &&\\n            strncmp(test->name, *test_name + pre_l, strlen(*test_name + pre_l)) == 0) {\\n          munit_test_runner_run_test(runner, test, pre);\\n          if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n            goto cleanup;\\n        }\\n      }\\n    } else { /* Run all tests */\\n      munit_test_runner_run_test(runner, test, pre);\\n    }\\n  }\\n\\n  if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n    goto cleanup;\\n\\n  /* Run any child suites. */\\n  for (child_suite = suite->suites ; child_suite != NULL && child_suite->prefix != NULL ; child_suite++) {\\n    munit_test_runner_run_suite(runner, child_suite, pre);\\n  }\\n\\n cleanup:\\n\\n  munit_maybe_free_concat(pre, prefix, suite->prefix);\\n}\\n\\nstatic void\\nmunit_test_runner_run(MunitTestRunner* runner) {\\n  munit_test_runner_run_suite(runner, runner->suite, NULL);\\n}\\n\\nstatic void\\nmunit_print_help(int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)], void* user_data, const MunitArgument arguments[]) {\\n  const MunitArgument* arg;\\n  (void) argc;\\n\\n  printf(\\\"USAGE: %s [OPTIONS...] [TEST...]\\\\n\\\\n\\\", argv[0]);\\n  puts(\\\" --seed SEED\\\\n\\\"\\n       \\\"           Value used to seed the PRNG.  Must be a 32-bit integer in decimal\\\\n\\\"\\n       \\\"           notation with no separators (commas, decimals, spaces, etc.), or\\\\n\\\"\\n       \\\"           hexidecimal prefixed by \\\\\\\"0x\\\\\\\".\\\\n\\\"\\n       \\\" --iterations N\\\\n\\\"\\n       \\\"           Run each test N times.  0 means the default number.\\\\n\\\"\\n       \\\" --param name value\\\\n\\\"\\n       \\\"           A parameter key/value pair which will be passed to any test with\\\\n\\\"\\n       \\\"           takes a parameter of that name.  If not provided, the test will be\\\\n\\\"\\n       \\\"           run once for each possible parameter value.\\\\n\\\"\\n       \\\" --list    Write a list of all available tests.\\\\n\\\"\\n       \\\" --list-params\\\\n\\\"\\n       \\\"           Write a list of all available tests and their possible parameters.\\\\n\\\"\\n       \\\" --single  Run each parameterized test in a single configuration instead of\\\\n\\\"\\n       \\\"           every possible combination\\\\n\\\"\\n       \\\" --log-visible debug|info|warning|error\\\\n\\\"\\n       \\\" --log-fatal debug|info|warning|error\\\\n\\\"\\n       \\\"           Set the level at which messages of different severities are visible,\\\\n\\\"\\n       \\\"           or cause the test to terminate.\\\\n\\\"\\n#if !defined(MUNIT_NO_FORK)\\n       \\\" --no-fork Do not execute tests in a child process.  If this option is supplied\\\\n\\\"\\n       \\\"           and a test crashes (including by failing an assertion), no further\\\\n\\\"\\n       \\\"           tests will be performed.\\\\n\\\"\\n#endif\\n       \\\" --fatal-failures\\\\n\\\"\\n       \\\"           Stop executing tests as soon as a failure is found.\\\\n\\\"\\n       \\\" --show-stderr\\\\n\\\"\\n       \\\"           Show data written to stderr by the tests, even if the test succeeds.\\\\n\\\"\\n       \\\" --color auto|always|never\\\\n\\\"\\n       \\\"           Colorize (or don't) the output.\\\\n\\\"\\n     /* 12345678901234567890123456789012345678901234567890123456789012345678901234567890 */\\n       \\\" --help    Print this help message and exit.\\\\n\\\");\\n#if defined(MUNIT_NL_LANGINFO)\\n  setlocale(LC_ALL, \\\"\\\");\\n  fputs((strcasecmp(\\\"UTF-8\\\", nl_langinfo(CODESET)) == 0) ? \\\"\\u00b5nit\\\" : \\\"munit\\\", stdout);\\n#else\\n  puts(\\\"munit\\\");\\n#endif\\n  printf(\\\" %d.%d.%d\\\\n\\\"\\n         \\\"Full documentation at: https://nemequ.github.io/munit/\\\\n\\\",\\n         (MUNIT_CURRENT_VERSION >> 16) & 0xff,\\n         (MUNIT_CURRENT_VERSION >> 8) & 0xff,\\n         (MUNIT_CURRENT_VERSION >> 0) & 0xff);\\n  for (arg = arguments ; arg != NULL && arg->name != NULL ; arg++)\\n    arg->write_help(arg, user_data);\\n}\\n\\nstatic const MunitArgument*\\nmunit_arguments_find(const MunitArgument arguments[], const char* name) {\\n  const MunitArgument* arg;\\n\\n  for (arg = arguments ; arg != NULL && arg->name != NULL ; arg++)\\n    if (strcmp(arg->name, name) == 0)\\n      return arg;\\n\\n  return NULL;\\n}\\n\\nstatic void\\nmunit_suite_list_tests(const MunitSuite* suite, munit_bool show_params, const char* prefix) {\\n  size_t pre_l;\\n  char* pre = munit_maybe_concat(&pre_l, (char*) prefix, (char*) suite->prefix);\\n  const MunitTest* test;\\n  const MunitParameterEnum* params;\\n  munit_bool first;\\n  char** val;\\n  const MunitSuite* child_suite;\\n\\n  for (test = suite->tests ;\\n       test != NULL && test->name != NULL ;\\n       test++) {\\n    if (pre != NULL)\\n      fputs(pre, stdout);\\n    puts(test->name);\\n\\n    if (show_params) {\\n      for (params = test->parameters ;\\n           params != NULL && params->name != NULL ;\\n           params++) {\\n        fprintf(stdout, \\\" - %s: \\\", params->name);\\n        if (params->values == NULL) {\\n          puts(\\\"Any\\\");\\n        } else {\\n          first = 1;\\n          for (val = params->values ;\\n               *val != NULL ;\\n               val++ ) {\\n            if(!first) {\\n              fputs(\\\", \\\", stdout);\\n            } else {\\n              first = 0;\\n            }\\n            fputs(*val, stdout);\\n          }\\n          putc('\\\\n', stdout);\\n        }\\n      }\\n    }\\n  }\\n\\n  for (child_suite = suite->suites ; child_suite != NULL && child_suite->prefix != NULL ; child_suite++) {\\n    munit_suite_list_tests(child_suite, show_params, pre);\\n  }\\n\\n  munit_maybe_free_concat(pre, prefix, suite->prefix);\\n}\\n\\nstatic munit_bool\\nmunit_stream_supports_ansi(FILE *stream) {\\n#if !defined(_WIN32)\\n  return isatty(fileno(stream));\\n#else\\n\\n#if !defined(__MINGW32__)\\n  size_t ansicon_size = 0;\\n#endif\\n\\n  if (isatty(fileno(stream))) {\\n#if !defined(__MINGW32__)\\n    getenv_s(&ansicon_size, NULL, 0, \\\"ANSICON\\\");\\n    return ansicon_size != 0;\\n#else\\n    return getenv(\\\"ANSICON\\\") != NULL;\\n#endif\\n  }\\n  return 0;\\n#endif\\n}\\n\\nint\\nmunit_suite_main_custom(const MunitSuite* suite, void* user_data,\\n                        int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)],\\n                        const MunitArgument arguments[]) {\\n  int result = EXIT_FAILURE;\\n  MunitTestRunner runner;\\n  size_t parameters_size = 0;\\n  size_t tests_size = 0;\\n  int arg;\\n\\n  char* envptr;\\n  unsigned long ts;\\n  char* endptr;\\n  unsigned long long iterations;\\n  MunitLogLevel level;\\n  const MunitArgument* argument;\\n  const char** runner_tests;\\n  unsigned int tests_run;\\n  unsigned int tests_total;\\n\\n  runner.prefix = NULL;\\n  runner.suite = NULL;\\n  runner.tests = NULL;\\n  runner.seed = 0;\\n  runner.iterations = 0;\\n  runner.parameters = NULL;\\n  runner.single_parameter_mode = 0;\\n  runner.user_data = NULL;\\n\\n  runner.report.successful = 0;\\n  runner.report.skipped = 0;\\n  runner.report.failed = 0;\\n  runner.report.errored = 0;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  runner.report.cpu_clock = 0;\\n  runner.report.wall_clock = 0;\\n#endif\\n\\n  runner.colorize = 0;\\n#if !defined(_WIN32)\\n  runner.fork = 1;\\n#else\\n  runner.fork = 0;\\n#endif\\n  runner.show_stderr = 0;\\n  runner.fatal_failures = 0;\\n  runner.suite = suite;\\n  runner.user_data = user_data;\\n  runner.seed = munit_rand_generate_seed();\\n  runner.colorize = munit_stream_supports_ansi(MUNIT_OUTPUT_FILE);\\n\\n  for (arg = 1 ; arg < argc ; arg++) {\\n    if (strncmp(\\\"--\\\", argv[arg], 2) == 0) {\\n      if (strcmp(\\\"seed\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        envptr = argv[arg + 1];\\n        ts = strtoul(argv[arg + 1], &envptr, 0);\\n        if (*envptr != '\\\\0' || ts > (~((munit_uint32_t) 0U))) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n        runner.seed = (munit_uint32_t) ts;\\n\\n        arg++;\\n      } else if (strcmp(\\\"iterations\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        endptr = argv[arg + 1];\\n        iterations = strtoul(argv[arg + 1], &endptr, 0);\\n        if (*endptr != '\\\\0' || iterations > UINT_MAX) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        runner.iterations = (unsigned int) iterations;\\n\\n        arg++;\\n      } else if (strcmp(\\\"param\\\", argv[arg] + 2) == 0) {\\n        if (arg + 2 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires two arguments\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        runner.parameters = realloc(runner.parameters, sizeof(MunitParameter) * (parameters_size + 2));\\n        if (runner.parameters == NULL) {\\n          munit_log_internal(MUNIT_LOG_ERROR, stderr, \\\"failed to allocate memory\\\");\\n          goto cleanup;\\n        }\\n        runner.parameters[parameters_size].name = (char*) argv[arg + 1];\\n        runner.parameters[parameters_size].value = (char*) argv[arg + 2];\\n        parameters_size++;\\n        runner.parameters[parameters_size].name = NULL;\\n        runner.parameters[parameters_size].value = NULL;\\n        arg += 2;\\n      } else if (strcmp(\\\"color\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(argv[arg + 1], \\\"always\\\") == 0)\\n          runner.colorize = 1;\\n        else if (strcmp(argv[arg + 1], \\\"never\\\") == 0)\\n          runner.colorize = 0;\\n        else if (strcmp(argv[arg + 1], \\\"auto\\\") == 0)\\n          runner.colorize = munit_stream_supports_ansi(MUNIT_OUTPUT_FILE);\\n        else {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        arg++;\\n      } else if (strcmp(\\\"help\\\", argv[arg] + 2) == 0) {\\n        munit_print_help(argc, argv, user_data, arguments);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else if (strcmp(\\\"single\\\", argv[arg] + 2) == 0) {\\n        runner.single_parameter_mode = 1;\\n      } else if (strcmp(\\\"show-stderr\\\", argv[arg] + 2) == 0) {\\n        runner.show_stderr = 1;\\n#if !defined(_WIN32)\\n      } else if (strcmp(\\\"no-fork\\\", argv[arg] + 2) == 0) {\\n        runner.fork = 0;\\n#endif\\n      } else if (strcmp(\\\"fatal-failures\\\", argv[arg] + 2) == 0) {\\n        runner.fatal_failures = 1;\\n      } else if (strcmp(\\\"log-visible\\\", argv[arg] + 2) == 0 ||\\n                 strcmp(\\\"log-fatal\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(argv[arg + 1], \\\"debug\\\") == 0)\\n          level = MUNIT_LOG_DEBUG;\\n        else if (strcmp(argv[arg + 1], \\\"info\\\") == 0)\\n          level = MUNIT_LOG_INFO;\\n        else if (strcmp(argv[arg + 1], \\\"warning\\\") == 0)\\n          level = MUNIT_LOG_WARNING;\\n        else if (strcmp(argv[arg + 1], \\\"error\\\") == 0)\\n          level = MUNIT_LOG_ERROR;\\n        else {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(\\\"log-visible\\\", argv[arg] + 2) == 0)\\n          munit_log_level_visible = level;\\n        else\\n          munit_log_level_fatal = level;\\n\\n        arg++;\\n      } else if (strcmp(\\\"list\\\", argv[arg] + 2) == 0) {\\n        munit_suite_list_tests(suite, 0, NULL);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else if (strcmp(\\\"list-params\\\", argv[arg] + 2) == 0) {\\n        munit_suite_list_tests(suite, 1, NULL);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else {\\n        argument = munit_arguments_find(arguments, argv[arg] + 2);\\n        if (argument == NULL) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"unknown argument ('%s')\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (!argument->parse_argument(suite, user_data, &arg, argc, argv))\\n          goto cleanup;\\n      }\\n    } else {\\n      runner_tests = realloc((void*) runner.tests, sizeof(char*) * (tests_size + 2));\\n      if (runner_tests == NULL) {\\n        munit_log_internal(MUNIT_LOG_ERROR, stderr, \\\"failed to allocate memory\\\");\\n        goto cleanup;\\n      }\\n      runner.tests = runner_tests;\\n      runner.tests[tests_size++] = argv[arg];\\n      runner.tests[tests_size] = NULL;\\n    }\\n  }\\n\\n  fflush(stderr);\\n  fprintf(MUNIT_OUTPUT_FILE, \\\"Running test suite with seed 0x%08\\\" PRIx32 \\\"...\\\\n\\\", runner.seed);\\n\\n  munit_test_runner_run(&runner);\\n\\n  tests_run = runner.report.successful + runner.report.failed + runner.report.errored;\\n  tests_total = tests_run + runner.report.skipped;\\n  if (tests_run == 0) {\\n    fprintf(stderr, \\\"No tests run, %d (100%%) skipped.\\\\n\\\", runner.report.skipped);\\n  } else {\\n    fprintf(MUNIT_OUTPUT_FILE, \\\"%d of %d (%0.0f%%) tests successful, %d (%0.0f%%) test skipped.\\\\n\\\",\\n            runner.report.successful, tests_run,\\n            (((double) runner.report.successful) / ((double) tests_run)) * 100.0,\\n            runner.report.skipped,\\n            (((double) runner.report.skipped) / ((double) tests_total)) * 100.0);\\n  }\\n\\n  if (runner.report.failed == 0 && runner.report.errored == 0) {\\n    result = EXIT_SUCCESS;\\n  }\\n\\n cleanup:\\n  free(runner.parameters);\\n  free((void*) runner.tests);\\n\\n  return result;\\n}\\n\\nint\\nmunit_suite_main(const MunitSuite* suite, void* user_data,\\n                 int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)]) {\\n  return munit_suite_main_custom(suite, user_data, argc, argv, NULL);\\n}\\n\", \"embeddings\": [-0.02607397735118866, 0.08344140648841858, 0.05948583781719208, 0.03592880070209503, 0.40621429681777954, -0.17045074701309204, 0.1341419816017151, 0.23127061128616333, 0.03809036314487457, -0.271656334400177, 0.10892608761787415, -0.09000315517187119, 0.06896669417619705, 0.016749437898397446, 0.05032598227262497, 0.08542798459529877, 0.021605081856250763, -0.05172739177942276, 0.06322038173675537, -0.3308308720588684, -0.15785203874111176, 0.04758419096469879, 0.19845813512802124, 0.08991829305887222, 0.18929360806941986, 0.07123209536075592, 0.23251740634441376, 0.0747336745262146, 0.45851218700408936, -0.09316231310367584, 0.013130076229572296, -0.08659841865301132, 0.09560884535312653, -0.16281336545944214, -0.028582263737916946, 0.005980234593153, -0.04470352083444595, 0.07958798855543137, 0.02949359267950058, -0.007252831012010574, -0.16168463230133057, 0.08177188783884048, 0.04075419530272484, 0.13595451414585114, 0.16310101747512817, -0.045125626027584076, 0.09959670901298523, 0.23174986243247986, -0.09448681771755219, 0.008603639900684357, 0.11679999530315399, -0.05073266848921776, 0.04168739169836044, -0.02021334320306778, -0.15454648435115814, 0.01507776789367199, -0.021045759320259094, 0.3594089150428772, -0.025525890290737152, -0.0616036131978035, -0.10666400194168091, -0.18846751749515533, -0.1780955195426941, 0.12623891234397888, 0.05311575531959534, 0.057219911366701126, -0.08603329956531525, -0.27200454473495483, 0.022990882396697998, 0.006724361330270767, 0.08831938356161118, 0.08976804465055466, 0.13274377584457397, -0.14104494452476501, -0.1856568157672882, -0.030962124466896057, 0.05551673099398613, 0.41317257285118103, -0.028894728049635887, 0.09435699135065079, 0.132438063621521, -0.0723520815372467, 0.168630450963974, 0.24636587500572205, 0.16245239973068237, 0.033114202320575714, -0.0600636824965477, 0.1311495006084442, -0.05565285682678223, 0.10152587294578552, 0.0785393938422203, 0.06627702713012695, -0.11058618873357773, -0.024353858083486557, -0.050876863300800323, -0.05085219070315361, 0.1483469307422638, -0.09151582419872284, 0.0955723449587822, 0.3482295870780945, -0.08627559244632721, -0.0994490385055542, -0.21570026874542236, 0.008109282702207565, 0.01660524308681488, -0.03111240640282631, -0.05486254394054413, 0.03597281500697136, 0.17547500133514404, -0.028844624757766724, 0.08525976538658142, -0.0315340980887413, -0.02860369347035885, 0.03452269732952118, 0.09133964031934738, -0.13551023602485657, 0.042755670845508575, 0.012090124189853668, 0.17413672804832458, -0.059151701629161835, 0.11055564135313034, 0.022791169583797455, 0.029315203428268433, -0.11721068620681763, -0.12996961176395416, 0.10558262467384338, 0.030028991401195526, -0.28574106097221375, 0.1410529613494873, 0.06118730455636978, -0.006577692925930023, -0.17197945713996887, -0.031900472939014435, -0.005178444087505341, 0.10889715701341629, -0.007594555616378784, 0.043585263192653656, -0.021016426384449005, 0.0030826926231384277, 0.014231130480766296, -0.031473733484745026, 0.026396363973617554, 0.3158768117427826, -0.037282366305589676, 0.21121063828468323, -0.08032795786857605, 0.14844587445259094, 0.14284400641918182, -0.40540263056755066, -0.15647713840007782, 0.08000122755765915, -0.06395300477743149, 0.003779758233577013, 0.007290638983249664, -0.15211020410060883, 0.6653910279273987, 0.23298406600952148, -0.2149554193019867, 0.09245657920837402, 0.06596994400024414, 0.02291799709200859, -0.2658012807369232, -0.025105170905590057, 0.16159150004386902, 0.11469337344169617, 0.11834195256233215, -0.03319591283798218, 0.0523805133998394, 0.12533199787139893, 0.0012638270854949951, 0.08825992792844772, -0.09211155772209167, -0.012652997858822346, 0.11526745557785034, 0.032003253698349, -0.13784343004226685, -0.1731204241514206, 0.06331869959831238, -0.022846903651952744, -0.021736539900302887, -0.10805320739746094, -0.0033722221851348877, -0.11290809512138367, 0.023036357015371323, -0.0891147330403328, -0.06333479285240173, 0.06379963457584381, -0.10830284655094147, 0.10119397193193436, 0.06876885145902634, 0.03330691158771515, 0.013923176564276218, 0.17708733677864075, -0.0307176411151886, 0.02146819233894348, 0.09929906576871872, -0.06677187234163284, -0.06000500172376633, 0.22705215215682983, -0.01655692607164383, -0.04464714229106903, -0.12669232487678528, 0.18700551986694336, -0.020504262298345566, 0.08582732826471329, 0.10834347456693649, -0.16420279443264008, -0.03110107034444809, -0.09470728039741516, -0.11906241625547409, -0.047533068805933, 0.16501086950302124, 0.1667078733444214, 0.017822986468672752, -0.019598983228206635, -0.16217048466205597, 0.15655511617660522, 0.09871290624141693, 0.010550199076533318, -0.09039538353681564, 0.07213369756937027, 0.12492555379867554, -0.1116509810090065, -0.06088662147521973, -0.052668988704681396, 0.12036488950252533, 0.18554890155792236, 0.1359359323978424, -0.01768854632973671, 0.07609593868255615, 0.11537350714206696, 0.1893155872821808, -0.1384023129940033, 0.17777909338474274, 0.01836143061518669, -0.03370149806141853, -0.04979526996612549, 0.013506285846233368, 0.05288076400756836, -0.07150457799434662, 0.05959071218967438, 0.12745332717895508, 0.22106707096099854, 0.266740083694458, 0.05656037479639053, -0.047382794320583344, -0.07503515481948853, -0.15014736354351044, -0.09750901907682419, 0.09550328552722931, 0.007112843915820122, -0.08497631549835205, 0.09354671835899353, -0.05452755466103554, -0.07983255386352539, -0.07246547937393188, -0.13740794360637665, -0.02134174481034279, 0.0343608483672142, 0.2887921631336212, -0.08446352928876877, 0.04451386630535126, 0.0776924416422844, -0.031456656754016876, -0.05915870890021324, -0.4145522117614746, -0.13009876012802124, 0.11537215113639832, 0.05617906153202057, -0.06586654484272003, 0.18576902151107788, -0.022087063640356064, 0.2573527693748474, 0.15853270888328552, 0.00548432394862175, -0.04274643957614899, -0.10265028476715088, -0.04894602671265602, -0.11624643206596375, 0.05859382823109627, -0.014993790537118912, 0.17655473947525024, -0.2257619947195053, 0.09421095252037048, 0.011254698038101196, 0.004040625412017107, 0.1636064648628235, -0.03909175843000412, 0.060829345136880875, 0.01970810443162918, -0.0748027116060257, 0.03489839285612106, 0.1034928634762764, 0.15668074786663055, 0.07801251113414764, 0.0824003741145134, 0.10932381451129913, 0.14068485796451569, 0.07518963515758514, -0.3690807819366455, 0.071388840675354, -0.17496152222156525, 0.14502476155757904, -0.14087983965873718, 0.3869771361351013, 0.043898507952690125, -0.0871211364865303, 0.024147000163793564, 0.19104745984077454, -0.021526996046304703, 0.10180801153182983, 0.061110008507966995, -0.09424084424972534, 0.15205137431621552, -0.11361771821975708, 0.06593786180019379, -0.009706465527415276, -0.0777161717414856, 0.09169670194387436, -0.03775596618652344, 0.015470091253519058, 0.2052934169769287, 0.11202666163444519, 0.12334045767784119, -0.02533385530114174, -0.029402732849121094, 0.09996989369392395, 0.011707779951393604, -0.2017715871334076, 0.5300753116607666, -0.6134535670280457, 0.14131610095500946, -0.14772702753543854, 0.37441980838775635, -0.08311337232589722, 0.3734937906265259, -0.06867241114377975, 0.11305461078882217, 0.04099348187446594, 0.154298797249794, -0.14313280582427979, -0.12860514223575592, -0.13029587268829346, 0.3278656005859375, 0.03684468939900398, 0.20431748032569885, 0.22753483057022095, -0.0388110987842083, 0.15450209379196167, -0.015852784737944603, -0.190095454454422, 0.2077084183692932, 0.0035714618861675262, -0.1371246725320816, 0.018155276775360107, 0.3884161412715912, -0.1403602659702301, -0.043234411627054214, -0.019828569144010544, -0.01783376932144165, 0.0629701241850853, -0.16645056009292603, 0.20367032289505005, -0.12297286838293076, 0.2213495373725891, -0.3966776728630066, -0.3825618028640747, -0.011350788176059723, -0.18705904483795166, 0.1306770294904709, 0.10483348369598389, 0.16455134749412537, 0.1459486037492752, -0.2683350443840027, 0.10189381241798401, -0.052080702036619186, -0.1280289888381958, -0.019175268709659576, 0.017696991562843323, 0.1766439974308014, 0.01985493302345276, 0.06882349401712418, 0.13189414143562317, -0.02686314657330513, 0.0260281041264534, -0.13928520679473877, 0.26146313548088074, 0.1365576684474945, 0.26089993119239807, -0.045431870967149734, 0.08239196240901947, -0.14064958691596985, 0.0849173367023468, 0.019609857350587845, 0.031756848096847534, 0.03052150458097458, 0.008117945864796638, 0.10601930320262909, -0.0894385501742363, -0.1819077432155609, 0.18080855906009674, 0.2937481999397278, -0.05174629017710686, 0.09590426087379456, 0.0631212592124939, 0.042216818779706955, 0.1047884151339531, -0.1930588036775589, -0.0637793019413948, -0.1542365550994873, 0.03322741016745567, 0.0006408169865608215, 0.05056597292423248, -0.02782171219587326, 0.2147578001022339, -0.06680598109960556, -0.06541913747787476, -0.2994783818721771, -0.13412830233573914, 0.10048902779817581, 0.12699897587299347, 0.09439973533153534, 0.05853690952062607, -0.1399327516555786, -0.07725296169519424, 0.051512211561203, 0.031555794179439545, -0.08326949179172516, 0.04171958193182945, -0.1866312325000763, -0.02315603196620941, 0.2208864837884903, 0.04107772931456566, 0.09970827400684357, 0.0653153508901596, -0.06194184720516205, -0.13591359555721283, -0.04681772366166115, 0.08550212532281876, 0.039909325540065765, -0.09720288217067719, 0.05789222568273544, 0.12331565469503403, -0.004302710294723511, -0.02506081387400627, -0.1599929928779602, 0.3878385126590729, 0.13914498686790466, -0.11641667783260345, 0.1611335575580597, -0.15975776314735413, 0.03346436470746994, -0.048003677278757095, -0.2122633159160614, 0.10985803604125977, 0.2562066614627838, 0.02058285102248192, 0.032625824213027954, 0.09802797436714172, -0.00520053505897522, 0.10637691617012024, 0.13407711684703827, -0.11147017776966095, -0.10213752835988998, 0.035091131925582886, -0.01774068921804428, 0.07460655272006989, 0.05346713960170746, 0.19063840806484222, 0.1703285276889801, 0.13942833244800568, 0.1882506012916565, 0.003053121268749237, -0.17391487956047058, -0.00323578342795372, -0.03576386719942093, 0.0006356968078762293, -0.24956737458705902, 0.08575780689716339, -0.16102002561092377, -0.032226234674453735, 0.13258546590805054, 0.1621600091457367, 0.04704900085926056, 0.0034653209149837494, -0.058285512030124664, 0.11469371616840363, 0.10117211192846298, -0.15675599873065948, -0.02041567489504814, -0.10375849902629852, 0.14054656028747559, -0.04366125538945198, 0.1985529363155365, 0.26744818687438965, 0.16066604852676392, 0.023609593510627747, 0.08443810790777206, 0.4135498106479645, -0.07563045620918274, 0.011091895401477814, 0.026142176240682602, 0.03877219930291176, -0.015223417431116104, -0.14008891582489014, -0.11565717309713364, 0.07374168187379837, 0.10449571907520294, 0.20876841247081757, -0.22822058200836182, -0.012756440788507462, -0.21169152855873108, 0.1299421340227127, 0.012221235781908035, -0.012754864990711212, 0.04935694858431816, -0.05118584632873535, 0.09859923273324966, -0.029058441519737244, 0.20997050404548645, -0.06950577348470688, -0.08148729801177979, -0.018912415951490402, 0.0023455116897821426, -0.10655494779348373, 0.01650957204401493, 0.18437185883522034, 0.034876737743616104, 0.042366474866867065, -0.012788001447916031, 0.15137851238250732, 0.005854178220033646, 0.09234560281038284, 0.20320290327072144, -0.050781045109033585, 0.015146380290389061, 0.04518982768058777, -0.04417473077774048, 0.28308507800102234, 0.04232883080840111, -0.29498720169067383, 0.10218355059623718, 0.23820318281650543, -0.13861703872680664, 0.053922489285469055, 0.02389088086783886, 0.10386313498020172, -0.003664657473564148, 0.012840738520026207, -0.049333080649375916, 9.684637188911438e-05, -0.658965528011322, -0.03908418491482735, 0.19519582390785217, -0.001580599695444107, 0.050991252064704895, 0.0868995264172554, 0.1378389596939087, 0.029783787205815315, 0.05062401294708252, 0.13665610551834106, 0.11836972832679749, 0.1450604796409607, 0.1519164890050888, -0.1446453481912613, -0.10314778983592987, 0.11517073959112167, 0.06251263618469238, -0.1921072155237198, 0.11070354282855988, 0.16992004215717316, -0.10827998071908951, 0.06252095103263855, 0.37266331911087036, 0.013011999428272247, 0.03191030025482178, 0.23272570967674255, -0.013315986841917038, 0.3173622488975525, -0.01966273784637451, 0.03419782966375351, 0.28373295068740845, 0.18094873428344727, -0.24651290476322174, 0.022513512521982193, 0.09997433423995972, 0.3547184467315674, 0.029822271317243576, 13.583736419677734, 0.00754187535494566, 0.18308201432228088, -0.18051022291183472, -0.048205263912677765, -0.06236317753791809, -0.040225572884082794, 0.10158328711986542, -0.017683804035186768, -0.047786861658096313, 0.2352302372455597, -0.039398618042469025, 0.09598157554864883, 0.026855027303099632, -0.0684625655412674, -0.05305124819278717, -0.0740482360124588, -0.06710096448659897, 0.26176419854164124, 0.02171320468187332, -0.13801215589046478, -0.16039250791072845, -0.050391241908073425, -0.47864094376564026, -0.0746774822473526, 0.037697575986385345, 0.25256475806236267, 0.17147739231586456, 0.0021336544305086136, -0.07023492455482483, -0.04978429526090622, 0.16619476675987244, 0.006104178726673126, -0.09371022880077362, 0.15520739555358887, -0.13422876596450806, -0.40814733505249023, -0.05508246645331383, 0.10982388257980347, 0.07261032611131668, -0.019208870828151703, -0.059954360127449036, 0.12729142606258392, 0.0304267480969429, 0.08586746454238892, 0.09120558947324753, -0.15936674177646637, 0.14284780621528625, -0.1311497986316681, 0.01601056382060051, 0.1885518878698349, 0.16720569133758545, 0.3445475101470947, -0.01734783872961998, -0.19542643427848816, -0.28594496846199036, 0.28022080659866333, -0.007778681814670563, -0.10894741117954254, 0.34462109208106995, -0.07635106146335602, -0.10402103513479233, 0.04270416870713234, 0.019097639247775078, -0.017646748572587967, 0.05497347190976143, 0.13729918003082275, 0.08672069013118744, -0.06364467740058899, 0.1341741979122162, 0.3318408131599426, -0.14986538887023926, 0.1491629183292389, 0.058771368116140366, 0.05773952603340149, 0.07356306910514832, -0.05810634046792984, -0.08801020681858063, 0.06148381903767586, -0.1325860321521759, -0.011165261268615723, 0.06718526780605316, -0.2575477063655853, -0.06860388070344925, -0.2132498174905777, 0.11266610771417618, -0.1498393565416336, 0.2026064693927765, 0.26882871985435486, -0.046292997896671295, -0.058490555733442307, -0.08689458668231964, 0.03672034665942192, -0.23364481329917908, 0.23218464851379395, 0.0015713199973106384, -0.10229150950908661, -0.08807457983493805, 0.11482996493577957, 0.13057240843772888, -0.04053252190351486, -0.08906526863574982, -0.017813056707382202, 0.02584514021873474, -0.15569458901882172, 0.013936653733253479, 0.021201670169830322, 0.050677914172410965, -0.019282232969999313, 0.09413598477840424, -0.007052566856145859, 0.0787392258644104, 0.13483980298042297, -0.25096267461776733, -0.038332171738147736, -0.034644100815057755, 0.03811093047261238, -0.06859894096851349, 0.22143784165382385, 0.07511664927005768, 0.12627653777599335, 0.15131884813308716, -0.1567174345254898, -0.07110661268234253, 0.06301547586917877, -0.1874794065952301, 0.12942126393318176, 0.20070841908454895, 0.010411856696009636, 0.036263324320316315, -0.048058945685625076, -0.06707815080881119, 0.3821476995944977, 0.14223089814186096, 0.07118158787488937, -0.09481540322303772, 0.004628144204616547, -0.005253933370113373, 0.18071210384368896, 0.18061882257461548, 0.043023306876420975, 0.06075816601514816, 0.2361256629228592, -0.0911058709025383, -0.07084164768457413, 0.2985117733478546, 0.13762128353118896, -0.10726030170917511, -0.15598414838314056, 0.0563226044178009, 0.07810189574956894, 0.23132915794849396, -0.12592065334320068, -0.05905790627002716, -0.0841778963804245, -0.1490219533443451, -0.21607248485088348, -0.0437454991042614, -0.11803882569074631, 0.04272438585758209, 0.0006550252437591553, -0.24185848236083984, 0.15165413916110992, -0.3099164366722107, -0.04196377098560333, 0.060707755386829376, 0.01892520673573017, 0.12487274408340454, 0.07136844843626022, -0.0823839083313942, 0.05521247163414955, 0.019773129373788834, -0.21621204912662506, -0.09562678635120392, -0.109092578291893, 0.08184191584587097, 0.19893698394298553, -0.33701956272125244, -0.1851000189781189, 0.08412113040685654]}"
"{\"sha\": \"00ede07ca6c77e3b71aaa699b2c48b9718700cc8\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"test/unit/munit.c\", \"func_name\": \"munit_clock_get_elapsed\", \"original_string\": \"static psnip_uint64_t\\nmunit_clock_get_elapsed(struct PsnipClockTimespec* start, struct PsnipClockTimespec* end) {\\n  psnip_uint64_t r = (end->seconds - start->seconds) * PSNIP_CLOCK_NSEC_PER_SEC;\\n  if (end->nanoseconds < start->nanoseconds) {\\n    r -= (start->nanoseconds - end->nanoseconds);\\n  } else {\\n    r += (end->nanoseconds - start->nanoseconds);\\n  }\\n  return r;\\n}\", \"code_tokens\": [\"static\", \"psnip_uint64_t\", \"munit_clock_get_elapsed\", \"(\", \"struct\", \"PsnipClockTimespec\", \"*\", \"start\", \",\", \"struct\", \"PsnipClockTimespec\", \"*\", \"end\", \")\", \"{\", \"psnip_uint64_t\", \"r\", \"=\", \"(\", \"end\", \"->\", \"seconds\", \"-\", \"start\", \"->\", \"seconds\", \")\", \"*\", \"PSNIP_CLOCK_NSEC_PER_SEC\", \";\", \"if\", \"(\", \"end\", \"->\", \"nanoseconds\", \"<\", \"start\", \"->\", \"nanoseconds\", \")\", \"{\", \"r\", \"-=\", \"(\", \"start\", \"->\", \"nanoseconds\", \"-\", \"end\", \"->\", \"nanoseconds\", \")\", \";\", \"}\", \"else\", \"{\", \"r\", \"+=\", \"(\", \"end\", \"->\", \"nanoseconds\", \"-\", \"start\", \"->\", \"nanoseconds\", \")\", \";\", \"}\", \"return\", \"r\", \";\", \"}\"], \"docstring\": \"/* !defined(PSNIP_CLOCK_H) */\", \"docstring_tokens\": [\"/\", \"*\", \"!defined\", \"(\", \"PSNIP_CLOCK_H\", \")\", \"*\", \"/\"], \"raw_contents\": \"/* Copyright (c) 2013-2018 Evan Nemerson <evan@nemerson.com>\\n *\\n * Permission is hereby granted, free of charge, to any person\\n * obtaining a copy of this software and associated documentation\\n * files (the \\\"Software\\\"), to deal in the Software without\\n * restriction, including without limitation the rights to use, copy,\\n * modify, merge, publish, distribute, sublicense, and/or sell copies\\n * of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be\\n * included in all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND,\\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n * SOFTWARE.\\n */\\n\\n/*** Configuration ***/\\n\\n/* This is just where the output from the test goes.  It's really just\\n * meant to let you choose stdout or stderr, but if anyone really want\\n * to direct it to a file let me know, it would be fairly easy to\\n * support. */\\n#if !defined(MUNIT_OUTPUT_FILE)\\n#  define MUNIT_OUTPUT_FILE stdout\\n#endif\\n\\n/* This is a bit more useful; it tells \\u00b5nit how to format the seconds in\\n * timed tests.  If your tests run for longer you might want to reduce\\n * it, and if your computer is really fast and your tests are tiny you\\n * can increase it. */\\n#if !defined(MUNIT_TEST_TIME_FORMAT)\\n#  define MUNIT_TEST_TIME_FORMAT \\\"0.8f\\\"\\n#endif\\n\\n/* If you have long test names you might want to consider bumping\\n * this.  The result information takes 43 characters. */\\n#if !defined(MUNIT_TEST_NAME_LEN)\\n#  define MUNIT_TEST_NAME_LEN 37\\n#endif\\n\\n/* If you don't like the timing information, you can disable it by\\n * defining MUNIT_DISABLE_TIMING. */\\n#if !defined(MUNIT_DISABLE_TIMING)\\n#  define MUNIT_ENABLE_TIMING\\n#endif\\n\\n/*** End configuration ***/\\n\\n#if defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE < 200809L)\\n#  undef _POSIX_C_SOURCE\\n#endif\\n#if !defined(_POSIX_C_SOURCE)\\n#  define _POSIX_C_SOURCE 200809L\\n#endif\\n\\n/* Solaris freaks out if you try to use a POSIX or SUS standard without\\n * the \\\"right\\\" C standard. */\\n#if defined(_XOPEN_SOURCE)\\n#  undef _XOPEN_SOURCE\\n#endif\\n\\n#if defined(__STDC_VERSION__)\\n#  if __STDC_VERSION__ >= 201112L\\n#    define _XOPEN_SOURCE 700\\n#  elif __STDC_VERSION__ >= 199901L\\n#    define _XOPEN_SOURCE 600\\n#  endif\\n#endif\\n\\n/* Because, according to Microsoft, POSIX is deprecated.  You've got\\n * to appreciate the chutzpah. */\\n#if defined(_MSC_VER) && !defined(_CRT_NONSTDC_NO_DEPRECATE)\\n#  define _CRT_NONSTDC_NO_DEPRECATE\\n#endif\\n\\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\\n#  include <stdbool.h>\\n#elif defined(_WIN32)\\n/* https://msdn.microsoft.com/en-us/library/tf4dy80a.aspx */\\n#endif\\n\\n#include <limits.h>\\n#include <time.h>\\n#include <errno.h>\\n#include <string.h>\\n#include <stdlib.h>\\n#include <stdio.h>\\n#include <stdarg.h>\\n#include <setjmp.h>\\n\\n#if !defined(MUNIT_NO_NL_LANGINFO) && !defined(_WIN32)\\n#define MUNIT_NL_LANGINFO\\n#include <locale.h>\\n#include <langinfo.h>\\n#include <strings.h>\\n#endif\\n\\n#if !defined(_WIN32)\\n#  include <unistd.h>\\n#  include <sys/types.h>\\n#  include <sys/wait.h>\\n#else\\n#  include <windows.h>\\n#  include <io.h>\\n#  include <fcntl.h>\\n#  if !defined(STDERR_FILENO)\\n#    define STDERR_FILENO _fileno(stderr)\\n#  endif\\n#endif\\n\\n#include \\\"munit.h\\\"\\n\\n#define MUNIT_STRINGIFY(x) #x\\n#define MUNIT_XSTRINGIFY(x) MUNIT_STRINGIFY(x)\\n\\n#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__SUNPRO_CC) || defined(__IBMCPP__)\\n#  define MUNIT_THREAD_LOCAL __thread\\n#elif (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201102L)) || defined(_Thread_local)\\n#  define MUNIT_THREAD_LOCAL _Thread_local\\n#elif defined(_WIN32)\\n#  define MUNIT_THREAD_LOCAL __declspec(thread)\\n#endif\\n\\n/* MSVC 12.0 will emit a warning at /W4 for code like 'do { ... }\\n * while (0)', or 'do { ... } while (1)'.  I'm pretty sure nobody\\n * at Microsoft compiles with /W4. */\\n#if defined(_MSC_VER) && (_MSC_VER <= 1800)\\n#pragma warning(disable: 4127)\\n#endif\\n\\n#if defined(_WIN32) || defined(__EMSCRIPTEN__)\\n#  define MUNIT_NO_FORK\\n#endif\\n\\n#if defined(__EMSCRIPTEN__)\\n#  define MUNIT_NO_BUFFER\\n#endif\\n\\n/*** Logging ***/\\n\\nstatic MunitLogLevel munit_log_level_visible = MUNIT_LOG_INFO;\\nstatic MunitLogLevel munit_log_level_fatal = MUNIT_LOG_ERROR;\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\nstatic MUNIT_THREAD_LOCAL munit_bool munit_error_jmp_buf_valid = 0;\\nstatic MUNIT_THREAD_LOCAL jmp_buf munit_error_jmp_buf;\\n#endif\\n\\n/* At certain warning levels, mingw will trigger warnings about\\n * suggesting the format attribute, which we've explicity *not* set\\n * because it will then choke on our attempts to use the MS-specific\\n * I64 modifier for size_t (which we have to use since MSVC doesn't\\n * support the C99 z modifier). */\\n\\n#if defined(__MINGW32__) || defined(__MINGW64__)\\n#  pragma GCC diagnostic push\\n#  pragma GCC diagnostic ignored \\\"-Wsuggest-attribute=format\\\"\\n#endif\\n\\nMUNIT_PRINTF(5,0)\\nstatic void\\nmunit_logf_exv(MunitLogLevel level, FILE* fp, const char* filename, int line, const char* format, va_list ap) {\\n  if (level < munit_log_level_visible)\\n    return;\\n\\n  switch (level) {\\n    case MUNIT_LOG_DEBUG:\\n      fputs(\\\"Debug\\\", fp);\\n      break;\\n    case MUNIT_LOG_INFO:\\n      fputs(\\\"Info\\\", fp);\\n      break;\\n    case MUNIT_LOG_WARNING:\\n      fputs(\\\"Warning\\\", fp);\\n      break;\\n    case MUNIT_LOG_ERROR:\\n      fputs(\\\"Error\\\", fp);\\n      break;\\n    default:\\n      munit_logf_ex(MUNIT_LOG_ERROR, filename, line, \\\"Invalid log level (%d)\\\", level);\\n      return;\\n  }\\n\\n  fputs(\\\": \\\", fp);\\n  if (filename != NULL)\\n    fprintf(fp, \\\"%s:%d: \\\", filename, line);\\n  vfprintf(fp, format, ap);\\n  fputc('\\\\n', fp);\\n}\\n\\nMUNIT_PRINTF(3,4)\\nstatic void\\nmunit_logf_internal(MunitLogLevel level, FILE* fp, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(level, fp, NULL, 0, format, ap);\\n  va_end(ap);\\n}\\n\\nstatic void\\nmunit_log_internal(MunitLogLevel level, FILE* fp, const char* message) {\\n  munit_logf_internal(level, fp, \\\"%s\\\", message);\\n}\\n\\nvoid\\nmunit_logf_ex(MunitLogLevel level, const char* filename, int line, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(level, stderr, filename, line, format, ap);\\n  va_end(ap);\\n\\n  if (level >= munit_log_level_fatal) {\\n#if defined(MUNIT_THREAD_LOCAL)\\n    if (munit_error_jmp_buf_valid)\\n      longjmp(munit_error_jmp_buf, 1);\\n#endif\\n    abort();\\n  }\\n}\\n\\nvoid\\nmunit_errorf_ex(const char* filename, int line, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(MUNIT_LOG_ERROR, stderr, filename, line, format, ap);\\n  va_end(ap);\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\n  if (munit_error_jmp_buf_valid)\\n    longjmp(munit_error_jmp_buf, 1);\\n#endif\\n  abort();\\n}\\n\\n#if defined(__MINGW32__) || defined(__MINGW64__)\\n#pragma GCC diagnostic pop\\n#endif\\n\\n#if !defined(MUNIT_STRERROR_LEN)\\n#  define MUNIT_STRERROR_LEN 80\\n#endif\\n\\nstatic void\\nmunit_log_errno(MunitLogLevel level, FILE* fp, const char* msg) {\\n#if defined(MUNIT_NO_STRERROR_R) || (defined(__MINGW32__) && !defined(MINGW_HAS_SECURE_API))\\n  munit_logf_internal(level, fp, \\\"%s: %s (%d)\\\", msg, strerror(errno), errno);\\n#else\\n  char munit_error_str[MUNIT_STRERROR_LEN];\\n  munit_error_str[0] = '\\\\0';\\n\\n#if !defined(_WIN32)\\n  strerror_r(errno, munit_error_str, MUNIT_STRERROR_LEN);\\n#else\\n  strerror_s(munit_error_str, MUNIT_STRERROR_LEN, errno);\\n#endif\\n\\n  munit_logf_internal(level, fp, \\\"%s: %s (%d)\\\", msg, munit_error_str, errno);\\n#endif\\n}\\n\\n/*** Memory allocation ***/\\n\\nvoid*\\nmunit_malloc_ex(const char* filename, int line, size_t size) {\\n  void* ptr;\\n\\n  if (size == 0)\\n    return NULL;\\n\\n  ptr = calloc(1, size);\\n  if (MUNIT_UNLIKELY(ptr == NULL)) {\\n    munit_logf_ex(MUNIT_LOG_ERROR, filename, line, \\\"Failed to allocate %\\\" MUNIT_SIZE_MODIFIER \\\"u bytes.\\\", size);\\n  }\\n\\n  return ptr;\\n}\\n\\n/*** Timer code ***/\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n\\n#define psnip_uint64_t munit_uint64_t\\n#define psnip_uint32_t munit_uint32_t\\n\\n/* Code copied from portable-snippets\\n * <https://github.com/nemequ/portable-snippets/>.  If you need to\\n * change something, please do it there so we can keep the code in\\n * sync. */\\n\\n/* Clocks (v1)\\n * Portable Snippets - https://gitub.com/nemequ/portable-snippets\\n * Created by Evan Nemerson <evan@nemerson.com>\\n *\\n *   To the extent possible under law, the authors have waived all\\n *   copyright and related or neighboring rights to this code.  For\\n *   details, see the Creative Commons Zero 1.0 Universal license at\\n *   https://creativecommons.org/publicdomain/zero/1.0/\\n */\\n\\n#if !defined(PSNIP_CLOCK_H)\\n#define PSNIP_CLOCK_H\\n\\n#if !defined(psnip_uint64_t)\\n#  include \\\"../exact-int/exact-int.h\\\"\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_STATIC_INLINE)\\n#  if defined(__GNUC__)\\n#    define PSNIP_CLOCK__COMPILER_ATTRIBUTES __attribute__((__unused__))\\n#  else\\n#    define PSNIP_CLOCK__COMPILER_ATTRIBUTES\\n#  endif\\n\\n#  define PSNIP_CLOCK__FUNCTION PSNIP_CLOCK__COMPILER_ATTRIBUTES static\\n#endif\\n\\nenum PsnipClockType {\\n  /* This clock provides the current time, in units since 1970-01-01\\n   * 00:00:00 UTC not including leap seconds.  In other words, UNIX\\n   * time.  Keep in mind that this clock doesn't account for leap\\n   * seconds, and can go backwards (think NTP adjustments). */\\n  PSNIP_CLOCK_TYPE_WALL = 1,\\n  /* The CPU time is a clock which increases only when the current\\n   * process is active (i.e., it doesn't increment while blocking on\\n   * I/O). */\\n  PSNIP_CLOCK_TYPE_CPU = 2,\\n  /* Monotonic time is always running (unlike CPU time), but it only\\n     ever moves forward unless you reboot the system.  Things like NTP\\n     adjustments have no effect on this clock. */\\n  PSNIP_CLOCK_TYPE_MONOTONIC = 3\\n};\\n\\nstruct PsnipClockTimespec {\\n  psnip_uint64_t seconds;\\n  psnip_uint64_t nanoseconds;\\n};\\n\\n/* Methods we support: */\\n\\n#define PSNIP_CLOCK_METHOD_CLOCK_GETTIME                   1\\n#define PSNIP_CLOCK_METHOD_TIME                            2\\n#define PSNIP_CLOCK_METHOD_GETTIMEOFDAY                    3\\n#define PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER         4\\n#define PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME              5\\n#define PSNIP_CLOCK_METHOD_CLOCK                           6\\n#define PSNIP_CLOCK_METHOD_GETPROCESSTIMES                 7\\n#define PSNIP_CLOCK_METHOD_GETRUSAGE                       8\\n#define PSNIP_CLOCK_METHOD_GETSYSTEMTIMEPRECISEASFILETIME  9\\n#define PSNIP_CLOCK_METHOD_GETTICKCOUNT64                 10\\n\\n#include <assert.h>\\n\\n#if defined(HEDLEY_UNREACHABLE)\\n#  define PSNIP_CLOCK_UNREACHABLE() HEDLEY_UNREACHABLE()\\n#else\\n#  define PSNIP_CLOCK_UNREACHABLE() assert(0)\\n#endif\\n\\n/* Choose an implementation */\\n\\n/* #undef PSNIP_CLOCK_WALL_METHOD */\\n/* #undef PSNIP_CLOCK_CPU_METHOD */\\n/* #undef PSNIP_CLOCK_MONOTONIC_METHOD */\\n\\n/* We want to be able to detect the libc implementation, so we include\\n   <limits.h> (<features.h> isn't available everywhere). */\\n\\n#if defined(__unix__) || defined(__unix) || defined(__linux__)\\n#  include <limits.h>\\n#  include <unistd.h>\\n#endif\\n\\n#if defined(_POSIX_TIMERS) && (_POSIX_TIMERS > 0)\\n/* These are known to work without librt.  If you know of others\\n * please let us know so we can add them. */\\n#  if \\\\\\n  (defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 17))) || \\\\\\n  (defined(__FreeBSD__))\\n#    define PSNIP_CLOCK_HAVE_CLOCK_GETTIME\\n#  elif !defined(PSNIP_CLOCK_NO_LIBRT)\\n#    define PSNIP_CLOCK_HAVE_CLOCK_GETTIME\\n#  endif\\n#endif\\n\\n#if defined(_WIN32)\\n#  if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#    define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n#  endif\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n#  endif\\n#endif\\n\\n#if defined(__MACH__) && !defined(__gnu_hurd__)\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n#  endif\\n#endif\\n\\n#if defined(PSNIP_CLOCK_HAVE_CLOCK_GETTIME)\\n#  include <time.h>\\n#  if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#    if defined(CLOCK_REALTIME_PRECISE)\\n#      define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_WALL CLOCK_REALTIME_PRECISE\\n#    elif !defined(__sun)\\n#      define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_WALL CLOCK_REALTIME\\n#    endif\\n#  endif\\n#  if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#    if defined(_POSIX_CPUTIME) || defined(CLOCK_PROCESS_CPUTIME_ID)\\n#      define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_CPU CLOCK_PROCESS_CPUTIME_ID\\n#    elif defined(CLOCK_VIRTUAL)\\n#      define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_CPU CLOCK_VIRTUAL\\n#    endif\\n#  endif\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    if defined(CLOCK_MONOTONIC_RAW)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC\\n#    elif defined(CLOCK_MONOTONIC_PRECISE)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC_PRECISE\\n#    elif defined(_POSIX_MONOTONIC_CLOCK) || defined(CLOCK_MONOTONIC)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC\\n#    endif\\n#  endif\\n#endif\\n\\n#if defined(_POSIX_VERSION) && (_POSIX_VERSION >= 200112L)\\n#  if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#    define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n#  endif\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#  define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_TIME\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#  define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK\\n#endif\\n\\n/* Primarily here for testing. */\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD) && defined(PSNIP_CLOCK_REQUIRE_MONOTONIC)\\n#  error No monotonic clock found.\\n#endif\\n\\n/* Implementations */\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_TIME))\\n#  include <time.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETTIMEOFDAY)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETTIMEOFDAY)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY))\\n#  include <sys/time.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETTICKCOUNT64)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETTICKCOUNT64)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64))\\n#  include <windows.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETRUSAGE)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETRUSAGE)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETRUSAGE))\\n#  include <sys/time.h>\\n#  include <sys/resource.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME))\\n#  include <CoreServices/CoreServices.h>\\n#  include <mach/mach.h>\\n#  include <mach/mach_time.h>\\n#endif\\n\\n/*** Implementations ***/\\n\\n#define PSNIP_CLOCK_NSEC_PER_SEC ((psnip_uint32_t) (1000000000ULL))\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME))\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock__clock_getres (clockid_t clk_id) {\\n  struct timespec res;\\n  int r;\\n\\n  r = clock_getres(clk_id, &res);\\n  if (r != 0)\\n    return 0;\\n\\n  return (psnip_uint32_t) (PSNIP_CLOCK_NSEC_PER_SEC / res.tv_nsec);\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock__clock_gettime (clockid_t clk_id, struct PsnipClockTimespec* res) {\\n  struct timespec ts;\\n\\n  if (clock_gettime(clk_id, &ts) != 0)\\n    return -10;\\n\\n  res->seconds = (psnip_uint64_t) (ts.tv_sec);\\n  res->nanoseconds = (psnip_uint64_t) (ts.tv_nsec);\\n\\n  return 0;\\n}\\n#endif\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_wall_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_WALL);\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n  return 1000000;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_TIME\\n  return 1;\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_wall_get_time (struct PsnipClockTimespec* res) {\\n  (void) res;\\n\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n  return -2;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_WALL, res);\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_TIME\\n  res->seconds = time(NULL);\\n  res->nanoseconds = 0;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n  struct timeval tv;\\n\\n  if (gettimeofday(&tv, NULL) != 0)\\n    return -6;\\n\\n  res->seconds = tv.tv_sec;\\n  res->nanoseconds = tv.tv_usec * 1000;\\n#else\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_cpu_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_CPU);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK\\n  return CLOCKS_PER_SEC;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n  return PSNIP_CLOCK_NSEC_PER_SEC / 100;\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_cpu_get_time (struct PsnipClockTimespec* res) {\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n  (void) res;\\n  return -2;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_CPU, res);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK\\n  clock_t t = clock();\\n  if (t == ((clock_t) -1))\\n    return -5;\\n  res->seconds = t / CLOCKS_PER_SEC;\\n  res->nanoseconds = (t % CLOCKS_PER_SEC) * (PSNIP_CLOCK_NSEC_PER_SEC / CLOCKS_PER_SEC);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n  FILETIME CreationTime, ExitTime, KernelTime, UserTime;\\n  LARGE_INTEGER date, adjust;\\n\\n  if (!GetProcessTimes(GetCurrentProcess(), &CreationTime, &ExitTime, &KernelTime, &UserTime))\\n    return -7;\\n\\n  /* http://www.frenk.com/2009/12/convert-filetime-to-unix-timestamp/ */\\n  date.HighPart = UserTime.dwHighDateTime;\\n  date.LowPart = UserTime.dwLowDateTime;\\n  adjust.QuadPart = 11644473600000 * 10000;\\n  date.QuadPart -= adjust.QuadPart;\\n\\n  res->seconds = date.QuadPart / 10000000;\\n  res->nanoseconds = (date.QuadPart % 10000000) * (PSNIP_CLOCK_NSEC_PER_SEC / 100);\\n#elif PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETRUSAGE\\n  struct rusage usage;\\n  if (getrusage(RUSAGE_SELF, &usage) != 0)\\n    return -8;\\n\\n  res->seconds = usage.ru_utime.tv_sec;\\n  res->nanoseconds = tv.tv_usec * 1000;\\n#else\\n  (void) res;\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_monotonic_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n  static mach_timebase_info_data_t tbi = { 0, };\\n  if (tbi.denom == 0)\\n    mach_timebase_info(&tbi);\\n  return (psnip_uint32_t) (tbi.numer / tbi.denom);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64\\n  return 1000;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n  LARGE_INTEGER Frequency;\\n  QueryPerformanceFrequency(&Frequency);\\n  return (psnip_uint32_t) ((Frequency.QuadPart > PSNIP_CLOCK_NSEC_PER_SEC) ? PSNIP_CLOCK_NSEC_PER_SEC : Frequency.QuadPart);\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_monotonic_get_time (struct PsnipClockTimespec* res) {\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n  (void) res;\\n  return -2;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC, res);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n  psnip_uint64_t nsec = mach_absolute_time();\\n  static mach_timebase_info_data_t tbi = { 0, };\\n  if (tbi.denom == 0)\\n    mach_timebase_info(&tbi);\\n  nsec *= ((psnip_uint64_t) tbi.numer) / ((psnip_uint64_t) tbi.denom);\\n  res->seconds = nsec / PSNIP_CLOCK_NSEC_PER_SEC;\\n  res->nanoseconds = nsec % PSNIP_CLOCK_NSEC_PER_SEC;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n  LARGE_INTEGER t, f;\\n  if (QueryPerformanceCounter(&t) == 0)\\n    return -12;\\n\\n  QueryPerformanceFrequency(&f);\\n  res->seconds = t.QuadPart / f.QuadPart;\\n  res->nanoseconds = t.QuadPart % f.QuadPart;\\n  if (f.QuadPart > PSNIP_CLOCK_NSEC_PER_SEC)\\n    res->nanoseconds /= f.QuadPart / PSNIP_CLOCK_NSEC_PER_SEC;\\n  else\\n    res->nanoseconds *= PSNIP_CLOCK_NSEC_PER_SEC / f.QuadPart;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64\\n  const ULONGLONG msec = GetTickCount64();\\n  res->seconds = msec / 1000;\\n  res->nanoseconds = sec % 1000;\\n#else\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\n/* Returns the number of ticks per second for the specified clock.\\n * For example, a clock with millisecond precision would return 1000,\\n * and a clock with 1 second (such as the time() function) would\\n * return 1.\\n *\\n * If the requested clock isn't available, it will return 0.\\n * Hopefully this will be rare, but if it happens to you please let us\\n * know so we can work on finding a way to support your system.\\n *\\n * Note that different clocks on the same system often have a\\n * different precisions.\\n */\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_get_precision (enum PsnipClockType clock_type) {\\n  switch (clock_type) {\\n    case PSNIP_CLOCK_TYPE_MONOTONIC:\\n      return psnip_clock_monotonic_get_precision ();\\n    case PSNIP_CLOCK_TYPE_CPU:\\n      return psnip_clock_cpu_get_precision ();\\n    case PSNIP_CLOCK_TYPE_WALL:\\n      return psnip_clock_wall_get_precision ();\\n  }\\n\\n  PSNIP_CLOCK_UNREACHABLE();\\n  return 0;\\n}\\n\\n/* Set the provided timespec to the requested time.  Returns 0 on\\n * success, or a negative value on failure. */\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_get_time (enum PsnipClockType clock_type, struct PsnipClockTimespec* res) {\\n  assert(res != NULL);\\n\\n  switch (clock_type) {\\n    case PSNIP_CLOCK_TYPE_MONOTONIC:\\n      return psnip_clock_monotonic_get_time (res);\\n    case PSNIP_CLOCK_TYPE_CPU:\\n      return psnip_clock_cpu_get_time (res);\\n    case PSNIP_CLOCK_TYPE_WALL:\\n      return psnip_clock_wall_get_time (res);\\n  }\\n\\n  return -1;\\n}\\n\\n#endif /* !defined(PSNIP_CLOCK_H) */\\n\\nstatic psnip_uint64_t\\nmunit_clock_get_elapsed(struct PsnipClockTimespec* start, struct PsnipClockTimespec* end) {\\n  psnip_uint64_t r = (end->seconds - start->seconds) * PSNIP_CLOCK_NSEC_PER_SEC;\\n  if (end->nanoseconds < start->nanoseconds) {\\n    r -= (start->nanoseconds - end->nanoseconds);\\n  } else {\\n    r += (end->nanoseconds - start->nanoseconds);\\n  }\\n  return r;\\n}\\n\\n#else\\n#  include <time.h>\\n#endif /* defined(MUNIT_ENABLE_TIMING) */\\n\\n/*** PRNG stuff ***/\\n\\n/* This is (unless I screwed up, which is entirely possible) the\\n * version of PCG with 32-bit state.  It was chosen because it has a\\n * small enough state that we should reliably be able to use CAS\\n * instead of requiring a lock for thread-safety.\\n *\\n * If I did screw up, I probably will not bother changing it unless\\n * there is a significant bias.  It's really not important this be\\n * particularly strong, as long as it is fairly random it's much more\\n * important that it be reproducible, so bug reports have a better\\n * chance of being reproducible. */\\n\\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__) && !defined(__EMSCRIPTEN__) && (!defined(__GNUC_MINOR__) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ > 8))\\n#  define HAVE_STDATOMIC\\n#elif defined(__clang__)\\n#  if __has_extension(c_atomic)\\n#    define HAVE_CLANG_ATOMICS\\n#  endif\\n#endif\\n\\n/* Workaround for http://llvm.org/bugs/show_bug.cgi?id=26911 */\\n#if defined(__clang__) && defined(_WIN32)\\n#  undef HAVE_STDATOMIC\\n#  if defined(__c2__)\\n#    undef HAVE_CLANG_ATOMICS\\n#  endif\\n#endif\\n\\n#if defined(_OPENMP)\\n#  define ATOMIC_UINT32_T uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#elif defined(HAVE_STDATOMIC)\\n#  include <stdatomic.h>\\n#  define ATOMIC_UINT32_T _Atomic uint32_t\\n#  define ATOMIC_UINT32_INIT(x) ATOMIC_VAR_INIT(x)\\n#elif defined(HAVE_CLANG_ATOMICS)\\n#  define ATOMIC_UINT32_T _Atomic uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#elif defined(_WIN32)\\n#  define ATOMIC_UINT32_T volatile LONG\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#else\\n#  define ATOMIC_UINT32_T volatile uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#endif\\n\\nstatic ATOMIC_UINT32_T munit_rand_state = ATOMIC_UINT32_INIT(42);\\n\\n#if defined(_OPENMP)\\nstatic inline void\\nmunit_atomic_store(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T value) {\\n#pragma omp critical (munit_atomics)\\n  *dest = value;\\n}\\n\\nstatic inline uint32_t\\nmunit_atomic_load(ATOMIC_UINT32_T* src) {\\n  int ret;\\n#pragma omp critical (munit_atomics)\\n  ret = *src;\\n  return ret;\\n}\\n\\nstatic inline uint32_t\\nmunit_atomic_cas(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T* expected, ATOMIC_UINT32_T desired) {\\n  munit_bool ret;\\n\\n#pragma omp critical (munit_atomics)\\n  {\\n    if (*dest == *expected) {\\n      *dest = desired;\\n      ret = 1;\\n    } else {\\n      ret = 0;\\n    }\\n  }\\n\\n  return ret;\\n}\\n#elif defined(HAVE_STDATOMIC)\\n#  define munit_atomic_store(dest, value)         atomic_store(dest, value)\\n#  define munit_atomic_load(src)                  atomic_load(src)\\n#  define munit_atomic_cas(dest, expected, value) atomic_compare_exchange_weak(dest, expected, value)\\n#elif defined(HAVE_CLANG_ATOMICS)\\n#  define munit_atomic_store(dest, value)         __c11_atomic_store(dest, value, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_load(src)                  __c11_atomic_load(src, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_cas(dest, expected, value) __c11_atomic_compare_exchange_weak(dest, expected, value, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\\n#elif defined(__GNUC__) && (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)\\n#  define munit_atomic_store(dest, value)         __atomic_store_n(dest, value, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_load(src)                  __atomic_load_n(src, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_cas(dest, expected, value) __atomic_compare_exchange_n(dest, expected, value, 1, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\\n#elif defined(__GNUC__) && (__GNUC__ >= 4)\\n#  define munit_atomic_store(dest,value)          do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\n#  define munit_atomic_cas(dest, expected, value) __sync_bool_compare_and_swap(dest, *expected, value)\\n#elif defined(_WIN32) /* Untested */\\n#  define munit_atomic_store(dest,value)          do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\n#  define munit_atomic_cas(dest, expected, value) InterlockedCompareExchange((dest), (value), *(expected))\\n#else\\n#  warning No atomic implementation, PRNG will not be thread-safe\\n#  define munit_atomic_store(dest, value)         do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\nstatic inline munit_bool\\nmunit_atomic_cas(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T* expected, ATOMIC_UINT32_T desired) {\\n  if (*dest == *expected) {\\n    *dest = desired;\\n    return 1;\\n  } else {\\n    return 0;\\n  }\\n}\\n#endif\\n\\n#define MUNIT_PRNG_MULTIPLIER (747796405U)\\n#define MUNIT_PRNG_INCREMENT  (1729U)\\n\\nstatic munit_uint32_t\\nmunit_rand_next_state(munit_uint32_t state) {\\n  return state * MUNIT_PRNG_MULTIPLIER + MUNIT_PRNG_INCREMENT;\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_from_state(munit_uint32_t state) {\\n  munit_uint32_t res = ((state >> ((state >> 28) + 4)) ^ state) * (277803737U);\\n  res ^= res >> 22;\\n  return res;\\n}\\n\\nvoid\\nmunit_rand_seed(munit_uint32_t seed) {\\n  munit_uint32_t state = munit_rand_next_state(seed + MUNIT_PRNG_INCREMENT);\\n  munit_atomic_store(&munit_rand_state, state);\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_generate_seed(void) {\\n  munit_uint32_t seed, state;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  struct PsnipClockTimespec wc = { 0, };\\n\\n  psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wc);\\n  seed = (munit_uint32_t) wc.nanoseconds;\\n#else\\n  seed = (munit_uint32_t) time(NULL);\\n#endif\\n\\n  state = munit_rand_next_state(seed + MUNIT_PRNG_INCREMENT);\\n  return munit_rand_from_state(state);\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_state_uint32(munit_uint32_t* state) {\\n  const munit_uint32_t old = *state;\\n  *state = munit_rand_next_state(old);\\n  return munit_rand_from_state(old);\\n}\\n\\nmunit_uint32_t\\nmunit_rand_uint32(void) {\\n  munit_uint32_t old, state;\\n\\n  do {\\n    old = munit_atomic_load(&munit_rand_state);\\n    state = munit_rand_next_state(old);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return munit_rand_from_state(old);\\n}\\n\\nstatic void\\nmunit_rand_state_memory(munit_uint32_t* state, size_t size, munit_uint8_t data[MUNIT_ARRAY_PARAM(size)]) {\\n  size_t members_remaining = size / sizeof(munit_uint32_t);\\n  size_t bytes_remaining = size % sizeof(munit_uint32_t);\\n  munit_uint8_t* b = data;\\n  munit_uint32_t rv;\\n  while (members_remaining-- > 0) {\\n    rv = munit_rand_state_uint32(state);\\n    memcpy(b, &rv, sizeof(munit_uint32_t));\\n    b += sizeof(munit_uint32_t);\\n  }\\n  if (bytes_remaining != 0) {\\n    rv = munit_rand_state_uint32(state);\\n    memcpy(b, &rv, bytes_remaining);\\n  }\\n}\\n\\nvoid\\nmunit_rand_memory(size_t size, munit_uint8_t data[MUNIT_ARRAY_PARAM(size)]) {\\n  munit_uint32_t old, state;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n    munit_rand_state_memory(&state, size, data);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_state_at_most(munit_uint32_t* state, munit_uint32_t salt, munit_uint32_t max) {\\n  /* We want (UINT32_MAX + 1) % max, which in unsigned arithmetic is the same\\n   * as (UINT32_MAX + 1 - max) % max = -max % max. We compute -max using not\\n   * to avoid compiler warnings.\\n   */\\n  const munit_uint32_t min = (~max + 1U) % max;\\n  munit_uint32_t x;\\n\\n  if (max == (~((munit_uint32_t) 0U)))\\n    return munit_rand_state_uint32(state) ^ salt;\\n\\n  max++;\\n\\n  do {\\n    x = munit_rand_state_uint32(state) ^ salt;\\n  } while (x < min);\\n\\n  return x % max;\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_at_most(munit_uint32_t salt, munit_uint32_t max) {\\n  munit_uint32_t old, state;\\n  munit_uint32_t retval;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n    retval = munit_rand_state_at_most(&state, salt, max);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return retval;\\n}\\n\\nint\\nmunit_rand_int_range(int min, int max) {\\n  munit_uint64_t range = (munit_uint64_t) max - (munit_uint64_t) min;\\n\\n  if (min > max)\\n    return munit_rand_int_range(max, min);\\n\\n  if (range > (~((munit_uint32_t) 0U)))\\n    range = (~((munit_uint32_t) 0U));\\n\\n  return min + munit_rand_at_most(0, (munit_uint32_t) range);\\n}\\n\\ndouble\\nmunit_rand_double(void) {\\n  munit_uint32_t old, state;\\n  double retval = 0.0;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n\\n    /* See http://mumble.net/~campbell/tmp/random_real.c for how to do\\n     * this right.  Patches welcome if you feel that this is too\\n     * biased. */\\n    retval = munit_rand_state_uint32(&state) / ((~((munit_uint32_t) 0U)) + 1.0);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return retval;\\n}\\n\\n/*** Test suite handling ***/\\n\\ntypedef struct {\\n  unsigned int successful;\\n  unsigned int skipped;\\n  unsigned int failed;\\n  unsigned int errored;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  munit_uint64_t cpu_clock;\\n  munit_uint64_t wall_clock;\\n#endif\\n} MunitReport;\\n\\ntypedef struct {\\n  const char* prefix;\\n  const MunitSuite* suite;\\n  const char** tests;\\n  munit_uint32_t seed;\\n  unsigned int iterations;\\n  MunitParameter* parameters;\\n  munit_bool single_parameter_mode;\\n  void* user_data;\\n  MunitReport report;\\n  munit_bool colorize;\\n  munit_bool fork;\\n  munit_bool show_stderr;\\n  munit_bool fatal_failures;\\n} MunitTestRunner;\\n\\nconst char*\\nmunit_parameters_get(const MunitParameter params[], const char* key) {\\n  const MunitParameter* param;\\n\\n  for (param = params ; param != NULL && param->name != NULL ; param++)\\n    if (strcmp(param->name, key) == 0)\\n      return param->value;\\n  return NULL;\\n}\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\nstatic void\\nmunit_print_time(FILE* fp, munit_uint64_t nanoseconds) {\\n  fprintf(fp, \\\"%\\\" MUNIT_TEST_TIME_FORMAT, ((double) nanoseconds) / ((double) PSNIP_CLOCK_NSEC_PER_SEC));\\n}\\n#endif\\n\\n/* Add a paramter to an array of parameters. */\\nstatic MunitResult\\nmunit_parameters_add(size_t* params_size, MunitParameter* params[MUNIT_ARRAY_PARAM(*params_size)], char* name, char* value) {\\n  *params = realloc(*params, sizeof(MunitParameter) * (*params_size + 2));\\n  if (*params == NULL)\\n    return MUNIT_ERROR;\\n\\n  (*params)[*params_size].name = name;\\n  (*params)[*params_size].value = value;\\n  (*params_size)++;\\n  (*params)[*params_size].name = NULL;\\n  (*params)[*params_size].value = NULL;\\n\\n  return MUNIT_OK;\\n}\\n\\n/* Concatenate two strings, but just return one of the components\\n * unaltered if the other is NULL or \\\"\\\". */\\nstatic char*\\nmunit_maybe_concat(size_t* len, char* prefix, char* suffix) {\\n  char* res;\\n  size_t res_l;\\n  const size_t prefix_l = prefix != NULL ? strlen(prefix) : 0;\\n  const size_t suffix_l = suffix != NULL ? strlen(suffix) : 0;\\n  if (prefix_l == 0 && suffix_l == 0) {\\n    res = NULL;\\n    res_l = 0;\\n  } else if (prefix_l == 0 && suffix_l != 0) {\\n    res = suffix;\\n    res_l = suffix_l;\\n  } else if (prefix_l != 0 && suffix_l == 0) {\\n    res = prefix;\\n    res_l = prefix_l;\\n  } else {\\n    res_l = prefix_l + suffix_l;\\n    res = malloc(res_l + 1);\\n    memcpy(res, prefix, prefix_l);\\n    memcpy(res + prefix_l, suffix, suffix_l);\\n    res[res_l] = 0;\\n  }\\n\\n  if (len != NULL)\\n    *len = res_l;\\n\\n  return res;\\n}\\n\\n/* Possbily free a string returned by munit_maybe_concat. */\\nstatic void\\nmunit_maybe_free_concat(char* s, const char* prefix, const char* suffix) {\\n  if (prefix != s && suffix != s)\\n    free(s);\\n}\\n\\n/* Cheap string hash function, just used to salt the PRNG. */\\nstatic munit_uint32_t\\nmunit_str_hash(const char* name) {\\n  const char *p;\\n  munit_uint32_t h = 5381U;\\n\\n  for (p = name; *p != '\\\\0'; p++)\\n    h = (h << 5) + h + *p;\\n\\n  return h;\\n}\\n\\nstatic void\\nmunit_splice(int from, int to) {\\n  munit_uint8_t buf[1024];\\n#if !defined(_WIN32)\\n  ssize_t len;\\n  ssize_t bytes_written;\\n  ssize_t write_res;\\n#else\\n  int len;\\n  int bytes_written;\\n  int write_res;\\n#endif\\n  do {\\n    len = read(from, buf, sizeof(buf));\\n    if (len > 0) {\\n      bytes_written = 0;\\n      do {\\n        write_res = write(to, buf + bytes_written, len - bytes_written);\\n        if (write_res < 0)\\n          break;\\n        bytes_written += write_res;\\n      } while (bytes_written < len);\\n    }\\n    else\\n      break;\\n  } while (1);\\n}\\n\\n/* This is the part that should be handled in the child process */\\nstatic MunitResult\\nmunit_test_runner_exec(MunitTestRunner* runner, const MunitTest* test, const MunitParameter params[], MunitReport* report) {\\n  unsigned int iterations = runner->iterations;\\n  MunitResult result = MUNIT_FAIL;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  struct PsnipClockTimespec wall_clock_begin = { 0, }, wall_clock_end = { 0, };\\n  struct PsnipClockTimespec cpu_clock_begin = { 0, }, cpu_clock_end = { 0, };\\n#endif\\n  unsigned int i = 0;\\n\\n  if ((test->options & MUNIT_TEST_OPTION_SINGLE_ITERATION) == MUNIT_TEST_OPTION_SINGLE_ITERATION)\\n    iterations = 1;\\n  else if (iterations == 0)\\n    iterations = runner->suite->iterations;\\n\\n  munit_rand_seed(runner->seed);\\n\\n  do {\\n    void* data = (test->setup == NULL) ? runner->user_data : test->setup(params, runner->user_data);\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wall_clock_begin);\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_CPU, &cpu_clock_begin);\\n#endif\\n\\n    result = test->test(params, data);\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wall_clock_end);\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_CPU, &cpu_clock_end);\\n#endif\\n\\n    if (test->tear_down != NULL)\\n      test->tear_down(data);\\n\\n    if (MUNIT_LIKELY(result == MUNIT_OK)) {\\n      report->successful++;\\n#if defined(MUNIT_ENABLE_TIMING)\\n      report->wall_clock += munit_clock_get_elapsed(&wall_clock_begin, &wall_clock_end);\\n      report->cpu_clock += munit_clock_get_elapsed(&cpu_clock_begin, &cpu_clock_end);\\n#endif\\n    } else {\\n      switch ((int) result) {\\n        case MUNIT_SKIP:\\n          report->skipped++;\\n          break;\\n        case MUNIT_FAIL:\\n          report->failed++;\\n          break;\\n        case MUNIT_ERROR:\\n          report->errored++;\\n          break;\\n        default:\\n          break;\\n      }\\n      break;\\n    }\\n  } while (++i < iterations);\\n\\n  return result;\\n}\\n\\n#if defined(MUNIT_EMOTICON)\\n#  define MUNIT_RESULT_STRING_OK    \\\":)\\\"\\n#  define MUNIT_RESULT_STRING_SKIP  \\\":|\\\"\\n#  define MUNIT_RESULT_STRING_FAIL  \\\":(\\\"\\n#  define MUNIT_RESULT_STRING_ERROR \\\":o\\\"\\n#  define MUNIT_RESULT_STRING_TODO  \\\":/\\\"\\n#else\\n#  define MUNIT_RESULT_STRING_OK    \\\"OK   \\\"\\n#  define MUNIT_RESULT_STRING_SKIP  \\\"SKIP \\\"\\n#  define MUNIT_RESULT_STRING_FAIL  \\\"FAIL \\\"\\n#  define MUNIT_RESULT_STRING_ERROR \\\"ERROR\\\"\\n#  define MUNIT_RESULT_STRING_TODO  \\\"TODO \\\"\\n#endif\\n\\nstatic void\\nmunit_test_runner_print_color(const MunitTestRunner* runner, const char* string, char color) {\\n  if (runner->colorize)\\n    fprintf(MUNIT_OUTPUT_FILE, \\\"\\\\x1b[3%cm%s\\\\x1b[39m\\\", color, string);\\n  else\\n    fputs(string, MUNIT_OUTPUT_FILE);\\n}\\n\\n#if !defined(MUNIT_NO_BUFFER)\\nstatic int\\nmunit_replace_stderr(FILE* stderr_buf) {\\n  if (stderr_buf != NULL) {\\n    const int orig_stderr = dup(STDERR_FILENO);\\n\\n    int errfd = fileno(stderr_buf);\\n    if (MUNIT_UNLIKELY(errfd == -1)) {\\n      exit(EXIT_FAILURE);\\n    }\\n\\n    dup2(errfd, STDERR_FILENO);\\n\\n    return orig_stderr;\\n  }\\n\\n  return -1;\\n}\\n\\nstatic void\\nmunit_restore_stderr(int orig_stderr) {\\n  if (orig_stderr != -1) {\\n    dup2(orig_stderr, STDERR_FILENO);\\n    close(orig_stderr);\\n  }\\n}\\n#endif /* !defined(MUNIT_NO_BUFFER) */\\n\\n/* Run a test with the specified parameters. */\\nstatic void\\nmunit_test_runner_run_test_with_params(MunitTestRunner* runner, const MunitTest* test, const MunitParameter params[]) {\\n  MunitResult result = MUNIT_OK;\\n  MunitReport report = {\\n    0, 0, 0, 0,\\n#if defined(MUNIT_ENABLE_TIMING)\\n    0, 0\\n#endif\\n  };\\n  unsigned int output_l;\\n  munit_bool first;\\n  const MunitParameter* param;\\n  FILE* stderr_buf;\\n#if !defined(MUNIT_NO_FORK)\\n  int pipefd[2];\\n  pid_t fork_pid;\\n  int orig_stderr;\\n  ssize_t bytes_written = 0;\\n  ssize_t write_res;\\n  ssize_t bytes_read = 0;\\n  ssize_t read_res;\\n  int status = 0;\\n  pid_t changed_pid;\\n#endif\\n\\n  if (params != NULL) {\\n    output_l = 2;\\n    fputs(\\\"  \\\", MUNIT_OUTPUT_FILE);\\n    first = 1;\\n    for (param = params ; param != NULL && param->name != NULL ; param++) {\\n      if (!first) {\\n        fputs(\\\", \\\", MUNIT_OUTPUT_FILE);\\n        output_l += 2;\\n      } else {\\n        first = 0;\\n      }\\n\\n      output_l += fprintf(MUNIT_OUTPUT_FILE, \\\"%s=%s\\\", param->name, param->value);\\n    }\\n    while (output_l++ < MUNIT_TEST_NAME_LEN) {\\n      fputc(' ', MUNIT_OUTPUT_FILE);\\n    }\\n  }\\n\\n  fflush(MUNIT_OUTPUT_FILE);\\n\\n  stderr_buf = NULL;\\n#if !defined(_WIN32) || defined(__MINGW32__)\\n  stderr_buf = tmpfile();\\n#else\\n  tmpfile_s(&stderr_buf);\\n#endif\\n  if (stderr_buf == NULL) {\\n    munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to create buffer for stderr\\\");\\n    result = MUNIT_ERROR;\\n    goto print_result;\\n  }\\n\\n#if !defined(MUNIT_NO_FORK)\\n  if (runner->fork) {\\n    pipefd[0] = -1;\\n    pipefd[1] = -1;\\n    if (pipe(pipefd) != 0) {\\n      munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to create pipe\\\");\\n      result = MUNIT_ERROR;\\n      goto print_result;\\n    }\\n\\n    fork_pid = fork();\\n    if (fork_pid == 0) {\\n      close(pipefd[0]);\\n\\n      orig_stderr = munit_replace_stderr(stderr_buf);\\n      munit_test_runner_exec(runner, test, params, &report);\\n\\n      /* Note that we don't restore stderr.  This is so we can buffer\\n       * things written to stderr later on (such as by\\n       * asan/tsan/ubsan, valgrind, etc.) */\\n      close(orig_stderr);\\n\\n      do {\\n        write_res = write(pipefd[1], ((munit_uint8_t*) (&report)) + bytes_written, sizeof(report) - bytes_written);\\n        if (write_res < 0) {\\n          if (stderr_buf != NULL) {\\n            munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to write to pipe\\\");\\n          }\\n          exit(EXIT_FAILURE);\\n        }\\n        bytes_written += write_res;\\n      } while ((size_t) bytes_written < sizeof(report));\\n\\n      if (stderr_buf != NULL)\\n        fclose(stderr_buf);\\n      close(pipefd[1]);\\n\\n      exit(EXIT_SUCCESS);\\n    } else if (fork_pid == -1) {\\n      close(pipefd[0]);\\n      close(pipefd[1]);\\n      if (stderr_buf != NULL) {\\n        munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to fork\\\");\\n      }\\n      report.errored++;\\n      result = MUNIT_ERROR;\\n    } else {\\n      close(pipefd[1]);\\n      do {\\n        read_res = read(pipefd[0], ((munit_uint8_t*) (&report)) + bytes_read, sizeof(report) - bytes_read);\\n        if (read_res < 1)\\n          break;\\n        bytes_read += read_res;\\n      } while (bytes_read < (ssize_t) sizeof(report));\\n\\n      changed_pid = waitpid(fork_pid, &status, 0);\\n\\n      if (MUNIT_LIKELY(changed_pid == fork_pid) && MUNIT_LIKELY(WIFEXITED(status))) {\\n        if (bytes_read != sizeof(report)) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child exited unexpectedly with status %d\\\", WEXITSTATUS(status));\\n          report.errored++;\\n        } else if (WEXITSTATUS(status) != EXIT_SUCCESS) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child exited with status %d\\\", WEXITSTATUS(status));\\n          report.errored++;\\n        }\\n      } else {\\n        if (WIFSIGNALED(status)) {\\n#if defined(_XOPEN_VERSION) && (_XOPEN_VERSION >= 700)\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child killed by signal %d (%s)\\\", WTERMSIG(status), strsignal(WTERMSIG(status)));\\n#else\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child killed by signal %d\\\", WTERMSIG(status));\\n#endif\\n        } else if (WIFSTOPPED(status)) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child stopped by signal %d\\\", WSTOPSIG(status));\\n        }\\n        report.errored++;\\n      }\\n\\n      close(pipefd[0]);\\n      waitpid(fork_pid, NULL, 0);\\n    }\\n  } else\\n#endif\\n  {\\n#if !defined(MUNIT_NO_BUFFER)\\n    const volatile int orig_stderr = munit_replace_stderr(stderr_buf);\\n#endif\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\n    if (MUNIT_UNLIKELY(setjmp(munit_error_jmp_buf) != 0)) {\\n      result = MUNIT_FAIL;\\n      report.failed++;\\n    } else {\\n      munit_error_jmp_buf_valid = 1;\\n      result = munit_test_runner_exec(runner, test, params, &report);\\n    }\\n#else\\n    result = munit_test_runner_exec(runner, test, params, &report);\\n#endif\\n\\n#if !defined(MUNIT_NO_BUFFER)\\n    munit_restore_stderr(orig_stderr);\\n#endif\\n\\n    /* Here just so that the label is used on Windows and we don't get\\n     * a warning */\\n    goto print_result;\\n  }\\n\\n print_result:\\n\\n  fputs(\\\"[ \\\", MUNIT_OUTPUT_FILE);\\n  if ((test->options & MUNIT_TEST_OPTION_TODO) == MUNIT_TEST_OPTION_TODO) {\\n    if (report.failed != 0 || report.errored != 0 || report.skipped != 0) {\\n      munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_TODO, '3');\\n      result = MUNIT_OK;\\n    } else {\\n      munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_ERROR, '1');\\n      if (MUNIT_LIKELY(stderr_buf != NULL))\\n        munit_log_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"Test marked TODO, but was successful.\\\");\\n      runner->report.failed++;\\n      result = MUNIT_ERROR;\\n    }\\n  } else if (report.failed > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_FAIL, '1');\\n    runner->report.failed++;\\n    result = MUNIT_FAIL;\\n  } else if (report.errored > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_ERROR, '1');\\n    runner->report.errored++;\\n    result = MUNIT_ERROR;\\n  } else if (report.skipped > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_SKIP, '3');\\n    runner->report.skipped++;\\n    result = MUNIT_SKIP;\\n  } else if (report.successful > 1) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_OK, '2');\\n#if defined(MUNIT_ENABLE_TIMING)\\n    fputs(\\\" ] [ \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock / report.successful);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock / report.successful);\\n    fprintf(MUNIT_OUTPUT_FILE, \\\" CPU ]\\\\n  %-\\\" MUNIT_XSTRINGIFY(MUNIT_TEST_NAME_LEN) \\\"s Total: [ \\\", \\\"\\\");\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock);\\n    fputs(\\\" CPU\\\", MUNIT_OUTPUT_FILE);\\n#endif\\n    runner->report.successful++;\\n    result = MUNIT_OK;\\n  } else if (report.successful > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_OK, '2');\\n#if defined(MUNIT_ENABLE_TIMING)\\n    fputs(\\\" ] [ \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock);\\n    fputs(\\\" CPU\\\", MUNIT_OUTPUT_FILE);\\n#endif\\n    runner->report.successful++;\\n    result = MUNIT_OK;\\n  }\\n  fputs(\\\" ]\\\\n\\\", MUNIT_OUTPUT_FILE);\\n\\n  if (stderr_buf != NULL) {\\n    if (result == MUNIT_FAIL || result == MUNIT_ERROR || runner->show_stderr) {\\n      fflush(MUNIT_OUTPUT_FILE);\\n\\n      rewind(stderr_buf);\\n      munit_splice(fileno(stderr_buf), STDERR_FILENO);\\n\\n      fflush(stderr);\\n    }\\n\\n    fclose(stderr_buf);\\n  }\\n}\\n\\nstatic void\\nmunit_test_runner_run_test_wild(MunitTestRunner* runner,\\n                                const MunitTest* test,\\n                                const char* test_name,\\n                                MunitParameter* params,\\n                                MunitParameter* p) {\\n  const MunitParameterEnum* pe;\\n  char** values;\\n  MunitParameter* next;\\n\\n  for (pe = test->parameters ; pe != NULL && pe->name != NULL ; pe++) {\\n    if (p->name == pe->name)\\n      break;\\n  }\\n\\n  if (pe == NULL)\\n    return;\\n\\n  for (values = pe->values ; *values != NULL ; values++) {\\n    next = p + 1;\\n    p->value = *values;\\n    if (next->name == NULL) {\\n      munit_test_runner_run_test_with_params(runner, test, params);\\n    } else {\\n      munit_test_runner_run_test_wild(runner, test, test_name, params, next);\\n    }\\n    if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n      break;\\n  }\\n}\\n\\n/* Run a single test, with every combination of parameters\\n * requested. */\\nstatic void\\nmunit_test_runner_run_test(MunitTestRunner* runner,\\n                           const MunitTest* test,\\n                           const char* prefix) {\\n  char* test_name = munit_maybe_concat(NULL, (char*) prefix, (char*) test->name);\\n  /* The array of parameters to pass to\\n   * munit_test_runner_run_test_with_params */\\n  MunitParameter* params = NULL;\\n  size_t params_l = 0;\\n  /* Wildcard parameters are parameters which have possible values\\n   * specified in the test, but no specific value was passed to the\\n   * CLI.  That means we want to run the test once for every\\n   * possible combination of parameter values or, if --single was\\n   * passed to the CLI, a single time with a random set of\\n   * parameters. */\\n  MunitParameter* wild_params = NULL;\\n  size_t wild_params_l = 0;\\n  const MunitParameterEnum* pe;\\n  const MunitParameter* cli_p;\\n  munit_bool filled;\\n  unsigned int possible;\\n  char** vals;\\n  size_t first_wild;\\n  const MunitParameter* wp;\\n  int pidx;\\n\\n  munit_rand_seed(runner->seed);\\n\\n  fprintf(MUNIT_OUTPUT_FILE, \\\"%-\\\" MUNIT_XSTRINGIFY(MUNIT_TEST_NAME_LEN) \\\"s\\\", test_name);\\n\\n  if (test->parameters == NULL) {\\n    /* No parameters.  Simple, nice. */\\n    munit_test_runner_run_test_with_params(runner, test, NULL);\\n  } else {\\n    fputc('\\\\n', MUNIT_OUTPUT_FILE);\\n\\n    for (pe = test->parameters ; pe != NULL && pe->name != NULL ; pe++) {\\n      /* Did we received a value for this parameter from the CLI? */\\n      filled = 0;\\n      for (cli_p = runner->parameters ; cli_p != NULL && cli_p->name != NULL ; cli_p++) {\\n        if (strcmp(cli_p->name, pe->name) == 0) {\\n          if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, cli_p->value) != MUNIT_OK))\\n            goto cleanup;\\n          filled = 1;\\n          break;\\n        }\\n      }\\n      if (filled)\\n        continue;\\n\\n      /* Nothing from CLI, is the enum NULL/empty?  We're not a\\n       * fuzzer\\u2026 */\\n      if (pe->values == NULL || pe->values[0] == NULL)\\n        continue;\\n\\n      /* If --single was passed to the CLI, choose a value from the\\n       * list of possibilities randomly. */\\n      if (runner->single_parameter_mode) {\\n        possible = 0;\\n        for (vals = pe->values ; *vals != NULL ; vals++)\\n          possible++;\\n        /* We want the tests to be reproducible, even if you're only\\n         * running a single test, but we don't want every test with\\n         * the same number of parameters to choose the same parameter\\n         * number, so use the test name as a primitive salt. */\\n        pidx = munit_rand_at_most(munit_str_hash(test_name), possible - 1);\\n        if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, pe->values[pidx]) != MUNIT_OK))\\n          goto cleanup;\\n      } else {\\n        /* We want to try every permutation.  Put in a placeholder\\n         * entry, we'll iterate through them later. */\\n        if (MUNIT_UNLIKELY(munit_parameters_add(&wild_params_l, &wild_params, pe->name, NULL) != MUNIT_OK))\\n          goto cleanup;\\n      }\\n    }\\n\\n    if (wild_params_l != 0) {\\n      first_wild = params_l;\\n      for (wp = wild_params ; wp != NULL && wp->name != NULL ; wp++) {\\n        for (pe = test->parameters ; pe != NULL && pe->name != NULL && pe->values != NULL ; pe++) {\\n          if (strcmp(wp->name, pe->name) == 0) {\\n            if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, pe->values[0]) != MUNIT_OK))\\n              goto cleanup;\\n          }\\n        }\\n      }\\n\\n      munit_test_runner_run_test_wild(runner, test, test_name, params, params + first_wild);\\n    } else {\\n      munit_test_runner_run_test_with_params(runner, test, params);\\n    }\\n\\n  cleanup:\\n    free(params);\\n    free(wild_params);\\n  }\\n\\n  munit_maybe_free_concat(test_name, prefix, test->name);\\n}\\n\\n/* Recurse through the suite and run all the tests.  If a list of\\n * tests to run was provied on the command line, run only those\\n * tests.  */\\nstatic void\\nmunit_test_runner_run_suite(MunitTestRunner* runner,\\n                            const MunitSuite* suite,\\n                            const char* prefix) {\\n  size_t pre_l;\\n  char* pre = munit_maybe_concat(&pre_l, (char*) prefix, (char*) suite->prefix);\\n  const MunitTest* test;\\n  const char** test_name;\\n  const MunitSuite* child_suite;\\n\\n  /* Run the tests. */\\n  for (test = suite->tests ; test != NULL && test->test != NULL ; test++) {\\n    if (runner->tests != NULL) { /* Specific tests were requested on the CLI */\\n      for (test_name = runner->tests ; test_name != NULL && *test_name != NULL ; test_name++) {\\n        if ((pre_l == 0 || strncmp(pre, *test_name, pre_l) == 0) &&\\n            strncmp(test->name, *test_name + pre_l, strlen(*test_name + pre_l)) == 0) {\\n          munit_test_runner_run_test(runner, test, pre);\\n          if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n            goto cleanup;\\n        }\\n      }\\n    } else { /* Run all tests */\\n      munit_test_runner_run_test(runner, test, pre);\\n    }\\n  }\\n\\n  if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n    goto cleanup;\\n\\n  /* Run any child suites. */\\n  for (child_suite = suite->suites ; child_suite != NULL && child_suite->prefix != NULL ; child_suite++) {\\n    munit_test_runner_run_suite(runner, child_suite, pre);\\n  }\\n\\n cleanup:\\n\\n  munit_maybe_free_concat(pre, prefix, suite->prefix);\\n}\\n\\nstatic void\\nmunit_test_runner_run(MunitTestRunner* runner) {\\n  munit_test_runner_run_suite(runner, runner->suite, NULL);\\n}\\n\\nstatic void\\nmunit_print_help(int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)], void* user_data, const MunitArgument arguments[]) {\\n  const MunitArgument* arg;\\n  (void) argc;\\n\\n  printf(\\\"USAGE: %s [OPTIONS...] [TEST...]\\\\n\\\\n\\\", argv[0]);\\n  puts(\\\" --seed SEED\\\\n\\\"\\n       \\\"           Value used to seed the PRNG.  Must be a 32-bit integer in decimal\\\\n\\\"\\n       \\\"           notation with no separators (commas, decimals, spaces, etc.), or\\\\n\\\"\\n       \\\"           hexidecimal prefixed by \\\\\\\"0x\\\\\\\".\\\\n\\\"\\n       \\\" --iterations N\\\\n\\\"\\n       \\\"           Run each test N times.  0 means the default number.\\\\n\\\"\\n       \\\" --param name value\\\\n\\\"\\n       \\\"           A parameter key/value pair which will be passed to any test with\\\\n\\\"\\n       \\\"           takes a parameter of that name.  If not provided, the test will be\\\\n\\\"\\n       \\\"           run once for each possible parameter value.\\\\n\\\"\\n       \\\" --list    Write a list of all available tests.\\\\n\\\"\\n       \\\" --list-params\\\\n\\\"\\n       \\\"           Write a list of all available tests and their possible parameters.\\\\n\\\"\\n       \\\" --single  Run each parameterized test in a single configuration instead of\\\\n\\\"\\n       \\\"           every possible combination\\\\n\\\"\\n       \\\" --log-visible debug|info|warning|error\\\\n\\\"\\n       \\\" --log-fatal debug|info|warning|error\\\\n\\\"\\n       \\\"           Set the level at which messages of different severities are visible,\\\\n\\\"\\n       \\\"           or cause the test to terminate.\\\\n\\\"\\n#if !defined(MUNIT_NO_FORK)\\n       \\\" --no-fork Do not execute tests in a child process.  If this option is supplied\\\\n\\\"\\n       \\\"           and a test crashes (including by failing an assertion), no further\\\\n\\\"\\n       \\\"           tests will be performed.\\\\n\\\"\\n#endif\\n       \\\" --fatal-failures\\\\n\\\"\\n       \\\"           Stop executing tests as soon as a failure is found.\\\\n\\\"\\n       \\\" --show-stderr\\\\n\\\"\\n       \\\"           Show data written to stderr by the tests, even if the test succeeds.\\\\n\\\"\\n       \\\" --color auto|always|never\\\\n\\\"\\n       \\\"           Colorize (or don't) the output.\\\\n\\\"\\n     /* 12345678901234567890123456789012345678901234567890123456789012345678901234567890 */\\n       \\\" --help    Print this help message and exit.\\\\n\\\");\\n#if defined(MUNIT_NL_LANGINFO)\\n  setlocale(LC_ALL, \\\"\\\");\\n  fputs((strcasecmp(\\\"UTF-8\\\", nl_langinfo(CODESET)) == 0) ? \\\"\\u00b5nit\\\" : \\\"munit\\\", stdout);\\n#else\\n  puts(\\\"munit\\\");\\n#endif\\n  printf(\\\" %d.%d.%d\\\\n\\\"\\n         \\\"Full documentation at: https://nemequ.github.io/munit/\\\\n\\\",\\n         (MUNIT_CURRENT_VERSION >> 16) & 0xff,\\n         (MUNIT_CURRENT_VERSION >> 8) & 0xff,\\n         (MUNIT_CURRENT_VERSION >> 0) & 0xff);\\n  for (arg = arguments ; arg != NULL && arg->name != NULL ; arg++)\\n    arg->write_help(arg, user_data);\\n}\\n\\nstatic const MunitArgument*\\nmunit_arguments_find(const MunitArgument arguments[], const char* name) {\\n  const MunitArgument* arg;\\n\\n  for (arg = arguments ; arg != NULL && arg->name != NULL ; arg++)\\n    if (strcmp(arg->name, name) == 0)\\n      return arg;\\n\\n  return NULL;\\n}\\n\\nstatic void\\nmunit_suite_list_tests(const MunitSuite* suite, munit_bool show_params, const char* prefix) {\\n  size_t pre_l;\\n  char* pre = munit_maybe_concat(&pre_l, (char*) prefix, (char*) suite->prefix);\\n  const MunitTest* test;\\n  const MunitParameterEnum* params;\\n  munit_bool first;\\n  char** val;\\n  const MunitSuite* child_suite;\\n\\n  for (test = suite->tests ;\\n       test != NULL && test->name != NULL ;\\n       test++) {\\n    if (pre != NULL)\\n      fputs(pre, stdout);\\n    puts(test->name);\\n\\n    if (show_params) {\\n      for (params = test->parameters ;\\n           params != NULL && params->name != NULL ;\\n           params++) {\\n        fprintf(stdout, \\\" - %s: \\\", params->name);\\n        if (params->values == NULL) {\\n          puts(\\\"Any\\\");\\n        } else {\\n          first = 1;\\n          for (val = params->values ;\\n               *val != NULL ;\\n               val++ ) {\\n            if(!first) {\\n              fputs(\\\", \\\", stdout);\\n            } else {\\n              first = 0;\\n            }\\n            fputs(*val, stdout);\\n          }\\n          putc('\\\\n', stdout);\\n        }\\n      }\\n    }\\n  }\\n\\n  for (child_suite = suite->suites ; child_suite != NULL && child_suite->prefix != NULL ; child_suite++) {\\n    munit_suite_list_tests(child_suite, show_params, pre);\\n  }\\n\\n  munit_maybe_free_concat(pre, prefix, suite->prefix);\\n}\\n\\nstatic munit_bool\\nmunit_stream_supports_ansi(FILE *stream) {\\n#if !defined(_WIN32)\\n  return isatty(fileno(stream));\\n#else\\n\\n#if !defined(__MINGW32__)\\n  size_t ansicon_size = 0;\\n#endif\\n\\n  if (isatty(fileno(stream))) {\\n#if !defined(__MINGW32__)\\n    getenv_s(&ansicon_size, NULL, 0, \\\"ANSICON\\\");\\n    return ansicon_size != 0;\\n#else\\n    return getenv(\\\"ANSICON\\\") != NULL;\\n#endif\\n  }\\n  return 0;\\n#endif\\n}\\n\\nint\\nmunit_suite_main_custom(const MunitSuite* suite, void* user_data,\\n                        int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)],\\n                        const MunitArgument arguments[]) {\\n  int result = EXIT_FAILURE;\\n  MunitTestRunner runner;\\n  size_t parameters_size = 0;\\n  size_t tests_size = 0;\\n  int arg;\\n\\n  char* envptr;\\n  unsigned long ts;\\n  char* endptr;\\n  unsigned long long iterations;\\n  MunitLogLevel level;\\n  const MunitArgument* argument;\\n  const char** runner_tests;\\n  unsigned int tests_run;\\n  unsigned int tests_total;\\n\\n  runner.prefix = NULL;\\n  runner.suite = NULL;\\n  runner.tests = NULL;\\n  runner.seed = 0;\\n  runner.iterations = 0;\\n  runner.parameters = NULL;\\n  runner.single_parameter_mode = 0;\\n  runner.user_data = NULL;\\n\\n  runner.report.successful = 0;\\n  runner.report.skipped = 0;\\n  runner.report.failed = 0;\\n  runner.report.errored = 0;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  runner.report.cpu_clock = 0;\\n  runner.report.wall_clock = 0;\\n#endif\\n\\n  runner.colorize = 0;\\n#if !defined(_WIN32)\\n  runner.fork = 1;\\n#else\\n  runner.fork = 0;\\n#endif\\n  runner.show_stderr = 0;\\n  runner.fatal_failures = 0;\\n  runner.suite = suite;\\n  runner.user_data = user_data;\\n  runner.seed = munit_rand_generate_seed();\\n  runner.colorize = munit_stream_supports_ansi(MUNIT_OUTPUT_FILE);\\n\\n  for (arg = 1 ; arg < argc ; arg++) {\\n    if (strncmp(\\\"--\\\", argv[arg], 2) == 0) {\\n      if (strcmp(\\\"seed\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        envptr = argv[arg + 1];\\n        ts = strtoul(argv[arg + 1], &envptr, 0);\\n        if (*envptr != '\\\\0' || ts > (~((munit_uint32_t) 0U))) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n        runner.seed = (munit_uint32_t) ts;\\n\\n        arg++;\\n      } else if (strcmp(\\\"iterations\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        endptr = argv[arg + 1];\\n        iterations = strtoul(argv[arg + 1], &endptr, 0);\\n        if (*endptr != '\\\\0' || iterations > UINT_MAX) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        runner.iterations = (unsigned int) iterations;\\n\\n        arg++;\\n      } else if (strcmp(\\\"param\\\", argv[arg] + 2) == 0) {\\n        if (arg + 2 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires two arguments\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        runner.parameters = realloc(runner.parameters, sizeof(MunitParameter) * (parameters_size + 2));\\n        if (runner.parameters == NULL) {\\n          munit_log_internal(MUNIT_LOG_ERROR, stderr, \\\"failed to allocate memory\\\");\\n          goto cleanup;\\n        }\\n        runner.parameters[parameters_size].name = (char*) argv[arg + 1];\\n        runner.parameters[parameters_size].value = (char*) argv[arg + 2];\\n        parameters_size++;\\n        runner.parameters[parameters_size].name = NULL;\\n        runner.parameters[parameters_size].value = NULL;\\n        arg += 2;\\n      } else if (strcmp(\\\"color\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(argv[arg + 1], \\\"always\\\") == 0)\\n          runner.colorize = 1;\\n        else if (strcmp(argv[arg + 1], \\\"never\\\") == 0)\\n          runner.colorize = 0;\\n        else if (strcmp(argv[arg + 1], \\\"auto\\\") == 0)\\n          runner.colorize = munit_stream_supports_ansi(MUNIT_OUTPUT_FILE);\\n        else {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        arg++;\\n      } else if (strcmp(\\\"help\\\", argv[arg] + 2) == 0) {\\n        munit_print_help(argc, argv, user_data, arguments);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else if (strcmp(\\\"single\\\", argv[arg] + 2) == 0) {\\n        runner.single_parameter_mode = 1;\\n      } else if (strcmp(\\\"show-stderr\\\", argv[arg] + 2) == 0) {\\n        runner.show_stderr = 1;\\n#if !defined(_WIN32)\\n      } else if (strcmp(\\\"no-fork\\\", argv[arg] + 2) == 0) {\\n        runner.fork = 0;\\n#endif\\n      } else if (strcmp(\\\"fatal-failures\\\", argv[arg] + 2) == 0) {\\n        runner.fatal_failures = 1;\\n      } else if (strcmp(\\\"log-visible\\\", argv[arg] + 2) == 0 ||\\n                 strcmp(\\\"log-fatal\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(argv[arg + 1], \\\"debug\\\") == 0)\\n          level = MUNIT_LOG_DEBUG;\\n        else if (strcmp(argv[arg + 1], \\\"info\\\") == 0)\\n          level = MUNIT_LOG_INFO;\\n        else if (strcmp(argv[arg + 1], \\\"warning\\\") == 0)\\n          level = MUNIT_LOG_WARNING;\\n        else if (strcmp(argv[arg + 1], \\\"error\\\") == 0)\\n          level = MUNIT_LOG_ERROR;\\n        else {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(\\\"log-visible\\\", argv[arg] + 2) == 0)\\n          munit_log_level_visible = level;\\n        else\\n          munit_log_level_fatal = level;\\n\\n        arg++;\\n      } else if (strcmp(\\\"list\\\", argv[arg] + 2) == 0) {\\n        munit_suite_list_tests(suite, 0, NULL);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else if (strcmp(\\\"list-params\\\", argv[arg] + 2) == 0) {\\n        munit_suite_list_tests(suite, 1, NULL);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else {\\n        argument = munit_arguments_find(arguments, argv[arg] + 2);\\n        if (argument == NULL) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"unknown argument ('%s')\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (!argument->parse_argument(suite, user_data, &arg, argc, argv))\\n          goto cleanup;\\n      }\\n    } else {\\n      runner_tests = realloc((void*) runner.tests, sizeof(char*) * (tests_size + 2));\\n      if (runner_tests == NULL) {\\n        munit_log_internal(MUNIT_LOG_ERROR, stderr, \\\"failed to allocate memory\\\");\\n        goto cleanup;\\n      }\\n      runner.tests = runner_tests;\\n      runner.tests[tests_size++] = argv[arg];\\n      runner.tests[tests_size] = NULL;\\n    }\\n  }\\n\\n  fflush(stderr);\\n  fprintf(MUNIT_OUTPUT_FILE, \\\"Running test suite with seed 0x%08\\\" PRIx32 \\\"...\\\\n\\\", runner.seed);\\n\\n  munit_test_runner_run(&runner);\\n\\n  tests_run = runner.report.successful + runner.report.failed + runner.report.errored;\\n  tests_total = tests_run + runner.report.skipped;\\n  if (tests_run == 0) {\\n    fprintf(stderr, \\\"No tests run, %d (100%%) skipped.\\\\n\\\", runner.report.skipped);\\n  } else {\\n    fprintf(MUNIT_OUTPUT_FILE, \\\"%d of %d (%0.0f%%) tests successful, %d (%0.0f%%) test skipped.\\\\n\\\",\\n            runner.report.successful, tests_run,\\n            (((double) runner.report.successful) / ((double) tests_run)) * 100.0,\\n            runner.report.skipped,\\n            (((double) runner.report.skipped) / ((double) tests_total)) * 100.0);\\n  }\\n\\n  if (runner.report.failed == 0 && runner.report.errored == 0) {\\n    result = EXIT_SUCCESS;\\n  }\\n\\n cleanup:\\n  free(runner.parameters);\\n  free((void*) runner.tests);\\n\\n  return result;\\n}\\n\\nint\\nmunit_suite_main(const MunitSuite* suite, void* user_data,\\n                 int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)]) {\\n  return munit_suite_main_custom(suite, user_data, argc, argv, NULL);\\n}\\n\", \"embeddings\": [0.0317634642124176, 0.04769979417324066, -0.004556868225336075, 0.08906365931034088, 0.2714909017086029, -0.27398407459259033, 0.06475367397069931, 0.23394057154655457, 0.06332262605428696, -0.167016863822937, 0.030474789440631866, -0.11867465823888779, -0.05519425868988037, 0.10167211294174194, 0.07572411745786667, 0.008201494812965393, -0.07045105844736099, -0.06966882199048996, 0.21709099411964417, -0.14358127117156982, -0.16218189895153046, -0.02676495909690857, 0.13547289371490479, 0.1947576254606247, 0.20444628596305847, -0.017920780926942825, 0.21737132966518402, 0.09578816592693329, 0.20741748809814453, -0.17123687267303467, 0.06585288792848587, -0.032632000744342804, 0.04254211485385895, -0.13927489519119263, 0.009991314262151718, -0.015708163380622864, 0.10208702087402344, 0.005036003887653351, -0.06368251144886017, 0.06234148144721985, -0.14345797896385193, 0.021485567092895508, 0.1424289047718048, 0.15245060622692108, 0.03320203721523285, -0.020847953855991364, 0.06294584274291992, 0.25715377926826477, -0.06275670230388641, -0.007926363497972488, 0.05774309113621712, 0.02875524014234543, -0.05618848651647568, -0.011109523475170135, -0.1382739096879959, -0.09992531687021255, 0.03900156915187836, 0.2493017613887787, 0.018343184143304825, -0.05325707048177719, -0.12882216274738312, -0.060886651277542114, -0.06589079648256302, 0.04187711700797081, 0.022697806358337402, 0.0032276026904582977, -0.16531319916248322, -0.06396308541297913, -0.01726507768034935, 0.03202010318636894, 0.04139956459403038, -0.00198434479534626, 0.08874498307704926, -0.12791571021080017, -0.061243295669555664, -0.020994484424591064, 0.0965772420167923, 0.6339005827903748, -0.08902585506439209, 0.08153524994850159, 0.2475351095199585, -0.02005086839199066, 0.2006533443927765, 0.07229845225811005, 0.038157422095537186, -0.03526415675878525, -0.052170053124427795, 0.03482608124613762, 0.09455734491348267, 0.11339545249938965, 0.05341550335288048, 0.10926005244255066, -0.10574380308389664, 0.04274600371718407, 0.0421096496284008, -0.03089410439133644, 0.07685323804616928, -0.1948731690645218, 0.05952364206314087, 0.28194528818130493, -0.1505919247865677, -0.08293260633945465, -0.11983747035264969, 0.030776608735322952, -0.07756458967924118, 0.04168703407049179, 0.10883750021457672, 0.02869991585612297, 0.07319184392690659, -0.042939960956573486, -0.020245440304279327, 0.03579585999250412, -0.01512894220650196, 0.031202547252178192, -0.05106804519891739, -0.11553145200014114, 0.05393929407000542, -0.02554534375667572, 0.09244804829359055, 0.001873508095741272, 0.09286949038505554, 0.0661906823515892, -0.027140222489833832, -0.07200722396373749, 0.017402928322553635, 0.14265891909599304, 0.02075352519750595, -0.13154414296150208, 0.11597533524036407, 0.12365605682134628, -0.014049381017684937, -0.12633809447288513, 0.07662830501794815, 0.06305094063282013, 0.23582935333251953, -0.021182004362344742, -0.019930601119995117, 0.027228113263845444, -0.055391259491443634, 0.04080520570278168, -0.022854894399642944, 0.036707572638988495, 0.29926544427871704, -0.10639193654060364, 0.18567368388175964, -0.09859265387058258, 0.04119517654180527, 0.10670901834964752, -0.20885466039180756, -0.18293699622154236, 0.08664125949144363, -0.04035167023539543, 0.018019767478108406, 0.07556872069835663, -0.22876057028770447, 0.8173025250434875, 0.19581851363182068, -0.025382250547409058, 0.009856246411800385, 0.053369514644145966, 0.07621873915195465, -0.18213100731372833, -0.03611965477466583, 0.0588998906314373, 0.0677666887640953, 0.12340673059225082, 0.07191812992095947, 0.09672105312347412, 0.05132449418306351, -0.09747231006622314, 0.08650924265384674, -0.0523848682641983, -0.08145267516374588, 0.15421053767204285, 0.0009364187717437744, -0.15921291708946228, -0.16468362510204315, 0.035304777324199677, -0.10351655632257462, -0.014417745172977448, -0.010565139353275299, 0.04853558540344238, -0.1397944539785385, -0.0610465407371521, 0.026474036276340485, 0.03613942116498947, 0.13110393285751343, -0.15038229525089264, 0.08062869310379028, 0.03416440635919571, 0.00034580007195472717, 0.07228493690490723, 0.09537334740161896, 0.026633813977241516, -0.03046555072069168, 0.14885638654232025, -0.12409991770982742, -0.09566576033830643, 0.10967228561639786, -0.021348431706428528, -0.008782874792814255, -0.04877644404768944, 0.13509900867938995, -0.10114988684654236, 0.13117119669914246, 0.12716619670391083, -0.16239714622497559, 0.06346260756254196, 0.038014017045497894, -0.11410754173994064, -0.03561894968152046, 0.132798969745636, 0.0983012393116951, 0.04051465541124344, -0.06969539821147919, -0.08921290189027786, 0.07880742102861404, 0.04368288069963455, -0.006480071693658829, -0.14167416095733643, 0.23231080174446106, 0.24592241644859314, -0.1188783124089241, -0.0149993896484375, -0.053112998604774475, 0.1914239227771759, 0.19268633425235748, 0.012778952717781067, -0.02381662279367447, 0.026766277849674225, 0.2265470176935196, 0.11011425405740738, -0.07868511974811554, 0.081406369805336, 0.1258685141801834, -0.15788505971431732, -0.07117904722690582, 0.009144499897956848, 0.021234482526779175, -0.05575546249747276, -0.011208850890398026, 0.14386259019374847, 0.1420123428106308, 0.3291088044643402, 0.045228563249111176, 0.09546004980802536, -0.1403844952583313, -0.1210867166519165, -0.034774601459503174, -0.01774107664823532, -0.0995272770524025, -0.0012000766582787037, 0.0279877670109272, -0.04363098368048668, -0.11060203611850739, -0.024558227509260178, -0.19675341248512268, 0.05112975090742111, 0.03368590399622917, 0.10256943851709366, -0.036765895783901215, -0.08733697980642319, 0.026559989899396896, 0.030399907380342484, -0.11232554167509079, -0.29349133372306824, -0.01177118718624115, 0.07939524948596954, -0.02993815392255783, 0.04132726415991783, 0.03819797933101654, -0.01381591334939003, 0.21559357643127441, 0.10657594352960587, -0.014850355684757233, -0.039894089102745056, -0.06511366367340088, 0.0599716491997242, -0.11050038039684296, 0.008408702909946442, -0.08069473505020142, 0.10181097686290741, -0.06242566928267479, 0.08685778081417084, -0.06148434802889824, 0.015228801406919956, -0.022012270987033844, -0.07455147057771683, 0.03489396721124649, 0.05656510591506958, 0.060366079211235046, 0.07799762487411499, 0.014495188370347023, 0.1260719895362854, -0.047358185052871704, 0.10516436398029327, 0.13915051519870758, -0.04760967195034027, 0.0765632912516594, -0.19902613759040833, 0.009788304567337036, -0.20049245655536652, -0.03480290621519089, -0.11695259809494019, 0.33536481857299805, -0.13053153455257416, 0.06906525045633316, -0.008432731032371521, 0.24061958491802216, -0.024611417204141617, 0.08391215652227402, 0.04648512601852417, -0.15902571380138397, 0.19571149349212646, -0.14923258125782013, 0.004373673349618912, -0.03951127082109451, -0.09122394025325775, 0.004733040928840637, -0.004337295889854431, -0.0560024194419384, 0.09094143658876419, 0.10988940298557281, 0.09709256887435913, -0.029674850404262543, 0.18857450783252716, 0.07008330523967743, 0.016056343913078308, -0.007925063371658325, 0.8167269229888916, -0.5071113705635071, 0.1363886594772339, -0.17730845510959625, 0.20443543791770935, -0.005883865058422089, 0.1907409131526947, -0.0789346918463707, 0.06016620993614197, 0.13663959503173828, 0.1365869641304016, -0.06365536153316498, -0.06434662640094757, -0.09535107016563416, 0.21445904672145844, 0.08130738139152527, 0.12720495462417603, 0.08535566926002502, -0.07747757434844971, 0.06156348064541817, -0.13301604986190796, -0.11070220172405243, 0.12067805975675583, 0.08954085409641266, -0.20165446400642395, 0.06146073713898659, 0.2707768380641937, -0.028870828449726105, -0.07044859230518341, 0.020701350644230843, 0.21430812776088715, 0.09727989137172699, -0.09826620668172836, 0.051371462643146515, -0.07371163368225098, 0.19546933472156525, -0.30767831206321716, -0.2229170799255371, 0.04854166507720947, -0.082990363240242, 0.09728185087442398, 0.06479935348033905, 0.3284238576889038, 0.041492775082588196, -0.09359429776668549, 0.05635002255439758, 0.011817362159490585, 0.00828501209616661, 0.0071315765380859375, 0.03484976664185524, 0.14339463412761688, 0.04701298102736473, 0.09450793266296387, 0.017074620351195335, 0.011993398889899254, -0.010298185050487518, -0.17860376834869385, 0.16728787124156952, 0.09434019029140472, 0.13214941322803497, -0.08411914110183716, 0.06829852610826492, -0.038994088768959045, -0.0691276490688324, 0.05221424251794815, 0.03106120228767395, 0.07979392260313034, -0.10951460897922516, 0.09256263077259064, -0.13903692364692688, -0.08132980763912201, 0.1311836689710617, 0.029064632952213287, -0.003871578723192215, 0.04288579896092415, 0.15052807331085205, 0.1181836798787117, 0.002558843931183219, -0.1273733377456665, -0.10346540808677673, -0.24066591262817383, 0.028153154999017715, 0.08433160930871964, 0.07622890919446945, -0.031191572546958923, 0.09438499063253403, -0.10514526069164276, -0.033333662897348404, -0.18604426085948944, -0.044412679970264435, 0.14158353209495544, 0.10699354112148285, 0.15341255068778992, 0.02050265669822693, -0.07174498587846756, 0.01970105990767479, 0.008230498060584068, -0.0063051506876945496, -0.0760674774646759, 0.0851447731256485, -0.13596850633621216, 0.08566673845052719, 0.3167436718940735, 0.0991147831082344, 0.02761485055088997, 0.04864009469747543, -0.038202524185180664, -0.18961741030216217, 0.031449634581804276, 0.00951891578733921, 0.012849098071455956, -0.020357701927423477, 0.0002881735563278198, 0.07457208633422852, 0.08814594149589539, 0.03256014734506607, -0.14767470955848694, 0.2878514528274536, 0.057304538786411285, -0.09087304770946503, 0.16556316614151, -0.09243279695510864, 0.006941936910152435, -0.11345329880714417, -0.39441367983818054, 0.06359641999006271, 0.10788112133741379, 0.13513386249542236, 0.07587490975856781, 0.062200676649808884, -0.03026401996612549, 0.012477129697799683, 0.12710461020469666, -0.07326629757881165, -0.13183684647083282, 0.039785515516996384, 0.013251900672912598, 0.12033899128437042, 0.09168636053800583, 0.10287678241729736, 0.11273114383220673, -0.015649303793907166, 0.1296701431274414, -0.03630933165550232, -0.21661777794361115, 0.021433308720588684, 0.03150307759642601, -0.06881292909383774, -0.09916144609451294, 0.05680286884307861, -0.20854726433753967, -0.08431205153465271, 0.09333297610282898, 0.2044030874967575, 0.05418629199266434, 0.01556506659835577, -0.07772824913263321, 0.19210289418697357, 0.1276039332151413, -0.06718319654464722, 0.023282673209905624, -0.0013770987279713154, 0.018191182985901833, 0.008739128708839417, 0.10366160422563553, 0.2694171071052551, 0.10939516127109528, 0.13396897912025452, 0.07556384801864624, 0.203630268573761, -0.09710283577442169, 0.018826693296432495, 0.1049785390496254, 0.04116059094667435, -0.10966749489307404, -0.0384640209376812, -0.04512321203947067, -0.043690167367458344, 0.09369827806949615, 0.03648621588945389, -0.1356988251209259, -0.044479407370090485, -0.13574665784835815, 0.07152452319860458, 0.01044296845793724, 0.023533973842859268, -0.05069362372159958, 0.047447845339775085, 0.040973000228405, 0.06918645650148392, 0.22032472491264343, -0.19238194823265076, -0.08837500214576721, -0.05201886221766472, 0.02445761114358902, -0.14028458297252655, 0.03139197453856468, 0.17584939301013947, -0.08312871307134628, 0.09060810506343842, 0.0665566548705101, 0.11351284384727478, 0.02518879622220993, 0.08992341160774231, 0.11306310445070267, -0.01935723051428795, 0.060257717967033386, 0.027700789272785187, -0.06488879024982452, 0.11099760234355927, 0.029130931943655014, -0.2097647339105606, -0.11142352968454361, 0.10575620830059052, -0.014021079987287521, 0.13341516256332397, 0.0060158297419548035, 0.1445404291152954, 0.034345194697380066, -0.009077709168195724, 0.028453432023525238, -0.0018390640616416931, -0.7963047623634338, 0.019522564485669136, 0.1188836619257927, 0.01664540357887745, 0.03697815164923668, 0.13519953191280365, 0.007124107331037521, 0.09201887249946594, 0.0861918181180954, 0.12652704119682312, 0.031477026641368866, 0.1395339071750641, 0.17391452193260193, -0.05222388356924057, 0.005208216607570648, 0.0745583102107048, 0.06721781939268112, -0.2139585316181183, 0.08802608400583267, -0.052492655813694, -0.02366676926612854, 0.06165861710906029, 0.2391381561756134, -0.09808406978845596, 0.0919095054268837, 0.24238629639148712, 0.003201674669981003, 0.14681574702262878, -0.10076652467250824, 0.12368587404489517, 0.2506990134716034, 0.04116523265838623, -0.201750248670578, 0.05147763341665268, 0.12341611832380295, 0.17077377438545227, 0.1650778353214264, 13.761828422546387, -0.10597042739391327, 0.16575929522514343, -0.005728140473365784, 0.002897024154663086, -0.06138152629137039, -0.0612867996096611, 0.0018833428621292114, -0.04770611226558685, 0.023496199399232864, 0.11650919914245605, -0.06950048357248306, 0.04532722383737564, 0.08322498202323914, -0.04553339630365372, -0.08493739366531372, -0.0056341178715229034, 0.008050987496972084, 0.13982102274894714, 0.0702676922082901, -0.00772181898355484, -0.058344677090644836, 0.022687610238790512, -0.13174082338809967, -0.004012858495116234, 0.06356093287467957, 0.2081725001335144, 0.11150186508893967, 0.018679505214095116, 0.04127679020166397, 0.15331654250621796, 0.18795934319496155, 0.10617801547050476, 0.002341128885746002, 0.00791466236114502, -0.2029571831226349, -0.3819624185562134, -0.12469317764043808, 0.06211245059967041, 0.05970467999577522, -0.025142081081867218, -0.014350958168506622, 0.14783066511154175, 0.01717105135321617, 0.04876096174120903, 0.026546210050582886, -0.13230246305465698, 0.18370209634304047, -0.10298966616392136, -0.07444974780082703, 0.19251057505607605, 0.07459737360477448, 0.20392805337905884, 0.009242646396160126, -0.12269710749387741, -0.09339740872383118, 0.25671568512916565, 0.013232331722974777, 0.09411292523145676, 0.21659791469573975, -0.022346287965774536, 0.008385680615901947, -0.05805129185318947, -0.0430455319583416, -0.0879298746585846, 0.013708136975765228, 0.08854658156633377, 0.041575945913791656, 0.054640017449855804, 0.06924702227115631, 0.13179194927215576, -0.07019767165184021, 0.020949475467205048, 0.046371255069971085, -0.023232966661453247, 0.06388616561889648, -0.11412142962217331, 0.04511301964521408, 0.05539409816265106, -0.2161800116300583, -0.033643633127212524, 0.029143329709768295, -0.19743694365024567, 0.007893864065408707, -0.13420352339744568, 0.1271428018808365, -0.10056822001934052, 0.20845848321914673, 0.08013273775577545, 0.016021935269236565, -0.13884136080741882, 0.03887615725398064, 0.06242220103740692, -0.16451218724250793, 0.1514427661895752, -0.07738465815782547, 0.09406424313783646, -0.21262650191783905, 0.08865009248256683, 0.10386527329683304, -0.010064654052257538, -0.10267436504364014, 0.050216786563396454, 0.12704437971115112, -0.11230915784835815, 0.072384312748909, -0.023190252482891083, -0.061538368463516235, -0.02965281903743744, 0.09408080577850342, 0.02875981107354164, 0.07882676273584366, 0.07368786633014679, -0.22853372991085052, 0.007331561297178268, -0.021908313035964966, 0.04046459496021271, 0.03643861413002014, 0.22701387107372284, 0.13320545852184296, 0.11560681462287903, -0.003678068518638611, -0.1283663958311081, -0.004803292453289032, 0.056136708706617355, -0.012780530378222466, 0.03149069845676422, 0.19676627218723297, 0.03083527460694313, -0.055607471615076065, 0.04245387390255928, -0.05841069668531418, 0.21222366392612457, 0.16777683794498444, 0.0026987940073013306, 0.012862324714660645, 0.02425428479909897, 0.04850892350077629, 0.14430786669254303, 0.16006684303283691, 0.06219851225614548, 0.07219155877828598, 0.17429287731647491, -0.14677967131137848, -0.07696361839771271, 0.15401509404182434, 0.13688553869724274, 0.026451628655195236, -0.004254493862390518, 0.1801169216632843, 0.16212479770183563, 0.12368623912334442, -0.006337778642773628, -0.12073980271816254, -0.07322812080383301, -0.16765737533569336, -0.05444299802184105, 0.13863597810268402, -0.06414780020713806, -0.11952119320631027, 0.21864187717437744, -0.3095400631427765, 0.0026144522707909346, -0.2338208258152008, -0.08043930679559708, 0.05971293896436691, 0.10154403001070023, 0.06919167935848236, 0.12847408652305603, -0.18834665417671204, 0.11603032052516937, -0.019969353452324867, -0.17339862883090973, 0.05705885589122772, 0.002430275082588196, 0.0851898342370987, 0.13332368433475494, -0.270045667886734, -0.10392578691244125, 0.06906077265739441]}"
"{\"sha\": \"00ede07ca6c77e3b71aaa699b2c48b9718700cc8\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"test/unit/munit.c\", \"func_name\": \"munit_parameters_add\", \"original_string\": \"static MunitResult\\nmunit_parameters_add(size_t* params_size, MunitParameter* params[MUNIT_ARRAY_PARAM(*params_size)], char* name, char* value) {\\n  *params = realloc(*params, sizeof(MunitParameter) * (*params_size + 2));\\n  if (*params == NULL)\\n    return MUNIT_ERROR;\\n\\n  (*params)[*params_size].name = name;\\n  (*params)[*params_size].value = value;\\n  (*params_size)++;\\n  (*params)[*params_size].name = NULL;\\n  (*params)[*params_size].value = NULL;\\n\\n  return MUNIT_OK;\\n}\", \"code_tokens\": [\"static\", \"MunitResult\", \"munit_parameters_add\", \"(\", \"size_t\", \"*\", \"params_size\", \",\", \"MunitParameter\", \"*\", \"params\", \"[\", \"MUNIT_ARRAY_PARAM\", \"(\", \"*\", \"params_size\", \")\", \"]\", \",\", \"char\", \"*\", \"name\", \",\", \"char\", \"*\", \"value\", \")\", \"{\", \"*\", \"params\", \"=\", \"realloc\", \"(\", \"*\", \"params\", \",\", \"sizeof\", \"(\", \"MunitParameter\", \")\", \"*\", \"(\", \"*\", \"params_size\", \"+\", \"2\", \")\", \")\", \";\", \"if\", \"(\", \"*\", \"params\", \"==\", \"NULL\", \")\", \"return\", \"MUNIT_ERROR\", \";\", \"(\", \"*\", \"params\", \")\", \"[\", \"*\", \"params_size\", \"]\", \".\", \"name\", \"=\", \"name\", \";\", \"(\", \"*\", \"params\", \")\", \"[\", \"*\", \"params_size\", \"]\", \".\", \"value\", \"=\", \"value\", \";\", \"(\", \"*\", \"params_size\", \")\", \"++\", \";\", \"(\", \"*\", \"params\", \")\", \"[\", \"*\", \"params_size\", \"]\", \".\", \"name\", \"=\", \"NULL\", \";\", \"(\", \"*\", \"params\", \")\", \"[\", \"*\", \"params_size\", \"]\", \".\", \"value\", \"=\", \"NULL\", \";\", \"return\", \"MUNIT_OK\", \";\", \"}\"], \"docstring\": \"/* Add a paramter to an array of parameters. */\", \"docstring_tokens\": [\"/\", \"*\", \"Add\", \"a\", \"paramter\", \"to\", \"an\", \"array\", \"of\", \"parameters\", \".\", \"*\", \"/\"], \"raw_contents\": \"/* Copyright (c) 2013-2018 Evan Nemerson <evan@nemerson.com>\\n *\\n * Permission is hereby granted, free of charge, to any person\\n * obtaining a copy of this software and associated documentation\\n * files (the \\\"Software\\\"), to deal in the Software without\\n * restriction, including without limitation the rights to use, copy,\\n * modify, merge, publish, distribute, sublicense, and/or sell copies\\n * of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be\\n * included in all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND,\\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n * SOFTWARE.\\n */\\n\\n/*** Configuration ***/\\n\\n/* This is just where the output from the test goes.  It's really just\\n * meant to let you choose stdout or stderr, but if anyone really want\\n * to direct it to a file let me know, it would be fairly easy to\\n * support. */\\n#if !defined(MUNIT_OUTPUT_FILE)\\n#  define MUNIT_OUTPUT_FILE stdout\\n#endif\\n\\n/* This is a bit more useful; it tells \\u00b5nit how to format the seconds in\\n * timed tests.  If your tests run for longer you might want to reduce\\n * it, and if your computer is really fast and your tests are tiny you\\n * can increase it. */\\n#if !defined(MUNIT_TEST_TIME_FORMAT)\\n#  define MUNIT_TEST_TIME_FORMAT \\\"0.8f\\\"\\n#endif\\n\\n/* If you have long test names you might want to consider bumping\\n * this.  The result information takes 43 characters. */\\n#if !defined(MUNIT_TEST_NAME_LEN)\\n#  define MUNIT_TEST_NAME_LEN 37\\n#endif\\n\\n/* If you don't like the timing information, you can disable it by\\n * defining MUNIT_DISABLE_TIMING. */\\n#if !defined(MUNIT_DISABLE_TIMING)\\n#  define MUNIT_ENABLE_TIMING\\n#endif\\n\\n/*** End configuration ***/\\n\\n#if defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE < 200809L)\\n#  undef _POSIX_C_SOURCE\\n#endif\\n#if !defined(_POSIX_C_SOURCE)\\n#  define _POSIX_C_SOURCE 200809L\\n#endif\\n\\n/* Solaris freaks out if you try to use a POSIX or SUS standard without\\n * the \\\"right\\\" C standard. */\\n#if defined(_XOPEN_SOURCE)\\n#  undef _XOPEN_SOURCE\\n#endif\\n\\n#if defined(__STDC_VERSION__)\\n#  if __STDC_VERSION__ >= 201112L\\n#    define _XOPEN_SOURCE 700\\n#  elif __STDC_VERSION__ >= 199901L\\n#    define _XOPEN_SOURCE 600\\n#  endif\\n#endif\\n\\n/* Because, according to Microsoft, POSIX is deprecated.  You've got\\n * to appreciate the chutzpah. */\\n#if defined(_MSC_VER) && !defined(_CRT_NONSTDC_NO_DEPRECATE)\\n#  define _CRT_NONSTDC_NO_DEPRECATE\\n#endif\\n\\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\\n#  include <stdbool.h>\\n#elif defined(_WIN32)\\n/* https://msdn.microsoft.com/en-us/library/tf4dy80a.aspx */\\n#endif\\n\\n#include <limits.h>\\n#include <time.h>\\n#include <errno.h>\\n#include <string.h>\\n#include <stdlib.h>\\n#include <stdio.h>\\n#include <stdarg.h>\\n#include <setjmp.h>\\n\\n#if !defined(MUNIT_NO_NL_LANGINFO) && !defined(_WIN32)\\n#define MUNIT_NL_LANGINFO\\n#include <locale.h>\\n#include <langinfo.h>\\n#include <strings.h>\\n#endif\\n\\n#if !defined(_WIN32)\\n#  include <unistd.h>\\n#  include <sys/types.h>\\n#  include <sys/wait.h>\\n#else\\n#  include <windows.h>\\n#  include <io.h>\\n#  include <fcntl.h>\\n#  if !defined(STDERR_FILENO)\\n#    define STDERR_FILENO _fileno(stderr)\\n#  endif\\n#endif\\n\\n#include \\\"munit.h\\\"\\n\\n#define MUNIT_STRINGIFY(x) #x\\n#define MUNIT_XSTRINGIFY(x) MUNIT_STRINGIFY(x)\\n\\n#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__SUNPRO_CC) || defined(__IBMCPP__)\\n#  define MUNIT_THREAD_LOCAL __thread\\n#elif (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201102L)) || defined(_Thread_local)\\n#  define MUNIT_THREAD_LOCAL _Thread_local\\n#elif defined(_WIN32)\\n#  define MUNIT_THREAD_LOCAL __declspec(thread)\\n#endif\\n\\n/* MSVC 12.0 will emit a warning at /W4 for code like 'do { ... }\\n * while (0)', or 'do { ... } while (1)'.  I'm pretty sure nobody\\n * at Microsoft compiles with /W4. */\\n#if defined(_MSC_VER) && (_MSC_VER <= 1800)\\n#pragma warning(disable: 4127)\\n#endif\\n\\n#if defined(_WIN32) || defined(__EMSCRIPTEN__)\\n#  define MUNIT_NO_FORK\\n#endif\\n\\n#if defined(__EMSCRIPTEN__)\\n#  define MUNIT_NO_BUFFER\\n#endif\\n\\n/*** Logging ***/\\n\\nstatic MunitLogLevel munit_log_level_visible = MUNIT_LOG_INFO;\\nstatic MunitLogLevel munit_log_level_fatal = MUNIT_LOG_ERROR;\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\nstatic MUNIT_THREAD_LOCAL munit_bool munit_error_jmp_buf_valid = 0;\\nstatic MUNIT_THREAD_LOCAL jmp_buf munit_error_jmp_buf;\\n#endif\\n\\n/* At certain warning levels, mingw will trigger warnings about\\n * suggesting the format attribute, which we've explicity *not* set\\n * because it will then choke on our attempts to use the MS-specific\\n * I64 modifier for size_t (which we have to use since MSVC doesn't\\n * support the C99 z modifier). */\\n\\n#if defined(__MINGW32__) || defined(__MINGW64__)\\n#  pragma GCC diagnostic push\\n#  pragma GCC diagnostic ignored \\\"-Wsuggest-attribute=format\\\"\\n#endif\\n\\nMUNIT_PRINTF(5,0)\\nstatic void\\nmunit_logf_exv(MunitLogLevel level, FILE* fp, const char* filename, int line, const char* format, va_list ap) {\\n  if (level < munit_log_level_visible)\\n    return;\\n\\n  switch (level) {\\n    case MUNIT_LOG_DEBUG:\\n      fputs(\\\"Debug\\\", fp);\\n      break;\\n    case MUNIT_LOG_INFO:\\n      fputs(\\\"Info\\\", fp);\\n      break;\\n    case MUNIT_LOG_WARNING:\\n      fputs(\\\"Warning\\\", fp);\\n      break;\\n    case MUNIT_LOG_ERROR:\\n      fputs(\\\"Error\\\", fp);\\n      break;\\n    default:\\n      munit_logf_ex(MUNIT_LOG_ERROR, filename, line, \\\"Invalid log level (%d)\\\", level);\\n      return;\\n  }\\n\\n  fputs(\\\": \\\", fp);\\n  if (filename != NULL)\\n    fprintf(fp, \\\"%s:%d: \\\", filename, line);\\n  vfprintf(fp, format, ap);\\n  fputc('\\\\n', fp);\\n}\\n\\nMUNIT_PRINTF(3,4)\\nstatic void\\nmunit_logf_internal(MunitLogLevel level, FILE* fp, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(level, fp, NULL, 0, format, ap);\\n  va_end(ap);\\n}\\n\\nstatic void\\nmunit_log_internal(MunitLogLevel level, FILE* fp, const char* message) {\\n  munit_logf_internal(level, fp, \\\"%s\\\", message);\\n}\\n\\nvoid\\nmunit_logf_ex(MunitLogLevel level, const char* filename, int line, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(level, stderr, filename, line, format, ap);\\n  va_end(ap);\\n\\n  if (level >= munit_log_level_fatal) {\\n#if defined(MUNIT_THREAD_LOCAL)\\n    if (munit_error_jmp_buf_valid)\\n      longjmp(munit_error_jmp_buf, 1);\\n#endif\\n    abort();\\n  }\\n}\\n\\nvoid\\nmunit_errorf_ex(const char* filename, int line, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(MUNIT_LOG_ERROR, stderr, filename, line, format, ap);\\n  va_end(ap);\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\n  if (munit_error_jmp_buf_valid)\\n    longjmp(munit_error_jmp_buf, 1);\\n#endif\\n  abort();\\n}\\n\\n#if defined(__MINGW32__) || defined(__MINGW64__)\\n#pragma GCC diagnostic pop\\n#endif\\n\\n#if !defined(MUNIT_STRERROR_LEN)\\n#  define MUNIT_STRERROR_LEN 80\\n#endif\\n\\nstatic void\\nmunit_log_errno(MunitLogLevel level, FILE* fp, const char* msg) {\\n#if defined(MUNIT_NO_STRERROR_R) || (defined(__MINGW32__) && !defined(MINGW_HAS_SECURE_API))\\n  munit_logf_internal(level, fp, \\\"%s: %s (%d)\\\", msg, strerror(errno), errno);\\n#else\\n  char munit_error_str[MUNIT_STRERROR_LEN];\\n  munit_error_str[0] = '\\\\0';\\n\\n#if !defined(_WIN32)\\n  strerror_r(errno, munit_error_str, MUNIT_STRERROR_LEN);\\n#else\\n  strerror_s(munit_error_str, MUNIT_STRERROR_LEN, errno);\\n#endif\\n\\n  munit_logf_internal(level, fp, \\\"%s: %s (%d)\\\", msg, munit_error_str, errno);\\n#endif\\n}\\n\\n/*** Memory allocation ***/\\n\\nvoid*\\nmunit_malloc_ex(const char* filename, int line, size_t size) {\\n  void* ptr;\\n\\n  if (size == 0)\\n    return NULL;\\n\\n  ptr = calloc(1, size);\\n  if (MUNIT_UNLIKELY(ptr == NULL)) {\\n    munit_logf_ex(MUNIT_LOG_ERROR, filename, line, \\\"Failed to allocate %\\\" MUNIT_SIZE_MODIFIER \\\"u bytes.\\\", size);\\n  }\\n\\n  return ptr;\\n}\\n\\n/*** Timer code ***/\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n\\n#define psnip_uint64_t munit_uint64_t\\n#define psnip_uint32_t munit_uint32_t\\n\\n/* Code copied from portable-snippets\\n * <https://github.com/nemequ/portable-snippets/>.  If you need to\\n * change something, please do it there so we can keep the code in\\n * sync. */\\n\\n/* Clocks (v1)\\n * Portable Snippets - https://gitub.com/nemequ/portable-snippets\\n * Created by Evan Nemerson <evan@nemerson.com>\\n *\\n *   To the extent possible under law, the authors have waived all\\n *   copyright and related or neighboring rights to this code.  For\\n *   details, see the Creative Commons Zero 1.0 Universal license at\\n *   https://creativecommons.org/publicdomain/zero/1.0/\\n */\\n\\n#if !defined(PSNIP_CLOCK_H)\\n#define PSNIP_CLOCK_H\\n\\n#if !defined(psnip_uint64_t)\\n#  include \\\"../exact-int/exact-int.h\\\"\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_STATIC_INLINE)\\n#  if defined(__GNUC__)\\n#    define PSNIP_CLOCK__COMPILER_ATTRIBUTES __attribute__((__unused__))\\n#  else\\n#    define PSNIP_CLOCK__COMPILER_ATTRIBUTES\\n#  endif\\n\\n#  define PSNIP_CLOCK__FUNCTION PSNIP_CLOCK__COMPILER_ATTRIBUTES static\\n#endif\\n\\nenum PsnipClockType {\\n  /* This clock provides the current time, in units since 1970-01-01\\n   * 00:00:00 UTC not including leap seconds.  In other words, UNIX\\n   * time.  Keep in mind that this clock doesn't account for leap\\n   * seconds, and can go backwards (think NTP adjustments). */\\n  PSNIP_CLOCK_TYPE_WALL = 1,\\n  /* The CPU time is a clock which increases only when the current\\n   * process is active (i.e., it doesn't increment while blocking on\\n   * I/O). */\\n  PSNIP_CLOCK_TYPE_CPU = 2,\\n  /* Monotonic time is always running (unlike CPU time), but it only\\n     ever moves forward unless you reboot the system.  Things like NTP\\n     adjustments have no effect on this clock. */\\n  PSNIP_CLOCK_TYPE_MONOTONIC = 3\\n};\\n\\nstruct PsnipClockTimespec {\\n  psnip_uint64_t seconds;\\n  psnip_uint64_t nanoseconds;\\n};\\n\\n/* Methods we support: */\\n\\n#define PSNIP_CLOCK_METHOD_CLOCK_GETTIME                   1\\n#define PSNIP_CLOCK_METHOD_TIME                            2\\n#define PSNIP_CLOCK_METHOD_GETTIMEOFDAY                    3\\n#define PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER         4\\n#define PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME              5\\n#define PSNIP_CLOCK_METHOD_CLOCK                           6\\n#define PSNIP_CLOCK_METHOD_GETPROCESSTIMES                 7\\n#define PSNIP_CLOCK_METHOD_GETRUSAGE                       8\\n#define PSNIP_CLOCK_METHOD_GETSYSTEMTIMEPRECISEASFILETIME  9\\n#define PSNIP_CLOCK_METHOD_GETTICKCOUNT64                 10\\n\\n#include <assert.h>\\n\\n#if defined(HEDLEY_UNREACHABLE)\\n#  define PSNIP_CLOCK_UNREACHABLE() HEDLEY_UNREACHABLE()\\n#else\\n#  define PSNIP_CLOCK_UNREACHABLE() assert(0)\\n#endif\\n\\n/* Choose an implementation */\\n\\n/* #undef PSNIP_CLOCK_WALL_METHOD */\\n/* #undef PSNIP_CLOCK_CPU_METHOD */\\n/* #undef PSNIP_CLOCK_MONOTONIC_METHOD */\\n\\n/* We want to be able to detect the libc implementation, so we include\\n   <limits.h> (<features.h> isn't available everywhere). */\\n\\n#if defined(__unix__) || defined(__unix) || defined(__linux__)\\n#  include <limits.h>\\n#  include <unistd.h>\\n#endif\\n\\n#if defined(_POSIX_TIMERS) && (_POSIX_TIMERS > 0)\\n/* These are known to work without librt.  If you know of others\\n * please let us know so we can add them. */\\n#  if \\\\\\n  (defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 17))) || \\\\\\n  (defined(__FreeBSD__))\\n#    define PSNIP_CLOCK_HAVE_CLOCK_GETTIME\\n#  elif !defined(PSNIP_CLOCK_NO_LIBRT)\\n#    define PSNIP_CLOCK_HAVE_CLOCK_GETTIME\\n#  endif\\n#endif\\n\\n#if defined(_WIN32)\\n#  if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#    define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n#  endif\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n#  endif\\n#endif\\n\\n#if defined(__MACH__) && !defined(__gnu_hurd__)\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n#  endif\\n#endif\\n\\n#if defined(PSNIP_CLOCK_HAVE_CLOCK_GETTIME)\\n#  include <time.h>\\n#  if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#    if defined(CLOCK_REALTIME_PRECISE)\\n#      define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_WALL CLOCK_REALTIME_PRECISE\\n#    elif !defined(__sun)\\n#      define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_WALL CLOCK_REALTIME\\n#    endif\\n#  endif\\n#  if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#    if defined(_POSIX_CPUTIME) || defined(CLOCK_PROCESS_CPUTIME_ID)\\n#      define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_CPU CLOCK_PROCESS_CPUTIME_ID\\n#    elif defined(CLOCK_VIRTUAL)\\n#      define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_CPU CLOCK_VIRTUAL\\n#    endif\\n#  endif\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    if defined(CLOCK_MONOTONIC_RAW)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC\\n#    elif defined(CLOCK_MONOTONIC_PRECISE)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC_PRECISE\\n#    elif defined(_POSIX_MONOTONIC_CLOCK) || defined(CLOCK_MONOTONIC)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC\\n#    endif\\n#  endif\\n#endif\\n\\n#if defined(_POSIX_VERSION) && (_POSIX_VERSION >= 200112L)\\n#  if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#    define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n#  endif\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#  define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_TIME\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#  define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK\\n#endif\\n\\n/* Primarily here for testing. */\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD) && defined(PSNIP_CLOCK_REQUIRE_MONOTONIC)\\n#  error No monotonic clock found.\\n#endif\\n\\n/* Implementations */\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_TIME))\\n#  include <time.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETTIMEOFDAY)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETTIMEOFDAY)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY))\\n#  include <sys/time.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETTICKCOUNT64)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETTICKCOUNT64)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64))\\n#  include <windows.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETRUSAGE)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETRUSAGE)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETRUSAGE))\\n#  include <sys/time.h>\\n#  include <sys/resource.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME))\\n#  include <CoreServices/CoreServices.h>\\n#  include <mach/mach.h>\\n#  include <mach/mach_time.h>\\n#endif\\n\\n/*** Implementations ***/\\n\\n#define PSNIP_CLOCK_NSEC_PER_SEC ((psnip_uint32_t) (1000000000ULL))\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME))\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock__clock_getres (clockid_t clk_id) {\\n  struct timespec res;\\n  int r;\\n\\n  r = clock_getres(clk_id, &res);\\n  if (r != 0)\\n    return 0;\\n\\n  return (psnip_uint32_t) (PSNIP_CLOCK_NSEC_PER_SEC / res.tv_nsec);\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock__clock_gettime (clockid_t clk_id, struct PsnipClockTimespec* res) {\\n  struct timespec ts;\\n\\n  if (clock_gettime(clk_id, &ts) != 0)\\n    return -10;\\n\\n  res->seconds = (psnip_uint64_t) (ts.tv_sec);\\n  res->nanoseconds = (psnip_uint64_t) (ts.tv_nsec);\\n\\n  return 0;\\n}\\n#endif\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_wall_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_WALL);\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n  return 1000000;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_TIME\\n  return 1;\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_wall_get_time (struct PsnipClockTimespec* res) {\\n  (void) res;\\n\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n  return -2;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_WALL, res);\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_TIME\\n  res->seconds = time(NULL);\\n  res->nanoseconds = 0;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n  struct timeval tv;\\n\\n  if (gettimeofday(&tv, NULL) != 0)\\n    return -6;\\n\\n  res->seconds = tv.tv_sec;\\n  res->nanoseconds = tv.tv_usec * 1000;\\n#else\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_cpu_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_CPU);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK\\n  return CLOCKS_PER_SEC;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n  return PSNIP_CLOCK_NSEC_PER_SEC / 100;\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_cpu_get_time (struct PsnipClockTimespec* res) {\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n  (void) res;\\n  return -2;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_CPU, res);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK\\n  clock_t t = clock();\\n  if (t == ((clock_t) -1))\\n    return -5;\\n  res->seconds = t / CLOCKS_PER_SEC;\\n  res->nanoseconds = (t % CLOCKS_PER_SEC) * (PSNIP_CLOCK_NSEC_PER_SEC / CLOCKS_PER_SEC);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n  FILETIME CreationTime, ExitTime, KernelTime, UserTime;\\n  LARGE_INTEGER date, adjust;\\n\\n  if (!GetProcessTimes(GetCurrentProcess(), &CreationTime, &ExitTime, &KernelTime, &UserTime))\\n    return -7;\\n\\n  /* http://www.frenk.com/2009/12/convert-filetime-to-unix-timestamp/ */\\n  date.HighPart = UserTime.dwHighDateTime;\\n  date.LowPart = UserTime.dwLowDateTime;\\n  adjust.QuadPart = 11644473600000 * 10000;\\n  date.QuadPart -= adjust.QuadPart;\\n\\n  res->seconds = date.QuadPart / 10000000;\\n  res->nanoseconds = (date.QuadPart % 10000000) * (PSNIP_CLOCK_NSEC_PER_SEC / 100);\\n#elif PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETRUSAGE\\n  struct rusage usage;\\n  if (getrusage(RUSAGE_SELF, &usage) != 0)\\n    return -8;\\n\\n  res->seconds = usage.ru_utime.tv_sec;\\n  res->nanoseconds = tv.tv_usec * 1000;\\n#else\\n  (void) res;\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_monotonic_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n  static mach_timebase_info_data_t tbi = { 0, };\\n  if (tbi.denom == 0)\\n    mach_timebase_info(&tbi);\\n  return (psnip_uint32_t) (tbi.numer / tbi.denom);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64\\n  return 1000;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n  LARGE_INTEGER Frequency;\\n  QueryPerformanceFrequency(&Frequency);\\n  return (psnip_uint32_t) ((Frequency.QuadPart > PSNIP_CLOCK_NSEC_PER_SEC) ? PSNIP_CLOCK_NSEC_PER_SEC : Frequency.QuadPart);\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_monotonic_get_time (struct PsnipClockTimespec* res) {\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n  (void) res;\\n  return -2;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC, res);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n  psnip_uint64_t nsec = mach_absolute_time();\\n  static mach_timebase_info_data_t tbi = { 0, };\\n  if (tbi.denom == 0)\\n    mach_timebase_info(&tbi);\\n  nsec *= ((psnip_uint64_t) tbi.numer) / ((psnip_uint64_t) tbi.denom);\\n  res->seconds = nsec / PSNIP_CLOCK_NSEC_PER_SEC;\\n  res->nanoseconds = nsec % PSNIP_CLOCK_NSEC_PER_SEC;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n  LARGE_INTEGER t, f;\\n  if (QueryPerformanceCounter(&t) == 0)\\n    return -12;\\n\\n  QueryPerformanceFrequency(&f);\\n  res->seconds = t.QuadPart / f.QuadPart;\\n  res->nanoseconds = t.QuadPart % f.QuadPart;\\n  if (f.QuadPart > PSNIP_CLOCK_NSEC_PER_SEC)\\n    res->nanoseconds /= f.QuadPart / PSNIP_CLOCK_NSEC_PER_SEC;\\n  else\\n    res->nanoseconds *= PSNIP_CLOCK_NSEC_PER_SEC / f.QuadPart;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64\\n  const ULONGLONG msec = GetTickCount64();\\n  res->seconds = msec / 1000;\\n  res->nanoseconds = sec % 1000;\\n#else\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\n/* Returns the number of ticks per second for the specified clock.\\n * For example, a clock with millisecond precision would return 1000,\\n * and a clock with 1 second (such as the time() function) would\\n * return 1.\\n *\\n * If the requested clock isn't available, it will return 0.\\n * Hopefully this will be rare, but if it happens to you please let us\\n * know so we can work on finding a way to support your system.\\n *\\n * Note that different clocks on the same system often have a\\n * different precisions.\\n */\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_get_precision (enum PsnipClockType clock_type) {\\n  switch (clock_type) {\\n    case PSNIP_CLOCK_TYPE_MONOTONIC:\\n      return psnip_clock_monotonic_get_precision ();\\n    case PSNIP_CLOCK_TYPE_CPU:\\n      return psnip_clock_cpu_get_precision ();\\n    case PSNIP_CLOCK_TYPE_WALL:\\n      return psnip_clock_wall_get_precision ();\\n  }\\n\\n  PSNIP_CLOCK_UNREACHABLE();\\n  return 0;\\n}\\n\\n/* Set the provided timespec to the requested time.  Returns 0 on\\n * success, or a negative value on failure. */\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_get_time (enum PsnipClockType clock_type, struct PsnipClockTimespec* res) {\\n  assert(res != NULL);\\n\\n  switch (clock_type) {\\n    case PSNIP_CLOCK_TYPE_MONOTONIC:\\n      return psnip_clock_monotonic_get_time (res);\\n    case PSNIP_CLOCK_TYPE_CPU:\\n      return psnip_clock_cpu_get_time (res);\\n    case PSNIP_CLOCK_TYPE_WALL:\\n      return psnip_clock_wall_get_time (res);\\n  }\\n\\n  return -1;\\n}\\n\\n#endif /* !defined(PSNIP_CLOCK_H) */\\n\\nstatic psnip_uint64_t\\nmunit_clock_get_elapsed(struct PsnipClockTimespec* start, struct PsnipClockTimespec* end) {\\n  psnip_uint64_t r = (end->seconds - start->seconds) * PSNIP_CLOCK_NSEC_PER_SEC;\\n  if (end->nanoseconds < start->nanoseconds) {\\n    r -= (start->nanoseconds - end->nanoseconds);\\n  } else {\\n    r += (end->nanoseconds - start->nanoseconds);\\n  }\\n  return r;\\n}\\n\\n#else\\n#  include <time.h>\\n#endif /* defined(MUNIT_ENABLE_TIMING) */\\n\\n/*** PRNG stuff ***/\\n\\n/* This is (unless I screwed up, which is entirely possible) the\\n * version of PCG with 32-bit state.  It was chosen because it has a\\n * small enough state that we should reliably be able to use CAS\\n * instead of requiring a lock for thread-safety.\\n *\\n * If I did screw up, I probably will not bother changing it unless\\n * there is a significant bias.  It's really not important this be\\n * particularly strong, as long as it is fairly random it's much more\\n * important that it be reproducible, so bug reports have a better\\n * chance of being reproducible. */\\n\\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__) && !defined(__EMSCRIPTEN__) && (!defined(__GNUC_MINOR__) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ > 8))\\n#  define HAVE_STDATOMIC\\n#elif defined(__clang__)\\n#  if __has_extension(c_atomic)\\n#    define HAVE_CLANG_ATOMICS\\n#  endif\\n#endif\\n\\n/* Workaround for http://llvm.org/bugs/show_bug.cgi?id=26911 */\\n#if defined(__clang__) && defined(_WIN32)\\n#  undef HAVE_STDATOMIC\\n#  if defined(__c2__)\\n#    undef HAVE_CLANG_ATOMICS\\n#  endif\\n#endif\\n\\n#if defined(_OPENMP)\\n#  define ATOMIC_UINT32_T uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#elif defined(HAVE_STDATOMIC)\\n#  include <stdatomic.h>\\n#  define ATOMIC_UINT32_T _Atomic uint32_t\\n#  define ATOMIC_UINT32_INIT(x) ATOMIC_VAR_INIT(x)\\n#elif defined(HAVE_CLANG_ATOMICS)\\n#  define ATOMIC_UINT32_T _Atomic uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#elif defined(_WIN32)\\n#  define ATOMIC_UINT32_T volatile LONG\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#else\\n#  define ATOMIC_UINT32_T volatile uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#endif\\n\\nstatic ATOMIC_UINT32_T munit_rand_state = ATOMIC_UINT32_INIT(42);\\n\\n#if defined(_OPENMP)\\nstatic inline void\\nmunit_atomic_store(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T value) {\\n#pragma omp critical (munit_atomics)\\n  *dest = value;\\n}\\n\\nstatic inline uint32_t\\nmunit_atomic_load(ATOMIC_UINT32_T* src) {\\n  int ret;\\n#pragma omp critical (munit_atomics)\\n  ret = *src;\\n  return ret;\\n}\\n\\nstatic inline uint32_t\\nmunit_atomic_cas(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T* expected, ATOMIC_UINT32_T desired) {\\n  munit_bool ret;\\n\\n#pragma omp critical (munit_atomics)\\n  {\\n    if (*dest == *expected) {\\n      *dest = desired;\\n      ret = 1;\\n    } else {\\n      ret = 0;\\n    }\\n  }\\n\\n  return ret;\\n}\\n#elif defined(HAVE_STDATOMIC)\\n#  define munit_atomic_store(dest, value)         atomic_store(dest, value)\\n#  define munit_atomic_load(src)                  atomic_load(src)\\n#  define munit_atomic_cas(dest, expected, value) atomic_compare_exchange_weak(dest, expected, value)\\n#elif defined(HAVE_CLANG_ATOMICS)\\n#  define munit_atomic_store(dest, value)         __c11_atomic_store(dest, value, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_load(src)                  __c11_atomic_load(src, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_cas(dest, expected, value) __c11_atomic_compare_exchange_weak(dest, expected, value, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\\n#elif defined(__GNUC__) && (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)\\n#  define munit_atomic_store(dest, value)         __atomic_store_n(dest, value, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_load(src)                  __atomic_load_n(src, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_cas(dest, expected, value) __atomic_compare_exchange_n(dest, expected, value, 1, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\\n#elif defined(__GNUC__) && (__GNUC__ >= 4)\\n#  define munit_atomic_store(dest,value)          do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\n#  define munit_atomic_cas(dest, expected, value) __sync_bool_compare_and_swap(dest, *expected, value)\\n#elif defined(_WIN32) /* Untested */\\n#  define munit_atomic_store(dest,value)          do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\n#  define munit_atomic_cas(dest, expected, value) InterlockedCompareExchange((dest), (value), *(expected))\\n#else\\n#  warning No atomic implementation, PRNG will not be thread-safe\\n#  define munit_atomic_store(dest, value)         do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\nstatic inline munit_bool\\nmunit_atomic_cas(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T* expected, ATOMIC_UINT32_T desired) {\\n  if (*dest == *expected) {\\n    *dest = desired;\\n    return 1;\\n  } else {\\n    return 0;\\n  }\\n}\\n#endif\\n\\n#define MUNIT_PRNG_MULTIPLIER (747796405U)\\n#define MUNIT_PRNG_INCREMENT  (1729U)\\n\\nstatic munit_uint32_t\\nmunit_rand_next_state(munit_uint32_t state) {\\n  return state * MUNIT_PRNG_MULTIPLIER + MUNIT_PRNG_INCREMENT;\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_from_state(munit_uint32_t state) {\\n  munit_uint32_t res = ((state >> ((state >> 28) + 4)) ^ state) * (277803737U);\\n  res ^= res >> 22;\\n  return res;\\n}\\n\\nvoid\\nmunit_rand_seed(munit_uint32_t seed) {\\n  munit_uint32_t state = munit_rand_next_state(seed + MUNIT_PRNG_INCREMENT);\\n  munit_atomic_store(&munit_rand_state, state);\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_generate_seed(void) {\\n  munit_uint32_t seed, state;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  struct PsnipClockTimespec wc = { 0, };\\n\\n  psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wc);\\n  seed = (munit_uint32_t) wc.nanoseconds;\\n#else\\n  seed = (munit_uint32_t) time(NULL);\\n#endif\\n\\n  state = munit_rand_next_state(seed + MUNIT_PRNG_INCREMENT);\\n  return munit_rand_from_state(state);\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_state_uint32(munit_uint32_t* state) {\\n  const munit_uint32_t old = *state;\\n  *state = munit_rand_next_state(old);\\n  return munit_rand_from_state(old);\\n}\\n\\nmunit_uint32_t\\nmunit_rand_uint32(void) {\\n  munit_uint32_t old, state;\\n\\n  do {\\n    old = munit_atomic_load(&munit_rand_state);\\n    state = munit_rand_next_state(old);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return munit_rand_from_state(old);\\n}\\n\\nstatic void\\nmunit_rand_state_memory(munit_uint32_t* state, size_t size, munit_uint8_t data[MUNIT_ARRAY_PARAM(size)]) {\\n  size_t members_remaining = size / sizeof(munit_uint32_t);\\n  size_t bytes_remaining = size % sizeof(munit_uint32_t);\\n  munit_uint8_t* b = data;\\n  munit_uint32_t rv;\\n  while (members_remaining-- > 0) {\\n    rv = munit_rand_state_uint32(state);\\n    memcpy(b, &rv, sizeof(munit_uint32_t));\\n    b += sizeof(munit_uint32_t);\\n  }\\n  if (bytes_remaining != 0) {\\n    rv = munit_rand_state_uint32(state);\\n    memcpy(b, &rv, bytes_remaining);\\n  }\\n}\\n\\nvoid\\nmunit_rand_memory(size_t size, munit_uint8_t data[MUNIT_ARRAY_PARAM(size)]) {\\n  munit_uint32_t old, state;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n    munit_rand_state_memory(&state, size, data);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_state_at_most(munit_uint32_t* state, munit_uint32_t salt, munit_uint32_t max) {\\n  /* We want (UINT32_MAX + 1) % max, which in unsigned arithmetic is the same\\n   * as (UINT32_MAX + 1 - max) % max = -max % max. We compute -max using not\\n   * to avoid compiler warnings.\\n   */\\n  const munit_uint32_t min = (~max + 1U) % max;\\n  munit_uint32_t x;\\n\\n  if (max == (~((munit_uint32_t) 0U)))\\n    return munit_rand_state_uint32(state) ^ salt;\\n\\n  max++;\\n\\n  do {\\n    x = munit_rand_state_uint32(state) ^ salt;\\n  } while (x < min);\\n\\n  return x % max;\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_at_most(munit_uint32_t salt, munit_uint32_t max) {\\n  munit_uint32_t old, state;\\n  munit_uint32_t retval;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n    retval = munit_rand_state_at_most(&state, salt, max);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return retval;\\n}\\n\\nint\\nmunit_rand_int_range(int min, int max) {\\n  munit_uint64_t range = (munit_uint64_t) max - (munit_uint64_t) min;\\n\\n  if (min > max)\\n    return munit_rand_int_range(max, min);\\n\\n  if (range > (~((munit_uint32_t) 0U)))\\n    range = (~((munit_uint32_t) 0U));\\n\\n  return min + munit_rand_at_most(0, (munit_uint32_t) range);\\n}\\n\\ndouble\\nmunit_rand_double(void) {\\n  munit_uint32_t old, state;\\n  double retval = 0.0;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n\\n    /* See http://mumble.net/~campbell/tmp/random_real.c for how to do\\n     * this right.  Patches welcome if you feel that this is too\\n     * biased. */\\n    retval = munit_rand_state_uint32(&state) / ((~((munit_uint32_t) 0U)) + 1.0);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return retval;\\n}\\n\\n/*** Test suite handling ***/\\n\\ntypedef struct {\\n  unsigned int successful;\\n  unsigned int skipped;\\n  unsigned int failed;\\n  unsigned int errored;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  munit_uint64_t cpu_clock;\\n  munit_uint64_t wall_clock;\\n#endif\\n} MunitReport;\\n\\ntypedef struct {\\n  const char* prefix;\\n  const MunitSuite* suite;\\n  const char** tests;\\n  munit_uint32_t seed;\\n  unsigned int iterations;\\n  MunitParameter* parameters;\\n  munit_bool single_parameter_mode;\\n  void* user_data;\\n  MunitReport report;\\n  munit_bool colorize;\\n  munit_bool fork;\\n  munit_bool show_stderr;\\n  munit_bool fatal_failures;\\n} MunitTestRunner;\\n\\nconst char*\\nmunit_parameters_get(const MunitParameter params[], const char* key) {\\n  const MunitParameter* param;\\n\\n  for (param = params ; param != NULL && param->name != NULL ; param++)\\n    if (strcmp(param->name, key) == 0)\\n      return param->value;\\n  return NULL;\\n}\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\nstatic void\\nmunit_print_time(FILE* fp, munit_uint64_t nanoseconds) {\\n  fprintf(fp, \\\"%\\\" MUNIT_TEST_TIME_FORMAT, ((double) nanoseconds) / ((double) PSNIP_CLOCK_NSEC_PER_SEC));\\n}\\n#endif\\n\\n/* Add a paramter to an array of parameters. */\\nstatic MunitResult\\nmunit_parameters_add(size_t* params_size, MunitParameter* params[MUNIT_ARRAY_PARAM(*params_size)], char* name, char* value) {\\n  *params = realloc(*params, sizeof(MunitParameter) * (*params_size + 2));\\n  if (*params == NULL)\\n    return MUNIT_ERROR;\\n\\n  (*params)[*params_size].name = name;\\n  (*params)[*params_size].value = value;\\n  (*params_size)++;\\n  (*params)[*params_size].name = NULL;\\n  (*params)[*params_size].value = NULL;\\n\\n  return MUNIT_OK;\\n}\\n\\n/* Concatenate two strings, but just return one of the components\\n * unaltered if the other is NULL or \\\"\\\". */\\nstatic char*\\nmunit_maybe_concat(size_t* len, char* prefix, char* suffix) {\\n  char* res;\\n  size_t res_l;\\n  const size_t prefix_l = prefix != NULL ? strlen(prefix) : 0;\\n  const size_t suffix_l = suffix != NULL ? strlen(suffix) : 0;\\n  if (prefix_l == 0 && suffix_l == 0) {\\n    res = NULL;\\n    res_l = 0;\\n  } else if (prefix_l == 0 && suffix_l != 0) {\\n    res = suffix;\\n    res_l = suffix_l;\\n  } else if (prefix_l != 0 && suffix_l == 0) {\\n    res = prefix;\\n    res_l = prefix_l;\\n  } else {\\n    res_l = prefix_l + suffix_l;\\n    res = malloc(res_l + 1);\\n    memcpy(res, prefix, prefix_l);\\n    memcpy(res + prefix_l, suffix, suffix_l);\\n    res[res_l] = 0;\\n  }\\n\\n  if (len != NULL)\\n    *len = res_l;\\n\\n  return res;\\n}\\n\\n/* Possbily free a string returned by munit_maybe_concat. */\\nstatic void\\nmunit_maybe_free_concat(char* s, const char* prefix, const char* suffix) {\\n  if (prefix != s && suffix != s)\\n    free(s);\\n}\\n\\n/* Cheap string hash function, just used to salt the PRNG. */\\nstatic munit_uint32_t\\nmunit_str_hash(const char* name) {\\n  const char *p;\\n  munit_uint32_t h = 5381U;\\n\\n  for (p = name; *p != '\\\\0'; p++)\\n    h = (h << 5) + h + *p;\\n\\n  return h;\\n}\\n\\nstatic void\\nmunit_splice(int from, int to) {\\n  munit_uint8_t buf[1024];\\n#if !defined(_WIN32)\\n  ssize_t len;\\n  ssize_t bytes_written;\\n  ssize_t write_res;\\n#else\\n  int len;\\n  int bytes_written;\\n  int write_res;\\n#endif\\n  do {\\n    len = read(from, buf, sizeof(buf));\\n    if (len > 0) {\\n      bytes_written = 0;\\n      do {\\n        write_res = write(to, buf + bytes_written, len - bytes_written);\\n        if (write_res < 0)\\n          break;\\n        bytes_written += write_res;\\n      } while (bytes_written < len);\\n    }\\n    else\\n      break;\\n  } while (1);\\n}\\n\\n/* This is the part that should be handled in the child process */\\nstatic MunitResult\\nmunit_test_runner_exec(MunitTestRunner* runner, const MunitTest* test, const MunitParameter params[], MunitReport* report) {\\n  unsigned int iterations = runner->iterations;\\n  MunitResult result = MUNIT_FAIL;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  struct PsnipClockTimespec wall_clock_begin = { 0, }, wall_clock_end = { 0, };\\n  struct PsnipClockTimespec cpu_clock_begin = { 0, }, cpu_clock_end = { 0, };\\n#endif\\n  unsigned int i = 0;\\n\\n  if ((test->options & MUNIT_TEST_OPTION_SINGLE_ITERATION) == MUNIT_TEST_OPTION_SINGLE_ITERATION)\\n    iterations = 1;\\n  else if (iterations == 0)\\n    iterations = runner->suite->iterations;\\n\\n  munit_rand_seed(runner->seed);\\n\\n  do {\\n    void* data = (test->setup == NULL) ? runner->user_data : test->setup(params, runner->user_data);\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wall_clock_begin);\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_CPU, &cpu_clock_begin);\\n#endif\\n\\n    result = test->test(params, data);\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wall_clock_end);\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_CPU, &cpu_clock_end);\\n#endif\\n\\n    if (test->tear_down != NULL)\\n      test->tear_down(data);\\n\\n    if (MUNIT_LIKELY(result == MUNIT_OK)) {\\n      report->successful++;\\n#if defined(MUNIT_ENABLE_TIMING)\\n      report->wall_clock += munit_clock_get_elapsed(&wall_clock_begin, &wall_clock_end);\\n      report->cpu_clock += munit_clock_get_elapsed(&cpu_clock_begin, &cpu_clock_end);\\n#endif\\n    } else {\\n      switch ((int) result) {\\n        case MUNIT_SKIP:\\n          report->skipped++;\\n          break;\\n        case MUNIT_FAIL:\\n          report->failed++;\\n          break;\\n        case MUNIT_ERROR:\\n          report->errored++;\\n          break;\\n        default:\\n          break;\\n      }\\n      break;\\n    }\\n  } while (++i < iterations);\\n\\n  return result;\\n}\\n\\n#if defined(MUNIT_EMOTICON)\\n#  define MUNIT_RESULT_STRING_OK    \\\":)\\\"\\n#  define MUNIT_RESULT_STRING_SKIP  \\\":|\\\"\\n#  define MUNIT_RESULT_STRING_FAIL  \\\":(\\\"\\n#  define MUNIT_RESULT_STRING_ERROR \\\":o\\\"\\n#  define MUNIT_RESULT_STRING_TODO  \\\":/\\\"\\n#else\\n#  define MUNIT_RESULT_STRING_OK    \\\"OK   \\\"\\n#  define MUNIT_RESULT_STRING_SKIP  \\\"SKIP \\\"\\n#  define MUNIT_RESULT_STRING_FAIL  \\\"FAIL \\\"\\n#  define MUNIT_RESULT_STRING_ERROR \\\"ERROR\\\"\\n#  define MUNIT_RESULT_STRING_TODO  \\\"TODO \\\"\\n#endif\\n\\nstatic void\\nmunit_test_runner_print_color(const MunitTestRunner* runner, const char* string, char color) {\\n  if (runner->colorize)\\n    fprintf(MUNIT_OUTPUT_FILE, \\\"\\\\x1b[3%cm%s\\\\x1b[39m\\\", color, string);\\n  else\\n    fputs(string, MUNIT_OUTPUT_FILE);\\n}\\n\\n#if !defined(MUNIT_NO_BUFFER)\\nstatic int\\nmunit_replace_stderr(FILE* stderr_buf) {\\n  if (stderr_buf != NULL) {\\n    const int orig_stderr = dup(STDERR_FILENO);\\n\\n    int errfd = fileno(stderr_buf);\\n    if (MUNIT_UNLIKELY(errfd == -1)) {\\n      exit(EXIT_FAILURE);\\n    }\\n\\n    dup2(errfd, STDERR_FILENO);\\n\\n    return orig_stderr;\\n  }\\n\\n  return -1;\\n}\\n\\nstatic void\\nmunit_restore_stderr(int orig_stderr) {\\n  if (orig_stderr != -1) {\\n    dup2(orig_stderr, STDERR_FILENO);\\n    close(orig_stderr);\\n  }\\n}\\n#endif /* !defined(MUNIT_NO_BUFFER) */\\n\\n/* Run a test with the specified parameters. */\\nstatic void\\nmunit_test_runner_run_test_with_params(MunitTestRunner* runner, const MunitTest* test, const MunitParameter params[]) {\\n  MunitResult result = MUNIT_OK;\\n  MunitReport report = {\\n    0, 0, 0, 0,\\n#if defined(MUNIT_ENABLE_TIMING)\\n    0, 0\\n#endif\\n  };\\n  unsigned int output_l;\\n  munit_bool first;\\n  const MunitParameter* param;\\n  FILE* stderr_buf;\\n#if !defined(MUNIT_NO_FORK)\\n  int pipefd[2];\\n  pid_t fork_pid;\\n  int orig_stderr;\\n  ssize_t bytes_written = 0;\\n  ssize_t write_res;\\n  ssize_t bytes_read = 0;\\n  ssize_t read_res;\\n  int status = 0;\\n  pid_t changed_pid;\\n#endif\\n\\n  if (params != NULL) {\\n    output_l = 2;\\n    fputs(\\\"  \\\", MUNIT_OUTPUT_FILE);\\n    first = 1;\\n    for (param = params ; param != NULL && param->name != NULL ; param++) {\\n      if (!first) {\\n        fputs(\\\", \\\", MUNIT_OUTPUT_FILE);\\n        output_l += 2;\\n      } else {\\n        first = 0;\\n      }\\n\\n      output_l += fprintf(MUNIT_OUTPUT_FILE, \\\"%s=%s\\\", param->name, param->value);\\n    }\\n    while (output_l++ < MUNIT_TEST_NAME_LEN) {\\n      fputc(' ', MUNIT_OUTPUT_FILE);\\n    }\\n  }\\n\\n  fflush(MUNIT_OUTPUT_FILE);\\n\\n  stderr_buf = NULL;\\n#if !defined(_WIN32) || defined(__MINGW32__)\\n  stderr_buf = tmpfile();\\n#else\\n  tmpfile_s(&stderr_buf);\\n#endif\\n  if (stderr_buf == NULL) {\\n    munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to create buffer for stderr\\\");\\n    result = MUNIT_ERROR;\\n    goto print_result;\\n  }\\n\\n#if !defined(MUNIT_NO_FORK)\\n  if (runner->fork) {\\n    pipefd[0] = -1;\\n    pipefd[1] = -1;\\n    if (pipe(pipefd) != 0) {\\n      munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to create pipe\\\");\\n      result = MUNIT_ERROR;\\n      goto print_result;\\n    }\\n\\n    fork_pid = fork();\\n    if (fork_pid == 0) {\\n      close(pipefd[0]);\\n\\n      orig_stderr = munit_replace_stderr(stderr_buf);\\n      munit_test_runner_exec(runner, test, params, &report);\\n\\n      /* Note that we don't restore stderr.  This is so we can buffer\\n       * things written to stderr later on (such as by\\n       * asan/tsan/ubsan, valgrind, etc.) */\\n      close(orig_stderr);\\n\\n      do {\\n        write_res = write(pipefd[1], ((munit_uint8_t*) (&report)) + bytes_written, sizeof(report) - bytes_written);\\n        if (write_res < 0) {\\n          if (stderr_buf != NULL) {\\n            munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to write to pipe\\\");\\n          }\\n          exit(EXIT_FAILURE);\\n        }\\n        bytes_written += write_res;\\n      } while ((size_t) bytes_written < sizeof(report));\\n\\n      if (stderr_buf != NULL)\\n        fclose(stderr_buf);\\n      close(pipefd[1]);\\n\\n      exit(EXIT_SUCCESS);\\n    } else if (fork_pid == -1) {\\n      close(pipefd[0]);\\n      close(pipefd[1]);\\n      if (stderr_buf != NULL) {\\n        munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to fork\\\");\\n      }\\n      report.errored++;\\n      result = MUNIT_ERROR;\\n    } else {\\n      close(pipefd[1]);\\n      do {\\n        read_res = read(pipefd[0], ((munit_uint8_t*) (&report)) + bytes_read, sizeof(report) - bytes_read);\\n        if (read_res < 1)\\n          break;\\n        bytes_read += read_res;\\n      } while (bytes_read < (ssize_t) sizeof(report));\\n\\n      changed_pid = waitpid(fork_pid, &status, 0);\\n\\n      if (MUNIT_LIKELY(changed_pid == fork_pid) && MUNIT_LIKELY(WIFEXITED(status))) {\\n        if (bytes_read != sizeof(report)) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child exited unexpectedly with status %d\\\", WEXITSTATUS(status));\\n          report.errored++;\\n        } else if (WEXITSTATUS(status) != EXIT_SUCCESS) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child exited with status %d\\\", WEXITSTATUS(status));\\n          report.errored++;\\n        }\\n      } else {\\n        if (WIFSIGNALED(status)) {\\n#if defined(_XOPEN_VERSION) && (_XOPEN_VERSION >= 700)\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child killed by signal %d (%s)\\\", WTERMSIG(status), strsignal(WTERMSIG(status)));\\n#else\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child killed by signal %d\\\", WTERMSIG(status));\\n#endif\\n        } else if (WIFSTOPPED(status)) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child stopped by signal %d\\\", WSTOPSIG(status));\\n        }\\n        report.errored++;\\n      }\\n\\n      close(pipefd[0]);\\n      waitpid(fork_pid, NULL, 0);\\n    }\\n  } else\\n#endif\\n  {\\n#if !defined(MUNIT_NO_BUFFER)\\n    const volatile int orig_stderr = munit_replace_stderr(stderr_buf);\\n#endif\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\n    if (MUNIT_UNLIKELY(setjmp(munit_error_jmp_buf) != 0)) {\\n      result = MUNIT_FAIL;\\n      report.failed++;\\n    } else {\\n      munit_error_jmp_buf_valid = 1;\\n      result = munit_test_runner_exec(runner, test, params, &report);\\n    }\\n#else\\n    result = munit_test_runner_exec(runner, test, params, &report);\\n#endif\\n\\n#if !defined(MUNIT_NO_BUFFER)\\n    munit_restore_stderr(orig_stderr);\\n#endif\\n\\n    /* Here just so that the label is used on Windows and we don't get\\n     * a warning */\\n    goto print_result;\\n  }\\n\\n print_result:\\n\\n  fputs(\\\"[ \\\", MUNIT_OUTPUT_FILE);\\n  if ((test->options & MUNIT_TEST_OPTION_TODO) == MUNIT_TEST_OPTION_TODO) {\\n    if (report.failed != 0 || report.errored != 0 || report.skipped != 0) {\\n      munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_TODO, '3');\\n      result = MUNIT_OK;\\n    } else {\\n      munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_ERROR, '1');\\n      if (MUNIT_LIKELY(stderr_buf != NULL))\\n        munit_log_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"Test marked TODO, but was successful.\\\");\\n      runner->report.failed++;\\n      result = MUNIT_ERROR;\\n    }\\n  } else if (report.failed > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_FAIL, '1');\\n    runner->report.failed++;\\n    result = MUNIT_FAIL;\\n  } else if (report.errored > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_ERROR, '1');\\n    runner->report.errored++;\\n    result = MUNIT_ERROR;\\n  } else if (report.skipped > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_SKIP, '3');\\n    runner->report.skipped++;\\n    result = MUNIT_SKIP;\\n  } else if (report.successful > 1) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_OK, '2');\\n#if defined(MUNIT_ENABLE_TIMING)\\n    fputs(\\\" ] [ \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock / report.successful);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock / report.successful);\\n    fprintf(MUNIT_OUTPUT_FILE, \\\" CPU ]\\\\n  %-\\\" MUNIT_XSTRINGIFY(MUNIT_TEST_NAME_LEN) \\\"s Total: [ \\\", \\\"\\\");\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock);\\n    fputs(\\\" CPU\\\", MUNIT_OUTPUT_FILE);\\n#endif\\n    runner->report.successful++;\\n    result = MUNIT_OK;\\n  } else if (report.successful > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_OK, '2');\\n#if defined(MUNIT_ENABLE_TIMING)\\n    fputs(\\\" ] [ \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock);\\n    fputs(\\\" CPU\\\", MUNIT_OUTPUT_FILE);\\n#endif\\n    runner->report.successful++;\\n    result = MUNIT_OK;\\n  }\\n  fputs(\\\" ]\\\\n\\\", MUNIT_OUTPUT_FILE);\\n\\n  if (stderr_buf != NULL) {\\n    if (result == MUNIT_FAIL || result == MUNIT_ERROR || runner->show_stderr) {\\n      fflush(MUNIT_OUTPUT_FILE);\\n\\n      rewind(stderr_buf);\\n      munit_splice(fileno(stderr_buf), STDERR_FILENO);\\n\\n      fflush(stderr);\\n    }\\n\\n    fclose(stderr_buf);\\n  }\\n}\\n\\nstatic void\\nmunit_test_runner_run_test_wild(MunitTestRunner* runner,\\n                                const MunitTest* test,\\n                                const char* test_name,\\n                                MunitParameter* params,\\n                                MunitParameter* p) {\\n  const MunitParameterEnum* pe;\\n  char** values;\\n  MunitParameter* next;\\n\\n  for (pe = test->parameters ; pe != NULL && pe->name != NULL ; pe++) {\\n    if (p->name == pe->name)\\n      break;\\n  }\\n\\n  if (pe == NULL)\\n    return;\\n\\n  for (values = pe->values ; *values != NULL ; values++) {\\n    next = p + 1;\\n    p->value = *values;\\n    if (next->name == NULL) {\\n      munit_test_runner_run_test_with_params(runner, test, params);\\n    } else {\\n      munit_test_runner_run_test_wild(runner, test, test_name, params, next);\\n    }\\n    if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n      break;\\n  }\\n}\\n\\n/* Run a single test, with every combination of parameters\\n * requested. */\\nstatic void\\nmunit_test_runner_run_test(MunitTestRunner* runner,\\n                           const MunitTest* test,\\n                           const char* prefix) {\\n  char* test_name = munit_maybe_concat(NULL, (char*) prefix, (char*) test->name);\\n  /* The array of parameters to pass to\\n   * munit_test_runner_run_test_with_params */\\n  MunitParameter* params = NULL;\\n  size_t params_l = 0;\\n  /* Wildcard parameters are parameters which have possible values\\n   * specified in the test, but no specific value was passed to the\\n   * CLI.  That means we want to run the test once for every\\n   * possible combination of parameter values or, if --single was\\n   * passed to the CLI, a single time with a random set of\\n   * parameters. */\\n  MunitParameter* wild_params = NULL;\\n  size_t wild_params_l = 0;\\n  const MunitParameterEnum* pe;\\n  const MunitParameter* cli_p;\\n  munit_bool filled;\\n  unsigned int possible;\\n  char** vals;\\n  size_t first_wild;\\n  const MunitParameter* wp;\\n  int pidx;\\n\\n  munit_rand_seed(runner->seed);\\n\\n  fprintf(MUNIT_OUTPUT_FILE, \\\"%-\\\" MUNIT_XSTRINGIFY(MUNIT_TEST_NAME_LEN) \\\"s\\\", test_name);\\n\\n  if (test->parameters == NULL) {\\n    /* No parameters.  Simple, nice. */\\n    munit_test_runner_run_test_with_params(runner, test, NULL);\\n  } else {\\n    fputc('\\\\n', MUNIT_OUTPUT_FILE);\\n\\n    for (pe = test->parameters ; pe != NULL && pe->name != NULL ; pe++) {\\n      /* Did we received a value for this parameter from the CLI? */\\n      filled = 0;\\n      for (cli_p = runner->parameters ; cli_p != NULL && cli_p->name != NULL ; cli_p++) {\\n        if (strcmp(cli_p->name, pe->name) == 0) {\\n          if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, cli_p->value) != MUNIT_OK))\\n            goto cleanup;\\n          filled = 1;\\n          break;\\n        }\\n      }\\n      if (filled)\\n        continue;\\n\\n      /* Nothing from CLI, is the enum NULL/empty?  We're not a\\n       * fuzzer\\u2026 */\\n      if (pe->values == NULL || pe->values[0] == NULL)\\n        continue;\\n\\n      /* If --single was passed to the CLI, choose a value from the\\n       * list of possibilities randomly. */\\n      if (runner->single_parameter_mode) {\\n        possible = 0;\\n        for (vals = pe->values ; *vals != NULL ; vals++)\\n          possible++;\\n        /* We want the tests to be reproducible, even if you're only\\n         * running a single test, but we don't want every test with\\n         * the same number of parameters to choose the same parameter\\n         * number, so use the test name as a primitive salt. */\\n        pidx = munit_rand_at_most(munit_str_hash(test_name), possible - 1);\\n        if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, pe->values[pidx]) != MUNIT_OK))\\n          goto cleanup;\\n      } else {\\n        /* We want to try every permutation.  Put in a placeholder\\n         * entry, we'll iterate through them later. */\\n        if (MUNIT_UNLIKELY(munit_parameters_add(&wild_params_l, &wild_params, pe->name, NULL) != MUNIT_OK))\\n          goto cleanup;\\n      }\\n    }\\n\\n    if (wild_params_l != 0) {\\n      first_wild = params_l;\\n      for (wp = wild_params ; wp != NULL && wp->name != NULL ; wp++) {\\n        for (pe = test->parameters ; pe != NULL && pe->name != NULL && pe->values != NULL ; pe++) {\\n          if (strcmp(wp->name, pe->name) == 0) {\\n            if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, pe->values[0]) != MUNIT_OK))\\n              goto cleanup;\\n          }\\n        }\\n      }\\n\\n      munit_test_runner_run_test_wild(runner, test, test_name, params, params + first_wild);\\n    } else {\\n      munit_test_runner_run_test_with_params(runner, test, params);\\n    }\\n\\n  cleanup:\\n    free(params);\\n    free(wild_params);\\n  }\\n\\n  munit_maybe_free_concat(test_name, prefix, test->name);\\n}\\n\\n/* Recurse through the suite and run all the tests.  If a list of\\n * tests to run was provied on the command line, run only those\\n * tests.  */\\nstatic void\\nmunit_test_runner_run_suite(MunitTestRunner* runner,\\n                            const MunitSuite* suite,\\n                            const char* prefix) {\\n  size_t pre_l;\\n  char* pre = munit_maybe_concat(&pre_l, (char*) prefix, (char*) suite->prefix);\\n  const MunitTest* test;\\n  const char** test_name;\\n  const MunitSuite* child_suite;\\n\\n  /* Run the tests. */\\n  for (test = suite->tests ; test != NULL && test->test != NULL ; test++) {\\n    if (runner->tests != NULL) { /* Specific tests were requested on the CLI */\\n      for (test_name = runner->tests ; test_name != NULL && *test_name != NULL ; test_name++) {\\n        if ((pre_l == 0 || strncmp(pre, *test_name, pre_l) == 0) &&\\n            strncmp(test->name, *test_name + pre_l, strlen(*test_name + pre_l)) == 0) {\\n          munit_test_runner_run_test(runner, test, pre);\\n          if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n            goto cleanup;\\n        }\\n      }\\n    } else { /* Run all tests */\\n      munit_test_runner_run_test(runner, test, pre);\\n    }\\n  }\\n\\n  if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n    goto cleanup;\\n\\n  /* Run any child suites. */\\n  for (child_suite = suite->suites ; child_suite != NULL && child_suite->prefix != NULL ; child_suite++) {\\n    munit_test_runner_run_suite(runner, child_suite, pre);\\n  }\\n\\n cleanup:\\n\\n  munit_maybe_free_concat(pre, prefix, suite->prefix);\\n}\\n\\nstatic void\\nmunit_test_runner_run(MunitTestRunner* runner) {\\n  munit_test_runner_run_suite(runner, runner->suite, NULL);\\n}\\n\\nstatic void\\nmunit_print_help(int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)], void* user_data, const MunitArgument arguments[]) {\\n  const MunitArgument* arg;\\n  (void) argc;\\n\\n  printf(\\\"USAGE: %s [OPTIONS...] [TEST...]\\\\n\\\\n\\\", argv[0]);\\n  puts(\\\" --seed SEED\\\\n\\\"\\n       \\\"           Value used to seed the PRNG.  Must be a 32-bit integer in decimal\\\\n\\\"\\n       \\\"           notation with no separators (commas, decimals, spaces, etc.), or\\\\n\\\"\\n       \\\"           hexidecimal prefixed by \\\\\\\"0x\\\\\\\".\\\\n\\\"\\n       \\\" --iterations N\\\\n\\\"\\n       \\\"           Run each test N times.  0 means the default number.\\\\n\\\"\\n       \\\" --param name value\\\\n\\\"\\n       \\\"           A parameter key/value pair which will be passed to any test with\\\\n\\\"\\n       \\\"           takes a parameter of that name.  If not provided, the test will be\\\\n\\\"\\n       \\\"           run once for each possible parameter value.\\\\n\\\"\\n       \\\" --list    Write a list of all available tests.\\\\n\\\"\\n       \\\" --list-params\\\\n\\\"\\n       \\\"           Write a list of all available tests and their possible parameters.\\\\n\\\"\\n       \\\" --single  Run each parameterized test in a single configuration instead of\\\\n\\\"\\n       \\\"           every possible combination\\\\n\\\"\\n       \\\" --log-visible debug|info|warning|error\\\\n\\\"\\n       \\\" --log-fatal debug|info|warning|error\\\\n\\\"\\n       \\\"           Set the level at which messages of different severities are visible,\\\\n\\\"\\n       \\\"           or cause the test to terminate.\\\\n\\\"\\n#if !defined(MUNIT_NO_FORK)\\n       \\\" --no-fork Do not execute tests in a child process.  If this option is supplied\\\\n\\\"\\n       \\\"           and a test crashes (including by failing an assertion), no further\\\\n\\\"\\n       \\\"           tests will be performed.\\\\n\\\"\\n#endif\\n       \\\" --fatal-failures\\\\n\\\"\\n       \\\"           Stop executing tests as soon as a failure is found.\\\\n\\\"\\n       \\\" --show-stderr\\\\n\\\"\\n       \\\"           Show data written to stderr by the tests, even if the test succeeds.\\\\n\\\"\\n       \\\" --color auto|always|never\\\\n\\\"\\n       \\\"           Colorize (or don't) the output.\\\\n\\\"\\n     /* 12345678901234567890123456789012345678901234567890123456789012345678901234567890 */\\n       \\\" --help    Print this help message and exit.\\\\n\\\");\\n#if defined(MUNIT_NL_LANGINFO)\\n  setlocale(LC_ALL, \\\"\\\");\\n  fputs((strcasecmp(\\\"UTF-8\\\", nl_langinfo(CODESET)) == 0) ? \\\"\\u00b5nit\\\" : \\\"munit\\\", stdout);\\n#else\\n  puts(\\\"munit\\\");\\n#endif\\n  printf(\\\" %d.%d.%d\\\\n\\\"\\n         \\\"Full documentation at: https://nemequ.github.io/munit/\\\\n\\\",\\n         (MUNIT_CURRENT_VERSION >> 16) & 0xff,\\n         (MUNIT_CURRENT_VERSION >> 8) & 0xff,\\n         (MUNIT_CURRENT_VERSION >> 0) & 0xff);\\n  for (arg = arguments ; arg != NULL && arg->name != NULL ; arg++)\\n    arg->write_help(arg, user_data);\\n}\\n\\nstatic const MunitArgument*\\nmunit_arguments_find(const MunitArgument arguments[], const char* name) {\\n  const MunitArgument* arg;\\n\\n  for (arg = arguments ; arg != NULL && arg->name != NULL ; arg++)\\n    if (strcmp(arg->name, name) == 0)\\n      return arg;\\n\\n  return NULL;\\n}\\n\\nstatic void\\nmunit_suite_list_tests(const MunitSuite* suite, munit_bool show_params, const char* prefix) {\\n  size_t pre_l;\\n  char* pre = munit_maybe_concat(&pre_l, (char*) prefix, (char*) suite->prefix);\\n  const MunitTest* test;\\n  const MunitParameterEnum* params;\\n  munit_bool first;\\n  char** val;\\n  const MunitSuite* child_suite;\\n\\n  for (test = suite->tests ;\\n       test != NULL && test->name != NULL ;\\n       test++) {\\n    if (pre != NULL)\\n      fputs(pre, stdout);\\n    puts(test->name);\\n\\n    if (show_params) {\\n      for (params = test->parameters ;\\n           params != NULL && params->name != NULL ;\\n           params++) {\\n        fprintf(stdout, \\\" - %s: \\\", params->name);\\n        if (params->values == NULL) {\\n          puts(\\\"Any\\\");\\n        } else {\\n          first = 1;\\n          for (val = params->values ;\\n               *val != NULL ;\\n               val++ ) {\\n            if(!first) {\\n              fputs(\\\", \\\", stdout);\\n            } else {\\n              first = 0;\\n            }\\n            fputs(*val, stdout);\\n          }\\n          putc('\\\\n', stdout);\\n        }\\n      }\\n    }\\n  }\\n\\n  for (child_suite = suite->suites ; child_suite != NULL && child_suite->prefix != NULL ; child_suite++) {\\n    munit_suite_list_tests(child_suite, show_params, pre);\\n  }\\n\\n  munit_maybe_free_concat(pre, prefix, suite->prefix);\\n}\\n\\nstatic munit_bool\\nmunit_stream_supports_ansi(FILE *stream) {\\n#if !defined(_WIN32)\\n  return isatty(fileno(stream));\\n#else\\n\\n#if !defined(__MINGW32__)\\n  size_t ansicon_size = 0;\\n#endif\\n\\n  if (isatty(fileno(stream))) {\\n#if !defined(__MINGW32__)\\n    getenv_s(&ansicon_size, NULL, 0, \\\"ANSICON\\\");\\n    return ansicon_size != 0;\\n#else\\n    return getenv(\\\"ANSICON\\\") != NULL;\\n#endif\\n  }\\n  return 0;\\n#endif\\n}\\n\\nint\\nmunit_suite_main_custom(const MunitSuite* suite, void* user_data,\\n                        int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)],\\n                        const MunitArgument arguments[]) {\\n  int result = EXIT_FAILURE;\\n  MunitTestRunner runner;\\n  size_t parameters_size = 0;\\n  size_t tests_size = 0;\\n  int arg;\\n\\n  char* envptr;\\n  unsigned long ts;\\n  char* endptr;\\n  unsigned long long iterations;\\n  MunitLogLevel level;\\n  const MunitArgument* argument;\\n  const char** runner_tests;\\n  unsigned int tests_run;\\n  unsigned int tests_total;\\n\\n  runner.prefix = NULL;\\n  runner.suite = NULL;\\n  runner.tests = NULL;\\n  runner.seed = 0;\\n  runner.iterations = 0;\\n  runner.parameters = NULL;\\n  runner.single_parameter_mode = 0;\\n  runner.user_data = NULL;\\n\\n  runner.report.successful = 0;\\n  runner.report.skipped = 0;\\n  runner.report.failed = 0;\\n  runner.report.errored = 0;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  runner.report.cpu_clock = 0;\\n  runner.report.wall_clock = 0;\\n#endif\\n\\n  runner.colorize = 0;\\n#if !defined(_WIN32)\\n  runner.fork = 1;\\n#else\\n  runner.fork = 0;\\n#endif\\n  runner.show_stderr = 0;\\n  runner.fatal_failures = 0;\\n  runner.suite = suite;\\n  runner.user_data = user_data;\\n  runner.seed = munit_rand_generate_seed();\\n  runner.colorize = munit_stream_supports_ansi(MUNIT_OUTPUT_FILE);\\n\\n  for (arg = 1 ; arg < argc ; arg++) {\\n    if (strncmp(\\\"--\\\", argv[arg], 2) == 0) {\\n      if (strcmp(\\\"seed\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        envptr = argv[arg + 1];\\n        ts = strtoul(argv[arg + 1], &envptr, 0);\\n        if (*envptr != '\\\\0' || ts > (~((munit_uint32_t) 0U))) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n        runner.seed = (munit_uint32_t) ts;\\n\\n        arg++;\\n      } else if (strcmp(\\\"iterations\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        endptr = argv[arg + 1];\\n        iterations = strtoul(argv[arg + 1], &endptr, 0);\\n        if (*endptr != '\\\\0' || iterations > UINT_MAX) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        runner.iterations = (unsigned int) iterations;\\n\\n        arg++;\\n      } else if (strcmp(\\\"param\\\", argv[arg] + 2) == 0) {\\n        if (arg + 2 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires two arguments\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        runner.parameters = realloc(runner.parameters, sizeof(MunitParameter) * (parameters_size + 2));\\n        if (runner.parameters == NULL) {\\n          munit_log_internal(MUNIT_LOG_ERROR, stderr, \\\"failed to allocate memory\\\");\\n          goto cleanup;\\n        }\\n        runner.parameters[parameters_size].name = (char*) argv[arg + 1];\\n        runner.parameters[parameters_size].value = (char*) argv[arg + 2];\\n        parameters_size++;\\n        runner.parameters[parameters_size].name = NULL;\\n        runner.parameters[parameters_size].value = NULL;\\n        arg += 2;\\n      } else if (strcmp(\\\"color\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(argv[arg + 1], \\\"always\\\") == 0)\\n          runner.colorize = 1;\\n        else if (strcmp(argv[arg + 1], \\\"never\\\") == 0)\\n          runner.colorize = 0;\\n        else if (strcmp(argv[arg + 1], \\\"auto\\\") == 0)\\n          runner.colorize = munit_stream_supports_ansi(MUNIT_OUTPUT_FILE);\\n        else {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        arg++;\\n      } else if (strcmp(\\\"help\\\", argv[arg] + 2) == 0) {\\n        munit_print_help(argc, argv, user_data, arguments);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else if (strcmp(\\\"single\\\", argv[arg] + 2) == 0) {\\n        runner.single_parameter_mode = 1;\\n      } else if (strcmp(\\\"show-stderr\\\", argv[arg] + 2) == 0) {\\n        runner.show_stderr = 1;\\n#if !defined(_WIN32)\\n      } else if (strcmp(\\\"no-fork\\\", argv[arg] + 2) == 0) {\\n        runner.fork = 0;\\n#endif\\n      } else if (strcmp(\\\"fatal-failures\\\", argv[arg] + 2) == 0) {\\n        runner.fatal_failures = 1;\\n      } else if (strcmp(\\\"log-visible\\\", argv[arg] + 2) == 0 ||\\n                 strcmp(\\\"log-fatal\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(argv[arg + 1], \\\"debug\\\") == 0)\\n          level = MUNIT_LOG_DEBUG;\\n        else if (strcmp(argv[arg + 1], \\\"info\\\") == 0)\\n          level = MUNIT_LOG_INFO;\\n        else if (strcmp(argv[arg + 1], \\\"warning\\\") == 0)\\n          level = MUNIT_LOG_WARNING;\\n        else if (strcmp(argv[arg + 1], \\\"error\\\") == 0)\\n          level = MUNIT_LOG_ERROR;\\n        else {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(\\\"log-visible\\\", argv[arg] + 2) == 0)\\n          munit_log_level_visible = level;\\n        else\\n          munit_log_level_fatal = level;\\n\\n        arg++;\\n      } else if (strcmp(\\\"list\\\", argv[arg] + 2) == 0) {\\n        munit_suite_list_tests(suite, 0, NULL);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else if (strcmp(\\\"list-params\\\", argv[arg] + 2) == 0) {\\n        munit_suite_list_tests(suite, 1, NULL);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else {\\n        argument = munit_arguments_find(arguments, argv[arg] + 2);\\n        if (argument == NULL) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"unknown argument ('%s')\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (!argument->parse_argument(suite, user_data, &arg, argc, argv))\\n          goto cleanup;\\n      }\\n    } else {\\n      runner_tests = realloc((void*) runner.tests, sizeof(char*) * (tests_size + 2));\\n      if (runner_tests == NULL) {\\n        munit_log_internal(MUNIT_LOG_ERROR, stderr, \\\"failed to allocate memory\\\");\\n        goto cleanup;\\n      }\\n      runner.tests = runner_tests;\\n      runner.tests[tests_size++] = argv[arg];\\n      runner.tests[tests_size] = NULL;\\n    }\\n  }\\n\\n  fflush(stderr);\\n  fprintf(MUNIT_OUTPUT_FILE, \\\"Running test suite with seed 0x%08\\\" PRIx32 \\\"...\\\\n\\\", runner.seed);\\n\\n  munit_test_runner_run(&runner);\\n\\n  tests_run = runner.report.successful + runner.report.failed + runner.report.errored;\\n  tests_total = tests_run + runner.report.skipped;\\n  if (tests_run == 0) {\\n    fprintf(stderr, \\\"No tests run, %d (100%%) skipped.\\\\n\\\", runner.report.skipped);\\n  } else {\\n    fprintf(MUNIT_OUTPUT_FILE, \\\"%d of %d (%0.0f%%) tests successful, %d (%0.0f%%) test skipped.\\\\n\\\",\\n            runner.report.successful, tests_run,\\n            (((double) runner.report.successful) / ((double) tests_run)) * 100.0,\\n            runner.report.skipped,\\n            (((double) runner.report.skipped) / ((double) tests_total)) * 100.0);\\n  }\\n\\n  if (runner.report.failed == 0 && runner.report.errored == 0) {\\n    result = EXIT_SUCCESS;\\n  }\\n\\n cleanup:\\n  free(runner.parameters);\\n  free((void*) runner.tests);\\n\\n  return result;\\n}\\n\\nint\\nmunit_suite_main(const MunitSuite* suite, void* user_data,\\n                 int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)]) {\\n  return munit_suite_main_custom(suite, user_data, argc, argv, NULL);\\n}\\n\", \"embeddings\": [0.020211558789014816, 0.13673560321331024, -0.02674209699034691, 0.06477174162864685, 0.310088574886322, -0.16771069169044495, 0.08953198790550232, 0.30692464113235474, 0.0019032210111618042, -0.1918519139289856, 0.04340821132063866, -0.122948057949543, -0.0207448061555624, 0.06730528175830841, 0.028848443180322647, -0.014642909169197083, 0.006570039317011833, 0.006866447627544403, 0.08588491380214691, -0.2468496859073639, -0.1584099978208542, 0.06940858066082001, 0.21813498437404633, 0.16393393278121948, 0.16850662231445312, -0.002123188227415085, 0.23611338436603546, 0.13732875883579254, 0.19115738570690155, -0.07556703686714172, 0.0366392508149147, -0.056780651211738586, 0.08342929184436798, -0.12482737004756927, 0.01668369397521019, 0.046311475336551666, 0.05905766040086746, 0.061109598726034164, -0.025498537346720695, 0.043581534177064896, -0.1909821778535843, 0.009198651649057865, 0.14766208827495575, 0.20683035254478455, 0.03841910511255264, 0.02236618660390377, 0.004732578992843628, 0.20810867846012115, -0.09743374586105347, 0.10340434312820435, 0.009733390063047409, -0.009997513145208359, -0.052983358502388, -0.0026585720479488373, -0.08338604867458344, -0.10700105875730515, 0.05647068843245506, 0.36948850750923157, 0.0019512102007865906, -0.033025629818439484, -0.0989689975976944, -0.018469199538230896, -0.11406359076499939, 0.04225168749690056, 0.06430307030677795, 0.026431070640683174, -0.19792991876602173, -0.04426993057131767, -0.0888512134552002, -0.012151237577199936, 0.039793796837329865, 0.007347262464463711, 0.03450455516576767, -0.14022643864154816, -0.11949385702610016, 0.0058417171239852905, 0.14304107427597046, 0.6457716822624207, -0.13096311688423157, 0.13894915580749512, 0.22841520607471466, -0.07205815613269806, 0.06745398789644241, 0.17509795725345612, 0.10653886198997498, 0.027642007917165756, -0.0458918958902359, -0.004709348082542419, 0.053976502269506454, 0.09366026520729065, 0.05602350831031799, 0.168989896774292, -0.05089413374662399, -0.011803466826677322, -0.009301550686359406, -0.014812961220741272, 0.00939517468214035, -0.34751057624816895, 0.02444520592689514, 0.3377925157546997, -0.06906209886074066, -0.07156530022621155, -0.1935531198978424, 0.021519023925065994, -0.00043161213397979736, 0.01687180995941162, 0.05605870485305786, 0.07851661741733551, 0.05423538759350777, -0.025617599487304688, 0.05499700456857681, 0.0641813799738884, -0.03802105784416199, 0.0407164990901947, 0.021962404251098633, -0.18108978867530823, 0.06748044490814209, -0.03099983185529709, 0.07952345907688141, 0.02162933722138405, 0.11446110904216766, 0.04060567170381546, -0.030597873032093048, -0.054825544357299805, -0.028351739048957825, 0.13895267248153687, -0.0012173354625701904, -0.19510644674301147, 0.09849102050065994, 0.1590094119310379, -0.035474151372909546, -0.21585845947265625, 0.04201196879148483, -0.0411420539021492, 0.15881229937076569, 0.013826003298163414, 0.009138405323028564, -0.0009967386722564697, 0.004455558955669403, -0.018391333520412445, -0.025326304137706757, 0.09405216574668884, 0.3599296808242798, -0.023909006267786026, 0.1280096471309662, -0.06402455270290375, 0.035426944494247437, 0.11205892264842987, -0.27619636058807373, -0.17157654464244843, 0.027245648205280304, -0.022319205105304718, 0.030047863721847534, -0.031836703419685364, -0.17535315454006195, 0.8087897896766663, 0.13048282265663147, -0.06908726692199707, -0.02248842641711235, -0.08084019273519516, 0.05394115298986435, -0.26161351799964905, -0.0041308291256427765, 0.07608151435852051, 0.09492215514183044, 0.18369458615779877, 0.02641911804676056, 0.07945447415113449, 0.0936480164527893, -0.006871085613965988, 0.02058614231646061, 0.01675107330083847, -0.13426975905895233, 0.14048470556735992, -0.052855439484119415, -0.06465994566679001, -0.19134245812892914, 0.06141604483127594, -0.07087498903274536, 0.06770544499158859, -0.04755614697933197, 0.034188829362392426, -0.15897756814956665, -0.04367697238922119, -0.016518764197826385, 0.020550543442368507, 0.06525155156850815, -0.06977544724941254, 0.11447633802890778, 0.05642106384038925, 0.031540121883153915, 0.05920323729515076, 0.159112349152565, -0.06146034598350525, -0.01827988028526306, 0.14798057079315186, -0.11336798220872879, -0.07662807404994965, 0.13147658109664917, -0.024816162884235382, -0.04111747443675995, -0.11945641785860062, 0.16223549842834473, -0.09088434278964996, 0.08959469199180603, 0.17177438735961914, -0.249167338013649, 0.027310147881507874, -0.0014634355902671814, -0.06857103854417801, -0.04622993245720863, 0.13752543926239014, 0.0948185920715332, 0.07602379471063614, -0.1073889434337616, -0.07253221422433853, 0.06217712163925171, 0.05714733898639679, -0.024048112332820892, -0.14224080741405487, 0.16288922727108002, 0.22661909461021423, -0.023483743891119957, -0.06223909556865692, -0.07394976913928986, 0.18058288097381592, 0.18883857131004333, -0.014669537544250488, 0.03418182581663132, 0.08211367577314377, 0.22238492965698242, 0.15379080176353455, -0.12990109622478485, 0.11533014476299286, 0.014643453061580658, -0.1796351671218872, -0.10040581226348877, 0.040246229618787766, 0.029001031070947647, -0.0503341443836689, 0.015040181577205658, 0.08841168880462646, 0.1302632838487625, 0.25084301829338074, 0.06639299541711807, 0.08817611634731293, -0.17818690836429596, -0.042195092886686325, -0.06783566623926163, 0.05033919960260391, -0.06704005599021912, -0.07437226921319962, -0.04871702194213867, -0.05705539509654045, -0.13274799287319183, -0.04493062570691109, -0.10552013665437698, 0.03956006467342377, 0.03665949031710625, 0.14833728969097137, -0.10036741942167282, -0.12346749007701874, 0.03386043384671211, -0.012673258781433105, -0.12154655903577805, -0.28952643275260925, 0.0005555413663387299, 0.057741835713386536, 0.018008150160312653, -0.0040351226925849915, 0.04353669285774231, -0.05632241070270538, 0.2062544822692871, 0.11484440416097641, 0.06805238872766495, 0.041518863290548325, 0.07441858947277069, 0.06792508065700531, -0.06120700389146805, 0.0012593623250722885, -0.03892854228615761, 0.14733925461769104, -0.06469753384590149, -0.03320583701133728, -0.03470303863286972, 0.09162398427724838, -0.022006165236234665, 0.00032601505517959595, 0.028050582855939865, -0.01103171706199646, 0.05252212658524513, 0.04781294986605644, 0.03754822537302971, 0.1348142921924591, -0.04798907786607742, 0.10481809824705124, 0.16932077705860138, -0.02298593521118164, 0.057499855756759644, -0.1688324213027954, 0.003448888659477234, -0.14324583113193512, -0.003386924508959055, -0.09744014590978622, 0.30860888957977295, -0.1496429443359375, 0.0369492769241333, 0.050527457147836685, 0.29064425826072693, 0.040073588490486145, 0.022636709734797478, 0.07065093517303467, -0.0867626890540123, 0.16984331607818604, -0.10261411964893341, -0.02861139550805092, 0.021634560078382492, -0.09675553441047668, 0.03880702331662178, -0.08544570207595825, -0.037079792469739914, 0.09995865821838379, 0.11237882077693939, 0.11493581533432007, 0.00426817499101162, 0.14601397514343262, 0.1113559752702713, -0.023229364305734634, -0.07816850394010544, 0.7731255888938904, -0.5678173899650574, 0.12643367052078247, -0.14159925282001495, 0.295906662940979, 0.0012218654155731201, 0.1893606185913086, 0.019056353718042374, 0.09559677541255951, 0.1498449742794037, 0.10741597414016724, -0.11476339399814606, -0.007113313302397728, -0.051751509308815, 0.17402046918869019, 0.08085509389638901, 0.19677206873893738, 0.08597691357135773, -0.061505090445280075, 0.1030680313706398, -0.08614178001880646, -0.1115514487028122, 0.038535527884960175, 0.010722726583480835, -0.11321455985307693, 0.12575632333755493, 0.2931629717350006, -0.07066275179386139, -0.03942210599780083, 0.012241258285939693, 0.057983867824077606, 0.10556593537330627, -0.07157168537378311, 0.1266346573829651, -0.11774041503667831, 0.27162742614746094, -0.24452565610408783, -0.3275699317455292, 0.04517066478729248, -0.10730378329753876, 0.08541765809059143, 0.10175824165344238, 0.24442002177238464, 0.10498329252004623, -0.13820430636405945, 0.05072811245918274, 0.0203542560338974, -0.018169380724430084, 0.04784851521253586, 0.024348121136426926, 0.1801665723323822, 0.03684929385781288, 0.024961397051811218, 0.022035926580429077, 0.008675098419189453, 0.03186088055372238, -0.16182979941368103, 0.24284769594669342, 0.19693413376808167, 0.17017649114131927, -0.08589345216751099, 0.14431647956371307, -0.054826654493808746, 0.0047727711498737335, -0.03309493139386177, 0.0033610910177230835, 0.014057289808988571, -0.152891606092453, 0.20067381858825684, -0.1138787791132927, -0.157698392868042, 0.1020037978887558, 0.14828148484230042, -0.05306145176291466, 0.10254593938589096, 0.15097884833812714, 0.10243487358093262, 0.15641044080257416, -0.14667022228240967, -0.1179424375295639, -0.18580865859985352, 0.04472588747739792, 0.0281587615609169, 0.02422281727194786, -0.07613222301006317, 0.10389531403779984, -0.07478929311037064, 0.004452066496014595, -0.1809050291776657, -0.07639198750257492, 0.08944191783666611, 0.15960243344306946, 0.11998533457517624, 0.018158260732889175, -0.12031879276037216, 0.006331145763397217, -0.023253362625837326, -0.005921952426433563, -0.039833590388298035, 0.13740341365337372, -0.09190694987773895, 0.055298447608947754, 0.3091988265514374, 0.0944209173321724, 0.14895743131637573, 0.06336723268032074, -0.08914253860712051, -0.08852064609527588, -0.06677809357643127, 0.00986497662961483, 0.028687113896012306, 0.029932057484984398, 0.04614333063364029, 0.019989661872386932, 0.024591654539108276, -0.05460553988814354, -0.11648016422986984, 0.4193060100078583, 0.08683004975318909, -0.12000931799411774, 0.06238819658756256, -0.12973622977733612, 0.014264270663261414, -0.1287887990474701, -0.3667472004890442, 0.12288916856050491, 0.15299777686595917, 0.1281631886959076, -0.005714520812034607, 0.037223055958747864, 0.005025438964366913, 0.03175252676010132, 0.11749213188886642, -0.023035015910863876, -0.15513189136981964, 0.03639017045497894, -0.0638953223824501, 0.13959752023220062, 0.06197836995124817, 0.12665313482284546, 0.12027566134929657, -0.0017513111233711243, 0.12246866524219513, 0.014563032425940037, -0.16257159411907196, 0.0913705974817276, -0.0035597309470176697, 0.011158832348883152, -0.1259264349937439, 0.09354886412620544, -0.19258005917072296, -0.03217514976859093, 0.09070329368114471, 0.15331701934337616, 0.01353512704372406, 0.02580982819199562, -0.10124775022268295, 0.2038106471300125, 0.15656130015850067, -0.15632329881191254, 0.03272644430398941, 0.014390561729669571, -0.010221807286143303, 0.05988981947302818, 0.08308631181716919, 0.26740604639053345, 0.14877662062644958, 0.13485383987426758, 0.11355125159025192, 0.20658093690872192, -0.10971906781196594, -7.899850606918335e-05, 0.12913168966770172, 0.08840684592723846, -0.005101185292005539, -0.11171500384807587, -0.10733845084905624, 0.028337499126791954, 0.14414066076278687, 0.04113581031560898, -0.16402244567871094, -0.03736426681280136, -0.08484522253274918, 0.12432315945625305, 0.011502426117658615, 0.05175764858722687, -0.041484951972961426, 0.0377902016043663, 0.03401470556855202, 0.05334046855568886, 0.2660633623600006, -0.13227804005146027, -0.15611407160758972, -0.03731567785143852, 0.036094602197408676, -0.11722331494092941, 0.02366240695118904, 0.11816670745611191, -0.041730768978595734, 0.10523425787687302, 0.10320281982421875, 0.047503985464572906, 0.010469983331859112, 0.07561272382736206, 0.12789276242256165, -0.020396951586008072, 0.09867677092552185, 0.009541155770421028, -0.05272265523672104, 0.12957139313220978, -0.05057796835899353, -0.1984403282403946, -0.12094862014055252, 0.11970195174217224, -0.04057462140917778, 0.13540837168693542, -0.012393351644277573, 0.18445032835006714, 0.06590356677770615, 0.011719509959220886, -0.0046341195702552795, -0.1194823831319809, -0.8399017453193665, 0.014852089807391167, 0.0752275213599205, -0.012482568621635437, 0.06976047903299332, 0.09172747284173965, 0.05844472348690033, 0.05801750347018242, 0.11334367096424103, 0.012354535982012749, -0.04748506098985672, 0.12082980573177338, 0.1158548966050148, -0.008255715481936932, -0.049056727439165115, 0.05997685715556145, 0.10461414605379105, -0.20887494087219238, 0.18636995553970337, -0.10803937166929245, -0.0616995170712471, 0.014104705303907394, 0.19858020544052124, 0.008726179599761963, 0.007925570011138916, 0.24447134137153625, 0.07782860845327377, 0.16507506370544434, -0.047751426696777344, 0.14675521850585938, 0.24887818098068237, 0.05810887739062309, -0.23034578561782837, 0.07788143306970596, 0.07827212661504745, 0.179391011595726, 0.176899254322052, 13.872857093811035, -0.11833608895540237, 0.16195568442344666, -0.09866844862699509, -0.03711070120334625, 0.01020110584795475, -0.11853759735822678, 0.05400066822767258, -0.06531882286071777, -0.02878754585981369, 0.10092638432979584, -0.09026474505662918, -0.03586990386247635, 0.07088195532560349, -0.01612677425146103, -0.041108131408691406, 0.04434090852737427, -0.005248477682471275, 0.16554591059684753, 0.033823344856500626, -0.0838296115398407, -0.08869622647762299, 0.027428772300481796, -0.18870215117931366, 0.005610382650047541, 0.006946824491024017, 0.0967157632112503, 0.0654016062617302, 0.05008557811379433, 0.03867769241333008, 0.22075030207633972, 0.17651987075805664, 0.09783224016427994, -0.032683469355106354, -0.04498084634542465, -0.2178252637386322, -0.4318905472755432, -0.13716842234134674, 0.03192759305238724, -0.03979804366827011, -0.05262567102909088, -0.037243977189064026, 0.1373656988143921, -0.05187155306339264, 0.14629603922367096, 0.0751921758055687, -0.19596105813980103, 0.18003085255622864, -0.05405183881521225, -0.07932360470294952, 0.1644459366798401, 0.11918517202138901, 0.20855258405208588, 0.06984123587608337, -0.09002210944890976, -0.14123955368995667, 0.22140562534332275, 0.03167757764458656, 0.04661937430500984, 0.2226567268371582, -0.030119217932224274, -0.05707446485757828, -0.040501918643713, -0.07166530191898346, -0.035641804337501526, 0.0022016391158103943, 0.12192631512880325, 0.08272510766983032, -0.04877851903438568, 0.011181853711605072, 0.11381906270980835, -0.06609123200178146, 0.022737422958016396, 0.030469417572021484, -0.06176052242517471, 0.1120222732424736, -0.1081329956650734, 0.02689562737941742, 0.04910210147500038, -0.2054755538702011, -0.022770121693611145, 0.004941120743751526, -0.1792181432247162, -0.04106133431196213, -0.19071653485298157, 0.07736758142709732, -0.10614345967769623, 0.21755582094192505, 0.15057356655597687, -0.003306800499558449, -0.1357007622718811, 0.0671047642827034, 0.02684641256928444, -0.13275682926177979, 0.213265061378479, -0.09866470843553543, 0.03279072791337967, -0.14237649738788605, 0.0899655744433403, 0.12449675053358078, -0.04355476051568985, -0.06517739593982697, 0.007157567888498306, 0.0996479019522667, -0.1503422111272812, 0.018825918436050415, -0.058161117136478424, -0.07014831900596619, -0.007714413106441498, 0.05830869823694229, 0.06555774062871933, 0.1501302719116211, 0.08516956120729446, -0.1824008971452713, -0.1579335480928421, -0.02933017909526825, 0.07898493111133575, 0.034745581448078156, 0.23840680718421936, 0.14115116000175476, 0.20764470100402832, 0.03168964385986328, -0.15174536406993866, -0.06550368666648865, 0.09206701070070267, -0.10173902660608292, 0.009217126294970512, 0.11069348454475403, 0.1115112230181694, -0.011128697544336319, 0.12430019676685333, -0.10532311350107193, 0.32979369163513184, 0.15999990701675415, 0.04903104156255722, -0.010110922157764435, 0.015992961823940277, 0.04510946199297905, 0.21515487134456635, 0.14276337623596191, 0.08362098038196564, 0.0067882537841796875, 0.15911976993083954, -0.11746816337108612, -0.10507760941982269, 0.15036538243293762, 0.24272099137306213, -0.014413800090551376, -0.05084555968642235, 0.07737212628126144, 0.10683868080377579, 0.22409361600875854, -0.08651463687419891, -0.04982256889343262, -0.16350573301315308, -0.1835644543170929, -0.05912908539175987, 0.061824433505535126, -0.0037572942674160004, -0.04310482740402222, 0.22226664423942566, -0.4269791543483734, 0.022383153438568115, -0.1701526790857315, -0.0842626541852951, 0.10435269773006439, 0.12668737769126892, 0.053601495921611786, 0.14890611171722412, -0.08384112268686295, 0.07317797839641571, 0.06420253962278366, -0.18137434124946594, 0.03015216253697872, -0.08652363717556, 0.03530716150999069, 0.19554689526557922, -0.2559300363063812, -0.14094164967536926, 0.042608678340911865]}"
"{\"sha\": \"00ede07ca6c77e3b71aaa699b2c48b9718700cc8\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"test/unit/munit.c\", \"func_name\": \"munit_maybe_concat\", \"original_string\": \"static char*\\nmunit_maybe_concat(size_t* len, char* prefix, char* suffix) {\\n  char* res;\\n  size_t res_l;\\n  const size_t prefix_l = prefix != NULL ? strlen(prefix) : 0;\\n  const size_t suffix_l = suffix != NULL ? strlen(suffix) : 0;\\n  if (prefix_l == 0 && suffix_l == 0) {\\n    res = NULL;\\n    res_l = 0;\\n  } else if (prefix_l == 0 && suffix_l != 0) {\\n    res = suffix;\\n    res_l = suffix_l;\\n  } else if (prefix_l != 0 && suffix_l == 0) {\\n    res = prefix;\\n    res_l = prefix_l;\\n  } else {\\n    res_l = prefix_l + suffix_l;\\n    res = malloc(res_l + 1);\\n    memcpy(res, prefix, prefix_l);\\n    memcpy(res + prefix_l, suffix, suffix_l);\\n    res[res_l] = 0;\\n  }\\n\\n  if (len != NULL)\\n    *len = res_l;\\n\\n  return res;\\n}\", \"code_tokens\": [\"static\", \"char\", \"*\", \"munit_maybe_concat\", \"(\", \"size_t\", \"*\", \"len\", \",\", \"char\", \"*\", \"prefix\", \",\", \"char\", \"*\", \"suffix\", \")\", \"{\", \"char\", \"*\", \"res\", \";\", \"size_t\", \"res_l\", \";\", \"const\", \"size_t\", \"prefix_l\", \"=\", \"prefix\", \"!=\", \"NULL\", \"?\", \"strlen\", \"(\", \"prefix\", \")\", \":\", \"0\", \";\", \"const\", \"size_t\", \"suffix_l\", \"=\", \"suffix\", \"!=\", \"NULL\", \"?\", \"strlen\", \"(\", \"suffix\", \")\", \":\", \"0\", \";\", \"if\", \"(\", \"prefix_l\", \"==\", \"0\", \"&&\", \"suffix_l\", \"==\", \"0\", \")\", \"{\", \"res\", \"=\", \"NULL\", \";\", \"res_l\", \"=\", \"0\", \";\", \"}\", \"else\", \"if\", \"(\", \"prefix_l\", \"==\", \"0\", \"&&\", \"suffix_l\", \"!=\", \"0\", \")\", \"{\", \"res\", \"=\", \"suffix\", \";\", \"res_l\", \"=\", \"suffix_l\", \";\", \"}\", \"else\", \"if\", \"(\", \"prefix_l\", \"!=\", \"0\", \"&&\", \"suffix_l\", \"==\", \"0\", \")\", \"{\", \"res\", \"=\", \"prefix\", \";\", \"res_l\", \"=\", \"prefix_l\", \";\", \"}\", \"else\", \"{\", \"res_l\", \"=\", \"prefix_l\", \"+\", \"suffix_l\", \";\", \"res\", \"=\", \"malloc\", \"(\", \"res_l\", \"+\", \"1\", \")\", \";\", \"memcpy\", \"(\", \"res\", \",\", \"prefix\", \",\", \"prefix_l\", \")\", \";\", \"memcpy\", \"(\", \"res\", \"+\", \"prefix_l\", \",\", \"suffix\", \",\", \"suffix_l\", \")\", \";\", \"res\", \"[\", \"res_l\", \"]\", \"=\", \"0\", \";\", \"}\", \"if\", \"(\", \"len\", \"!=\", \"NULL\", \")\", \"*\", \"len\", \"=\", \"res_l\", \";\", \"return\", \"res\", \";\", \"}\"], \"docstring\": \"/* Concatenate two strings, but just return one of the components\\n * unaltered if the other is NULL or \\\"\\\". */\", \"docstring_tokens\": [\"/\", \"*\", \"Concatenate\", \"two\", \"strings\", \"but\", \"just\", \"return\", \"one\", \"of\", \"the\", \"components\", \"*\", \"unaltered\", \"if\", \"the\", \"other\", \"is\", \"NULL\", \"or\", \"\\\"\", \"\\\"\", \".\", \"*\", \"/\"], \"raw_contents\": \"/* Copyright (c) 2013-2018 Evan Nemerson <evan@nemerson.com>\\n *\\n * Permission is hereby granted, free of charge, to any person\\n * obtaining a copy of this software and associated documentation\\n * files (the \\\"Software\\\"), to deal in the Software without\\n * restriction, including without limitation the rights to use, copy,\\n * modify, merge, publish, distribute, sublicense, and/or sell copies\\n * of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be\\n * included in all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND,\\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n * SOFTWARE.\\n */\\n\\n/*** Configuration ***/\\n\\n/* This is just where the output from the test goes.  It's really just\\n * meant to let you choose stdout or stderr, but if anyone really want\\n * to direct it to a file let me know, it would be fairly easy to\\n * support. */\\n#if !defined(MUNIT_OUTPUT_FILE)\\n#  define MUNIT_OUTPUT_FILE stdout\\n#endif\\n\\n/* This is a bit more useful; it tells \\u00b5nit how to format the seconds in\\n * timed tests.  If your tests run for longer you might want to reduce\\n * it, and if your computer is really fast and your tests are tiny you\\n * can increase it. */\\n#if !defined(MUNIT_TEST_TIME_FORMAT)\\n#  define MUNIT_TEST_TIME_FORMAT \\\"0.8f\\\"\\n#endif\\n\\n/* If you have long test names you might want to consider bumping\\n * this.  The result information takes 43 characters. */\\n#if !defined(MUNIT_TEST_NAME_LEN)\\n#  define MUNIT_TEST_NAME_LEN 37\\n#endif\\n\\n/* If you don't like the timing information, you can disable it by\\n * defining MUNIT_DISABLE_TIMING. */\\n#if !defined(MUNIT_DISABLE_TIMING)\\n#  define MUNIT_ENABLE_TIMING\\n#endif\\n\\n/*** End configuration ***/\\n\\n#if defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE < 200809L)\\n#  undef _POSIX_C_SOURCE\\n#endif\\n#if !defined(_POSIX_C_SOURCE)\\n#  define _POSIX_C_SOURCE 200809L\\n#endif\\n\\n/* Solaris freaks out if you try to use a POSIX or SUS standard without\\n * the \\\"right\\\" C standard. */\\n#if defined(_XOPEN_SOURCE)\\n#  undef _XOPEN_SOURCE\\n#endif\\n\\n#if defined(__STDC_VERSION__)\\n#  if __STDC_VERSION__ >= 201112L\\n#    define _XOPEN_SOURCE 700\\n#  elif __STDC_VERSION__ >= 199901L\\n#    define _XOPEN_SOURCE 600\\n#  endif\\n#endif\\n\\n/* Because, according to Microsoft, POSIX is deprecated.  You've got\\n * to appreciate the chutzpah. */\\n#if defined(_MSC_VER) && !defined(_CRT_NONSTDC_NO_DEPRECATE)\\n#  define _CRT_NONSTDC_NO_DEPRECATE\\n#endif\\n\\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\\n#  include <stdbool.h>\\n#elif defined(_WIN32)\\n/* https://msdn.microsoft.com/en-us/library/tf4dy80a.aspx */\\n#endif\\n\\n#include <limits.h>\\n#include <time.h>\\n#include <errno.h>\\n#include <string.h>\\n#include <stdlib.h>\\n#include <stdio.h>\\n#include <stdarg.h>\\n#include <setjmp.h>\\n\\n#if !defined(MUNIT_NO_NL_LANGINFO) && !defined(_WIN32)\\n#define MUNIT_NL_LANGINFO\\n#include <locale.h>\\n#include <langinfo.h>\\n#include <strings.h>\\n#endif\\n\\n#if !defined(_WIN32)\\n#  include <unistd.h>\\n#  include <sys/types.h>\\n#  include <sys/wait.h>\\n#else\\n#  include <windows.h>\\n#  include <io.h>\\n#  include <fcntl.h>\\n#  if !defined(STDERR_FILENO)\\n#    define STDERR_FILENO _fileno(stderr)\\n#  endif\\n#endif\\n\\n#include \\\"munit.h\\\"\\n\\n#define MUNIT_STRINGIFY(x) #x\\n#define MUNIT_XSTRINGIFY(x) MUNIT_STRINGIFY(x)\\n\\n#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__SUNPRO_CC) || defined(__IBMCPP__)\\n#  define MUNIT_THREAD_LOCAL __thread\\n#elif (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201102L)) || defined(_Thread_local)\\n#  define MUNIT_THREAD_LOCAL _Thread_local\\n#elif defined(_WIN32)\\n#  define MUNIT_THREAD_LOCAL __declspec(thread)\\n#endif\\n\\n/* MSVC 12.0 will emit a warning at /W4 for code like 'do { ... }\\n * while (0)', or 'do { ... } while (1)'.  I'm pretty sure nobody\\n * at Microsoft compiles with /W4. */\\n#if defined(_MSC_VER) && (_MSC_VER <= 1800)\\n#pragma warning(disable: 4127)\\n#endif\\n\\n#if defined(_WIN32) || defined(__EMSCRIPTEN__)\\n#  define MUNIT_NO_FORK\\n#endif\\n\\n#if defined(__EMSCRIPTEN__)\\n#  define MUNIT_NO_BUFFER\\n#endif\\n\\n/*** Logging ***/\\n\\nstatic MunitLogLevel munit_log_level_visible = MUNIT_LOG_INFO;\\nstatic MunitLogLevel munit_log_level_fatal = MUNIT_LOG_ERROR;\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\nstatic MUNIT_THREAD_LOCAL munit_bool munit_error_jmp_buf_valid = 0;\\nstatic MUNIT_THREAD_LOCAL jmp_buf munit_error_jmp_buf;\\n#endif\\n\\n/* At certain warning levels, mingw will trigger warnings about\\n * suggesting the format attribute, which we've explicity *not* set\\n * because it will then choke on our attempts to use the MS-specific\\n * I64 modifier for size_t (which we have to use since MSVC doesn't\\n * support the C99 z modifier). */\\n\\n#if defined(__MINGW32__) || defined(__MINGW64__)\\n#  pragma GCC diagnostic push\\n#  pragma GCC diagnostic ignored \\\"-Wsuggest-attribute=format\\\"\\n#endif\\n\\nMUNIT_PRINTF(5,0)\\nstatic void\\nmunit_logf_exv(MunitLogLevel level, FILE* fp, const char* filename, int line, const char* format, va_list ap) {\\n  if (level < munit_log_level_visible)\\n    return;\\n\\n  switch (level) {\\n    case MUNIT_LOG_DEBUG:\\n      fputs(\\\"Debug\\\", fp);\\n      break;\\n    case MUNIT_LOG_INFO:\\n      fputs(\\\"Info\\\", fp);\\n      break;\\n    case MUNIT_LOG_WARNING:\\n      fputs(\\\"Warning\\\", fp);\\n      break;\\n    case MUNIT_LOG_ERROR:\\n      fputs(\\\"Error\\\", fp);\\n      break;\\n    default:\\n      munit_logf_ex(MUNIT_LOG_ERROR, filename, line, \\\"Invalid log level (%d)\\\", level);\\n      return;\\n  }\\n\\n  fputs(\\\": \\\", fp);\\n  if (filename != NULL)\\n    fprintf(fp, \\\"%s:%d: \\\", filename, line);\\n  vfprintf(fp, format, ap);\\n  fputc('\\\\n', fp);\\n}\\n\\nMUNIT_PRINTF(3,4)\\nstatic void\\nmunit_logf_internal(MunitLogLevel level, FILE* fp, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(level, fp, NULL, 0, format, ap);\\n  va_end(ap);\\n}\\n\\nstatic void\\nmunit_log_internal(MunitLogLevel level, FILE* fp, const char* message) {\\n  munit_logf_internal(level, fp, \\\"%s\\\", message);\\n}\\n\\nvoid\\nmunit_logf_ex(MunitLogLevel level, const char* filename, int line, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(level, stderr, filename, line, format, ap);\\n  va_end(ap);\\n\\n  if (level >= munit_log_level_fatal) {\\n#if defined(MUNIT_THREAD_LOCAL)\\n    if (munit_error_jmp_buf_valid)\\n      longjmp(munit_error_jmp_buf, 1);\\n#endif\\n    abort();\\n  }\\n}\\n\\nvoid\\nmunit_errorf_ex(const char* filename, int line, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(MUNIT_LOG_ERROR, stderr, filename, line, format, ap);\\n  va_end(ap);\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\n  if (munit_error_jmp_buf_valid)\\n    longjmp(munit_error_jmp_buf, 1);\\n#endif\\n  abort();\\n}\\n\\n#if defined(__MINGW32__) || defined(__MINGW64__)\\n#pragma GCC diagnostic pop\\n#endif\\n\\n#if !defined(MUNIT_STRERROR_LEN)\\n#  define MUNIT_STRERROR_LEN 80\\n#endif\\n\\nstatic void\\nmunit_log_errno(MunitLogLevel level, FILE* fp, const char* msg) {\\n#if defined(MUNIT_NO_STRERROR_R) || (defined(__MINGW32__) && !defined(MINGW_HAS_SECURE_API))\\n  munit_logf_internal(level, fp, \\\"%s: %s (%d)\\\", msg, strerror(errno), errno);\\n#else\\n  char munit_error_str[MUNIT_STRERROR_LEN];\\n  munit_error_str[0] = '\\\\0';\\n\\n#if !defined(_WIN32)\\n  strerror_r(errno, munit_error_str, MUNIT_STRERROR_LEN);\\n#else\\n  strerror_s(munit_error_str, MUNIT_STRERROR_LEN, errno);\\n#endif\\n\\n  munit_logf_internal(level, fp, \\\"%s: %s (%d)\\\", msg, munit_error_str, errno);\\n#endif\\n}\\n\\n/*** Memory allocation ***/\\n\\nvoid*\\nmunit_malloc_ex(const char* filename, int line, size_t size) {\\n  void* ptr;\\n\\n  if (size == 0)\\n    return NULL;\\n\\n  ptr = calloc(1, size);\\n  if (MUNIT_UNLIKELY(ptr == NULL)) {\\n    munit_logf_ex(MUNIT_LOG_ERROR, filename, line, \\\"Failed to allocate %\\\" MUNIT_SIZE_MODIFIER \\\"u bytes.\\\", size);\\n  }\\n\\n  return ptr;\\n}\\n\\n/*** Timer code ***/\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n\\n#define psnip_uint64_t munit_uint64_t\\n#define psnip_uint32_t munit_uint32_t\\n\\n/* Code copied from portable-snippets\\n * <https://github.com/nemequ/portable-snippets/>.  If you need to\\n * change something, please do it there so we can keep the code in\\n * sync. */\\n\\n/* Clocks (v1)\\n * Portable Snippets - https://gitub.com/nemequ/portable-snippets\\n * Created by Evan Nemerson <evan@nemerson.com>\\n *\\n *   To the extent possible under law, the authors have waived all\\n *   copyright and related or neighboring rights to this code.  For\\n *   details, see the Creative Commons Zero 1.0 Universal license at\\n *   https://creativecommons.org/publicdomain/zero/1.0/\\n */\\n\\n#if !defined(PSNIP_CLOCK_H)\\n#define PSNIP_CLOCK_H\\n\\n#if !defined(psnip_uint64_t)\\n#  include \\\"../exact-int/exact-int.h\\\"\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_STATIC_INLINE)\\n#  if defined(__GNUC__)\\n#    define PSNIP_CLOCK__COMPILER_ATTRIBUTES __attribute__((__unused__))\\n#  else\\n#    define PSNIP_CLOCK__COMPILER_ATTRIBUTES\\n#  endif\\n\\n#  define PSNIP_CLOCK__FUNCTION PSNIP_CLOCK__COMPILER_ATTRIBUTES static\\n#endif\\n\\nenum PsnipClockType {\\n  /* This clock provides the current time, in units since 1970-01-01\\n   * 00:00:00 UTC not including leap seconds.  In other words, UNIX\\n   * time.  Keep in mind that this clock doesn't account for leap\\n   * seconds, and can go backwards (think NTP adjustments). */\\n  PSNIP_CLOCK_TYPE_WALL = 1,\\n  /* The CPU time is a clock which increases only when the current\\n   * process is active (i.e., it doesn't increment while blocking on\\n   * I/O). */\\n  PSNIP_CLOCK_TYPE_CPU = 2,\\n  /* Monotonic time is always running (unlike CPU time), but it only\\n     ever moves forward unless you reboot the system.  Things like NTP\\n     adjustments have no effect on this clock. */\\n  PSNIP_CLOCK_TYPE_MONOTONIC = 3\\n};\\n\\nstruct PsnipClockTimespec {\\n  psnip_uint64_t seconds;\\n  psnip_uint64_t nanoseconds;\\n};\\n\\n/* Methods we support: */\\n\\n#define PSNIP_CLOCK_METHOD_CLOCK_GETTIME                   1\\n#define PSNIP_CLOCK_METHOD_TIME                            2\\n#define PSNIP_CLOCK_METHOD_GETTIMEOFDAY                    3\\n#define PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER         4\\n#define PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME              5\\n#define PSNIP_CLOCK_METHOD_CLOCK                           6\\n#define PSNIP_CLOCK_METHOD_GETPROCESSTIMES                 7\\n#define PSNIP_CLOCK_METHOD_GETRUSAGE                       8\\n#define PSNIP_CLOCK_METHOD_GETSYSTEMTIMEPRECISEASFILETIME  9\\n#define PSNIP_CLOCK_METHOD_GETTICKCOUNT64                 10\\n\\n#include <assert.h>\\n\\n#if defined(HEDLEY_UNREACHABLE)\\n#  define PSNIP_CLOCK_UNREACHABLE() HEDLEY_UNREACHABLE()\\n#else\\n#  define PSNIP_CLOCK_UNREACHABLE() assert(0)\\n#endif\\n\\n/* Choose an implementation */\\n\\n/* #undef PSNIP_CLOCK_WALL_METHOD */\\n/* #undef PSNIP_CLOCK_CPU_METHOD */\\n/* #undef PSNIP_CLOCK_MONOTONIC_METHOD */\\n\\n/* We want to be able to detect the libc implementation, so we include\\n   <limits.h> (<features.h> isn't available everywhere). */\\n\\n#if defined(__unix__) || defined(__unix) || defined(__linux__)\\n#  include <limits.h>\\n#  include <unistd.h>\\n#endif\\n\\n#if defined(_POSIX_TIMERS) && (_POSIX_TIMERS > 0)\\n/* These are known to work without librt.  If you know of others\\n * please let us know so we can add them. */\\n#  if \\\\\\n  (defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 17))) || \\\\\\n  (defined(__FreeBSD__))\\n#    define PSNIP_CLOCK_HAVE_CLOCK_GETTIME\\n#  elif !defined(PSNIP_CLOCK_NO_LIBRT)\\n#    define PSNIP_CLOCK_HAVE_CLOCK_GETTIME\\n#  endif\\n#endif\\n\\n#if defined(_WIN32)\\n#  if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#    define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n#  endif\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n#  endif\\n#endif\\n\\n#if defined(__MACH__) && !defined(__gnu_hurd__)\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n#  endif\\n#endif\\n\\n#if defined(PSNIP_CLOCK_HAVE_CLOCK_GETTIME)\\n#  include <time.h>\\n#  if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#    if defined(CLOCK_REALTIME_PRECISE)\\n#      define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_WALL CLOCK_REALTIME_PRECISE\\n#    elif !defined(__sun)\\n#      define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_WALL CLOCK_REALTIME\\n#    endif\\n#  endif\\n#  if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#    if defined(_POSIX_CPUTIME) || defined(CLOCK_PROCESS_CPUTIME_ID)\\n#      define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_CPU CLOCK_PROCESS_CPUTIME_ID\\n#    elif defined(CLOCK_VIRTUAL)\\n#      define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_CPU CLOCK_VIRTUAL\\n#    endif\\n#  endif\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    if defined(CLOCK_MONOTONIC_RAW)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC\\n#    elif defined(CLOCK_MONOTONIC_PRECISE)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC_PRECISE\\n#    elif defined(_POSIX_MONOTONIC_CLOCK) || defined(CLOCK_MONOTONIC)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC\\n#    endif\\n#  endif\\n#endif\\n\\n#if defined(_POSIX_VERSION) && (_POSIX_VERSION >= 200112L)\\n#  if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#    define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n#  endif\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#  define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_TIME\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#  define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK\\n#endif\\n\\n/* Primarily here for testing. */\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD) && defined(PSNIP_CLOCK_REQUIRE_MONOTONIC)\\n#  error No monotonic clock found.\\n#endif\\n\\n/* Implementations */\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_TIME))\\n#  include <time.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETTIMEOFDAY)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETTIMEOFDAY)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY))\\n#  include <sys/time.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETTICKCOUNT64)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETTICKCOUNT64)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64))\\n#  include <windows.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETRUSAGE)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETRUSAGE)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETRUSAGE))\\n#  include <sys/time.h>\\n#  include <sys/resource.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME))\\n#  include <CoreServices/CoreServices.h>\\n#  include <mach/mach.h>\\n#  include <mach/mach_time.h>\\n#endif\\n\\n/*** Implementations ***/\\n\\n#define PSNIP_CLOCK_NSEC_PER_SEC ((psnip_uint32_t) (1000000000ULL))\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME))\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock__clock_getres (clockid_t clk_id) {\\n  struct timespec res;\\n  int r;\\n\\n  r = clock_getres(clk_id, &res);\\n  if (r != 0)\\n    return 0;\\n\\n  return (psnip_uint32_t) (PSNIP_CLOCK_NSEC_PER_SEC / res.tv_nsec);\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock__clock_gettime (clockid_t clk_id, struct PsnipClockTimespec* res) {\\n  struct timespec ts;\\n\\n  if (clock_gettime(clk_id, &ts) != 0)\\n    return -10;\\n\\n  res->seconds = (psnip_uint64_t) (ts.tv_sec);\\n  res->nanoseconds = (psnip_uint64_t) (ts.tv_nsec);\\n\\n  return 0;\\n}\\n#endif\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_wall_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_WALL);\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n  return 1000000;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_TIME\\n  return 1;\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_wall_get_time (struct PsnipClockTimespec* res) {\\n  (void) res;\\n\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n  return -2;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_WALL, res);\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_TIME\\n  res->seconds = time(NULL);\\n  res->nanoseconds = 0;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n  struct timeval tv;\\n\\n  if (gettimeofday(&tv, NULL) != 0)\\n    return -6;\\n\\n  res->seconds = tv.tv_sec;\\n  res->nanoseconds = tv.tv_usec * 1000;\\n#else\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_cpu_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_CPU);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK\\n  return CLOCKS_PER_SEC;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n  return PSNIP_CLOCK_NSEC_PER_SEC / 100;\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_cpu_get_time (struct PsnipClockTimespec* res) {\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n  (void) res;\\n  return -2;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_CPU, res);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK\\n  clock_t t = clock();\\n  if (t == ((clock_t) -1))\\n    return -5;\\n  res->seconds = t / CLOCKS_PER_SEC;\\n  res->nanoseconds = (t % CLOCKS_PER_SEC) * (PSNIP_CLOCK_NSEC_PER_SEC / CLOCKS_PER_SEC);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n  FILETIME CreationTime, ExitTime, KernelTime, UserTime;\\n  LARGE_INTEGER date, adjust;\\n\\n  if (!GetProcessTimes(GetCurrentProcess(), &CreationTime, &ExitTime, &KernelTime, &UserTime))\\n    return -7;\\n\\n  /* http://www.frenk.com/2009/12/convert-filetime-to-unix-timestamp/ */\\n  date.HighPart = UserTime.dwHighDateTime;\\n  date.LowPart = UserTime.dwLowDateTime;\\n  adjust.QuadPart = 11644473600000 * 10000;\\n  date.QuadPart -= adjust.QuadPart;\\n\\n  res->seconds = date.QuadPart / 10000000;\\n  res->nanoseconds = (date.QuadPart % 10000000) * (PSNIP_CLOCK_NSEC_PER_SEC / 100);\\n#elif PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETRUSAGE\\n  struct rusage usage;\\n  if (getrusage(RUSAGE_SELF, &usage) != 0)\\n    return -8;\\n\\n  res->seconds = usage.ru_utime.tv_sec;\\n  res->nanoseconds = tv.tv_usec * 1000;\\n#else\\n  (void) res;\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_monotonic_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n  static mach_timebase_info_data_t tbi = { 0, };\\n  if (tbi.denom == 0)\\n    mach_timebase_info(&tbi);\\n  return (psnip_uint32_t) (tbi.numer / tbi.denom);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64\\n  return 1000;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n  LARGE_INTEGER Frequency;\\n  QueryPerformanceFrequency(&Frequency);\\n  return (psnip_uint32_t) ((Frequency.QuadPart > PSNIP_CLOCK_NSEC_PER_SEC) ? PSNIP_CLOCK_NSEC_PER_SEC : Frequency.QuadPart);\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_monotonic_get_time (struct PsnipClockTimespec* res) {\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n  (void) res;\\n  return -2;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC, res);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n  psnip_uint64_t nsec = mach_absolute_time();\\n  static mach_timebase_info_data_t tbi = { 0, };\\n  if (tbi.denom == 0)\\n    mach_timebase_info(&tbi);\\n  nsec *= ((psnip_uint64_t) tbi.numer) / ((psnip_uint64_t) tbi.denom);\\n  res->seconds = nsec / PSNIP_CLOCK_NSEC_PER_SEC;\\n  res->nanoseconds = nsec % PSNIP_CLOCK_NSEC_PER_SEC;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n  LARGE_INTEGER t, f;\\n  if (QueryPerformanceCounter(&t) == 0)\\n    return -12;\\n\\n  QueryPerformanceFrequency(&f);\\n  res->seconds = t.QuadPart / f.QuadPart;\\n  res->nanoseconds = t.QuadPart % f.QuadPart;\\n  if (f.QuadPart > PSNIP_CLOCK_NSEC_PER_SEC)\\n    res->nanoseconds /= f.QuadPart / PSNIP_CLOCK_NSEC_PER_SEC;\\n  else\\n    res->nanoseconds *= PSNIP_CLOCK_NSEC_PER_SEC / f.QuadPart;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64\\n  const ULONGLONG msec = GetTickCount64();\\n  res->seconds = msec / 1000;\\n  res->nanoseconds = sec % 1000;\\n#else\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\n/* Returns the number of ticks per second for the specified clock.\\n * For example, a clock with millisecond precision would return 1000,\\n * and a clock with 1 second (such as the time() function) would\\n * return 1.\\n *\\n * If the requested clock isn't available, it will return 0.\\n * Hopefully this will be rare, but if it happens to you please let us\\n * know so we can work on finding a way to support your system.\\n *\\n * Note that different clocks on the same system often have a\\n * different precisions.\\n */\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_get_precision (enum PsnipClockType clock_type) {\\n  switch (clock_type) {\\n    case PSNIP_CLOCK_TYPE_MONOTONIC:\\n      return psnip_clock_monotonic_get_precision ();\\n    case PSNIP_CLOCK_TYPE_CPU:\\n      return psnip_clock_cpu_get_precision ();\\n    case PSNIP_CLOCK_TYPE_WALL:\\n      return psnip_clock_wall_get_precision ();\\n  }\\n\\n  PSNIP_CLOCK_UNREACHABLE();\\n  return 0;\\n}\\n\\n/* Set the provided timespec to the requested time.  Returns 0 on\\n * success, or a negative value on failure. */\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_get_time (enum PsnipClockType clock_type, struct PsnipClockTimespec* res) {\\n  assert(res != NULL);\\n\\n  switch (clock_type) {\\n    case PSNIP_CLOCK_TYPE_MONOTONIC:\\n      return psnip_clock_monotonic_get_time (res);\\n    case PSNIP_CLOCK_TYPE_CPU:\\n      return psnip_clock_cpu_get_time (res);\\n    case PSNIP_CLOCK_TYPE_WALL:\\n      return psnip_clock_wall_get_time (res);\\n  }\\n\\n  return -1;\\n}\\n\\n#endif /* !defined(PSNIP_CLOCK_H) */\\n\\nstatic psnip_uint64_t\\nmunit_clock_get_elapsed(struct PsnipClockTimespec* start, struct PsnipClockTimespec* end) {\\n  psnip_uint64_t r = (end->seconds - start->seconds) * PSNIP_CLOCK_NSEC_PER_SEC;\\n  if (end->nanoseconds < start->nanoseconds) {\\n    r -= (start->nanoseconds - end->nanoseconds);\\n  } else {\\n    r += (end->nanoseconds - start->nanoseconds);\\n  }\\n  return r;\\n}\\n\\n#else\\n#  include <time.h>\\n#endif /* defined(MUNIT_ENABLE_TIMING) */\\n\\n/*** PRNG stuff ***/\\n\\n/* This is (unless I screwed up, which is entirely possible) the\\n * version of PCG with 32-bit state.  It was chosen because it has a\\n * small enough state that we should reliably be able to use CAS\\n * instead of requiring a lock for thread-safety.\\n *\\n * If I did screw up, I probably will not bother changing it unless\\n * there is a significant bias.  It's really not important this be\\n * particularly strong, as long as it is fairly random it's much more\\n * important that it be reproducible, so bug reports have a better\\n * chance of being reproducible. */\\n\\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__) && !defined(__EMSCRIPTEN__) && (!defined(__GNUC_MINOR__) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ > 8))\\n#  define HAVE_STDATOMIC\\n#elif defined(__clang__)\\n#  if __has_extension(c_atomic)\\n#    define HAVE_CLANG_ATOMICS\\n#  endif\\n#endif\\n\\n/* Workaround for http://llvm.org/bugs/show_bug.cgi?id=26911 */\\n#if defined(__clang__) && defined(_WIN32)\\n#  undef HAVE_STDATOMIC\\n#  if defined(__c2__)\\n#    undef HAVE_CLANG_ATOMICS\\n#  endif\\n#endif\\n\\n#if defined(_OPENMP)\\n#  define ATOMIC_UINT32_T uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#elif defined(HAVE_STDATOMIC)\\n#  include <stdatomic.h>\\n#  define ATOMIC_UINT32_T _Atomic uint32_t\\n#  define ATOMIC_UINT32_INIT(x) ATOMIC_VAR_INIT(x)\\n#elif defined(HAVE_CLANG_ATOMICS)\\n#  define ATOMIC_UINT32_T _Atomic uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#elif defined(_WIN32)\\n#  define ATOMIC_UINT32_T volatile LONG\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#else\\n#  define ATOMIC_UINT32_T volatile uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#endif\\n\\nstatic ATOMIC_UINT32_T munit_rand_state = ATOMIC_UINT32_INIT(42);\\n\\n#if defined(_OPENMP)\\nstatic inline void\\nmunit_atomic_store(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T value) {\\n#pragma omp critical (munit_atomics)\\n  *dest = value;\\n}\\n\\nstatic inline uint32_t\\nmunit_atomic_load(ATOMIC_UINT32_T* src) {\\n  int ret;\\n#pragma omp critical (munit_atomics)\\n  ret = *src;\\n  return ret;\\n}\\n\\nstatic inline uint32_t\\nmunit_atomic_cas(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T* expected, ATOMIC_UINT32_T desired) {\\n  munit_bool ret;\\n\\n#pragma omp critical (munit_atomics)\\n  {\\n    if (*dest == *expected) {\\n      *dest = desired;\\n      ret = 1;\\n    } else {\\n      ret = 0;\\n    }\\n  }\\n\\n  return ret;\\n}\\n#elif defined(HAVE_STDATOMIC)\\n#  define munit_atomic_store(dest, value)         atomic_store(dest, value)\\n#  define munit_atomic_load(src)                  atomic_load(src)\\n#  define munit_atomic_cas(dest, expected, value) atomic_compare_exchange_weak(dest, expected, value)\\n#elif defined(HAVE_CLANG_ATOMICS)\\n#  define munit_atomic_store(dest, value)         __c11_atomic_store(dest, value, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_load(src)                  __c11_atomic_load(src, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_cas(dest, expected, value) __c11_atomic_compare_exchange_weak(dest, expected, value, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\\n#elif defined(__GNUC__) && (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)\\n#  define munit_atomic_store(dest, value)         __atomic_store_n(dest, value, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_load(src)                  __atomic_load_n(src, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_cas(dest, expected, value) __atomic_compare_exchange_n(dest, expected, value, 1, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\\n#elif defined(__GNUC__) && (__GNUC__ >= 4)\\n#  define munit_atomic_store(dest,value)          do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\n#  define munit_atomic_cas(dest, expected, value) __sync_bool_compare_and_swap(dest, *expected, value)\\n#elif defined(_WIN32) /* Untested */\\n#  define munit_atomic_store(dest,value)          do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\n#  define munit_atomic_cas(dest, expected, value) InterlockedCompareExchange((dest), (value), *(expected))\\n#else\\n#  warning No atomic implementation, PRNG will not be thread-safe\\n#  define munit_atomic_store(dest, value)         do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\nstatic inline munit_bool\\nmunit_atomic_cas(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T* expected, ATOMIC_UINT32_T desired) {\\n  if (*dest == *expected) {\\n    *dest = desired;\\n    return 1;\\n  } else {\\n    return 0;\\n  }\\n}\\n#endif\\n\\n#define MUNIT_PRNG_MULTIPLIER (747796405U)\\n#define MUNIT_PRNG_INCREMENT  (1729U)\\n\\nstatic munit_uint32_t\\nmunit_rand_next_state(munit_uint32_t state) {\\n  return state * MUNIT_PRNG_MULTIPLIER + MUNIT_PRNG_INCREMENT;\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_from_state(munit_uint32_t state) {\\n  munit_uint32_t res = ((state >> ((state >> 28) + 4)) ^ state) * (277803737U);\\n  res ^= res >> 22;\\n  return res;\\n}\\n\\nvoid\\nmunit_rand_seed(munit_uint32_t seed) {\\n  munit_uint32_t state = munit_rand_next_state(seed + MUNIT_PRNG_INCREMENT);\\n  munit_atomic_store(&munit_rand_state, state);\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_generate_seed(void) {\\n  munit_uint32_t seed, state;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  struct PsnipClockTimespec wc = { 0, };\\n\\n  psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wc);\\n  seed = (munit_uint32_t) wc.nanoseconds;\\n#else\\n  seed = (munit_uint32_t) time(NULL);\\n#endif\\n\\n  state = munit_rand_next_state(seed + MUNIT_PRNG_INCREMENT);\\n  return munit_rand_from_state(state);\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_state_uint32(munit_uint32_t* state) {\\n  const munit_uint32_t old = *state;\\n  *state = munit_rand_next_state(old);\\n  return munit_rand_from_state(old);\\n}\\n\\nmunit_uint32_t\\nmunit_rand_uint32(void) {\\n  munit_uint32_t old, state;\\n\\n  do {\\n    old = munit_atomic_load(&munit_rand_state);\\n    state = munit_rand_next_state(old);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return munit_rand_from_state(old);\\n}\\n\\nstatic void\\nmunit_rand_state_memory(munit_uint32_t* state, size_t size, munit_uint8_t data[MUNIT_ARRAY_PARAM(size)]) {\\n  size_t members_remaining = size / sizeof(munit_uint32_t);\\n  size_t bytes_remaining = size % sizeof(munit_uint32_t);\\n  munit_uint8_t* b = data;\\n  munit_uint32_t rv;\\n  while (members_remaining-- > 0) {\\n    rv = munit_rand_state_uint32(state);\\n    memcpy(b, &rv, sizeof(munit_uint32_t));\\n    b += sizeof(munit_uint32_t);\\n  }\\n  if (bytes_remaining != 0) {\\n    rv = munit_rand_state_uint32(state);\\n    memcpy(b, &rv, bytes_remaining);\\n  }\\n}\\n\\nvoid\\nmunit_rand_memory(size_t size, munit_uint8_t data[MUNIT_ARRAY_PARAM(size)]) {\\n  munit_uint32_t old, state;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n    munit_rand_state_memory(&state, size, data);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_state_at_most(munit_uint32_t* state, munit_uint32_t salt, munit_uint32_t max) {\\n  /* We want (UINT32_MAX + 1) % max, which in unsigned arithmetic is the same\\n   * as (UINT32_MAX + 1 - max) % max = -max % max. We compute -max using not\\n   * to avoid compiler warnings.\\n   */\\n  const munit_uint32_t min = (~max + 1U) % max;\\n  munit_uint32_t x;\\n\\n  if (max == (~((munit_uint32_t) 0U)))\\n    return munit_rand_state_uint32(state) ^ salt;\\n\\n  max++;\\n\\n  do {\\n    x = munit_rand_state_uint32(state) ^ salt;\\n  } while (x < min);\\n\\n  return x % max;\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_at_most(munit_uint32_t salt, munit_uint32_t max) {\\n  munit_uint32_t old, state;\\n  munit_uint32_t retval;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n    retval = munit_rand_state_at_most(&state, salt, max);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return retval;\\n}\\n\\nint\\nmunit_rand_int_range(int min, int max) {\\n  munit_uint64_t range = (munit_uint64_t) max - (munit_uint64_t) min;\\n\\n  if (min > max)\\n    return munit_rand_int_range(max, min);\\n\\n  if (range > (~((munit_uint32_t) 0U)))\\n    range = (~((munit_uint32_t) 0U));\\n\\n  return min + munit_rand_at_most(0, (munit_uint32_t) range);\\n}\\n\\ndouble\\nmunit_rand_double(void) {\\n  munit_uint32_t old, state;\\n  double retval = 0.0;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n\\n    /* See http://mumble.net/~campbell/tmp/random_real.c for how to do\\n     * this right.  Patches welcome if you feel that this is too\\n     * biased. */\\n    retval = munit_rand_state_uint32(&state) / ((~((munit_uint32_t) 0U)) + 1.0);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return retval;\\n}\\n\\n/*** Test suite handling ***/\\n\\ntypedef struct {\\n  unsigned int successful;\\n  unsigned int skipped;\\n  unsigned int failed;\\n  unsigned int errored;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  munit_uint64_t cpu_clock;\\n  munit_uint64_t wall_clock;\\n#endif\\n} MunitReport;\\n\\ntypedef struct {\\n  const char* prefix;\\n  const MunitSuite* suite;\\n  const char** tests;\\n  munit_uint32_t seed;\\n  unsigned int iterations;\\n  MunitParameter* parameters;\\n  munit_bool single_parameter_mode;\\n  void* user_data;\\n  MunitReport report;\\n  munit_bool colorize;\\n  munit_bool fork;\\n  munit_bool show_stderr;\\n  munit_bool fatal_failures;\\n} MunitTestRunner;\\n\\nconst char*\\nmunit_parameters_get(const MunitParameter params[], const char* key) {\\n  const MunitParameter* param;\\n\\n  for (param = params ; param != NULL && param->name != NULL ; param++)\\n    if (strcmp(param->name, key) == 0)\\n      return param->value;\\n  return NULL;\\n}\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\nstatic void\\nmunit_print_time(FILE* fp, munit_uint64_t nanoseconds) {\\n  fprintf(fp, \\\"%\\\" MUNIT_TEST_TIME_FORMAT, ((double) nanoseconds) / ((double) PSNIP_CLOCK_NSEC_PER_SEC));\\n}\\n#endif\\n\\n/* Add a paramter to an array of parameters. */\\nstatic MunitResult\\nmunit_parameters_add(size_t* params_size, MunitParameter* params[MUNIT_ARRAY_PARAM(*params_size)], char* name, char* value) {\\n  *params = realloc(*params, sizeof(MunitParameter) * (*params_size + 2));\\n  if (*params == NULL)\\n    return MUNIT_ERROR;\\n\\n  (*params)[*params_size].name = name;\\n  (*params)[*params_size].value = value;\\n  (*params_size)++;\\n  (*params)[*params_size].name = NULL;\\n  (*params)[*params_size].value = NULL;\\n\\n  return MUNIT_OK;\\n}\\n\\n/* Concatenate two strings, but just return one of the components\\n * unaltered if the other is NULL or \\\"\\\". */\\nstatic char*\\nmunit_maybe_concat(size_t* len, char* prefix, char* suffix) {\\n  char* res;\\n  size_t res_l;\\n  const size_t prefix_l = prefix != NULL ? strlen(prefix) : 0;\\n  const size_t suffix_l = suffix != NULL ? strlen(suffix) : 0;\\n  if (prefix_l == 0 && suffix_l == 0) {\\n    res = NULL;\\n    res_l = 0;\\n  } else if (prefix_l == 0 && suffix_l != 0) {\\n    res = suffix;\\n    res_l = suffix_l;\\n  } else if (prefix_l != 0 && suffix_l == 0) {\\n    res = prefix;\\n    res_l = prefix_l;\\n  } else {\\n    res_l = prefix_l + suffix_l;\\n    res = malloc(res_l + 1);\\n    memcpy(res, prefix, prefix_l);\\n    memcpy(res + prefix_l, suffix, suffix_l);\\n    res[res_l] = 0;\\n  }\\n\\n  if (len != NULL)\\n    *len = res_l;\\n\\n  return res;\\n}\\n\\n/* Possbily free a string returned by munit_maybe_concat. */\\nstatic void\\nmunit_maybe_free_concat(char* s, const char* prefix, const char* suffix) {\\n  if (prefix != s && suffix != s)\\n    free(s);\\n}\\n\\n/* Cheap string hash function, just used to salt the PRNG. */\\nstatic munit_uint32_t\\nmunit_str_hash(const char* name) {\\n  const char *p;\\n  munit_uint32_t h = 5381U;\\n\\n  for (p = name; *p != '\\\\0'; p++)\\n    h = (h << 5) + h + *p;\\n\\n  return h;\\n}\\n\\nstatic void\\nmunit_splice(int from, int to) {\\n  munit_uint8_t buf[1024];\\n#if !defined(_WIN32)\\n  ssize_t len;\\n  ssize_t bytes_written;\\n  ssize_t write_res;\\n#else\\n  int len;\\n  int bytes_written;\\n  int write_res;\\n#endif\\n  do {\\n    len = read(from, buf, sizeof(buf));\\n    if (len > 0) {\\n      bytes_written = 0;\\n      do {\\n        write_res = write(to, buf + bytes_written, len - bytes_written);\\n        if (write_res < 0)\\n          break;\\n        bytes_written += write_res;\\n      } while (bytes_written < len);\\n    }\\n    else\\n      break;\\n  } while (1);\\n}\\n\\n/* This is the part that should be handled in the child process */\\nstatic MunitResult\\nmunit_test_runner_exec(MunitTestRunner* runner, const MunitTest* test, const MunitParameter params[], MunitReport* report) {\\n  unsigned int iterations = runner->iterations;\\n  MunitResult result = MUNIT_FAIL;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  struct PsnipClockTimespec wall_clock_begin = { 0, }, wall_clock_end = { 0, };\\n  struct PsnipClockTimespec cpu_clock_begin = { 0, }, cpu_clock_end = { 0, };\\n#endif\\n  unsigned int i = 0;\\n\\n  if ((test->options & MUNIT_TEST_OPTION_SINGLE_ITERATION) == MUNIT_TEST_OPTION_SINGLE_ITERATION)\\n    iterations = 1;\\n  else if (iterations == 0)\\n    iterations = runner->suite->iterations;\\n\\n  munit_rand_seed(runner->seed);\\n\\n  do {\\n    void* data = (test->setup == NULL) ? runner->user_data : test->setup(params, runner->user_data);\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wall_clock_begin);\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_CPU, &cpu_clock_begin);\\n#endif\\n\\n    result = test->test(params, data);\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wall_clock_end);\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_CPU, &cpu_clock_end);\\n#endif\\n\\n    if (test->tear_down != NULL)\\n      test->tear_down(data);\\n\\n    if (MUNIT_LIKELY(result == MUNIT_OK)) {\\n      report->successful++;\\n#if defined(MUNIT_ENABLE_TIMING)\\n      report->wall_clock += munit_clock_get_elapsed(&wall_clock_begin, &wall_clock_end);\\n      report->cpu_clock += munit_clock_get_elapsed(&cpu_clock_begin, &cpu_clock_end);\\n#endif\\n    } else {\\n      switch ((int) result) {\\n        case MUNIT_SKIP:\\n          report->skipped++;\\n          break;\\n        case MUNIT_FAIL:\\n          report->failed++;\\n          break;\\n        case MUNIT_ERROR:\\n          report->errored++;\\n          break;\\n        default:\\n          break;\\n      }\\n      break;\\n    }\\n  } while (++i < iterations);\\n\\n  return result;\\n}\\n\\n#if defined(MUNIT_EMOTICON)\\n#  define MUNIT_RESULT_STRING_OK    \\\":)\\\"\\n#  define MUNIT_RESULT_STRING_SKIP  \\\":|\\\"\\n#  define MUNIT_RESULT_STRING_FAIL  \\\":(\\\"\\n#  define MUNIT_RESULT_STRING_ERROR \\\":o\\\"\\n#  define MUNIT_RESULT_STRING_TODO  \\\":/\\\"\\n#else\\n#  define MUNIT_RESULT_STRING_OK    \\\"OK   \\\"\\n#  define MUNIT_RESULT_STRING_SKIP  \\\"SKIP \\\"\\n#  define MUNIT_RESULT_STRING_FAIL  \\\"FAIL \\\"\\n#  define MUNIT_RESULT_STRING_ERROR \\\"ERROR\\\"\\n#  define MUNIT_RESULT_STRING_TODO  \\\"TODO \\\"\\n#endif\\n\\nstatic void\\nmunit_test_runner_print_color(const MunitTestRunner* runner, const char* string, char color) {\\n  if (runner->colorize)\\n    fprintf(MUNIT_OUTPUT_FILE, \\\"\\\\x1b[3%cm%s\\\\x1b[39m\\\", color, string);\\n  else\\n    fputs(string, MUNIT_OUTPUT_FILE);\\n}\\n\\n#if !defined(MUNIT_NO_BUFFER)\\nstatic int\\nmunit_replace_stderr(FILE* stderr_buf) {\\n  if (stderr_buf != NULL) {\\n    const int orig_stderr = dup(STDERR_FILENO);\\n\\n    int errfd = fileno(stderr_buf);\\n    if (MUNIT_UNLIKELY(errfd == -1)) {\\n      exit(EXIT_FAILURE);\\n    }\\n\\n    dup2(errfd, STDERR_FILENO);\\n\\n    return orig_stderr;\\n  }\\n\\n  return -1;\\n}\\n\\nstatic void\\nmunit_restore_stderr(int orig_stderr) {\\n  if (orig_stderr != -1) {\\n    dup2(orig_stderr, STDERR_FILENO);\\n    close(orig_stderr);\\n  }\\n}\\n#endif /* !defined(MUNIT_NO_BUFFER) */\\n\\n/* Run a test with the specified parameters. */\\nstatic void\\nmunit_test_runner_run_test_with_params(MunitTestRunner* runner, const MunitTest* test, const MunitParameter params[]) {\\n  MunitResult result = MUNIT_OK;\\n  MunitReport report = {\\n    0, 0, 0, 0,\\n#if defined(MUNIT_ENABLE_TIMING)\\n    0, 0\\n#endif\\n  };\\n  unsigned int output_l;\\n  munit_bool first;\\n  const MunitParameter* param;\\n  FILE* stderr_buf;\\n#if !defined(MUNIT_NO_FORK)\\n  int pipefd[2];\\n  pid_t fork_pid;\\n  int orig_stderr;\\n  ssize_t bytes_written = 0;\\n  ssize_t write_res;\\n  ssize_t bytes_read = 0;\\n  ssize_t read_res;\\n  int status = 0;\\n  pid_t changed_pid;\\n#endif\\n\\n  if (params != NULL) {\\n    output_l = 2;\\n    fputs(\\\"  \\\", MUNIT_OUTPUT_FILE);\\n    first = 1;\\n    for (param = params ; param != NULL && param->name != NULL ; param++) {\\n      if (!first) {\\n        fputs(\\\", \\\", MUNIT_OUTPUT_FILE);\\n        output_l += 2;\\n      } else {\\n        first = 0;\\n      }\\n\\n      output_l += fprintf(MUNIT_OUTPUT_FILE, \\\"%s=%s\\\", param->name, param->value);\\n    }\\n    while (output_l++ < MUNIT_TEST_NAME_LEN) {\\n      fputc(' ', MUNIT_OUTPUT_FILE);\\n    }\\n  }\\n\\n  fflush(MUNIT_OUTPUT_FILE);\\n\\n  stderr_buf = NULL;\\n#if !defined(_WIN32) || defined(__MINGW32__)\\n  stderr_buf = tmpfile();\\n#else\\n  tmpfile_s(&stderr_buf);\\n#endif\\n  if (stderr_buf == NULL) {\\n    munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to create buffer for stderr\\\");\\n    result = MUNIT_ERROR;\\n    goto print_result;\\n  }\\n\\n#if !defined(MUNIT_NO_FORK)\\n  if (runner->fork) {\\n    pipefd[0] = -1;\\n    pipefd[1] = -1;\\n    if (pipe(pipefd) != 0) {\\n      munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to create pipe\\\");\\n      result = MUNIT_ERROR;\\n      goto print_result;\\n    }\\n\\n    fork_pid = fork();\\n    if (fork_pid == 0) {\\n      close(pipefd[0]);\\n\\n      orig_stderr = munit_replace_stderr(stderr_buf);\\n      munit_test_runner_exec(runner, test, params, &report);\\n\\n      /* Note that we don't restore stderr.  This is so we can buffer\\n       * things written to stderr later on (such as by\\n       * asan/tsan/ubsan, valgrind, etc.) */\\n      close(orig_stderr);\\n\\n      do {\\n        write_res = write(pipefd[1], ((munit_uint8_t*) (&report)) + bytes_written, sizeof(report) - bytes_written);\\n        if (write_res < 0) {\\n          if (stderr_buf != NULL) {\\n            munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to write to pipe\\\");\\n          }\\n          exit(EXIT_FAILURE);\\n        }\\n        bytes_written += write_res;\\n      } while ((size_t) bytes_written < sizeof(report));\\n\\n      if (stderr_buf != NULL)\\n        fclose(stderr_buf);\\n      close(pipefd[1]);\\n\\n      exit(EXIT_SUCCESS);\\n    } else if (fork_pid == -1) {\\n      close(pipefd[0]);\\n      close(pipefd[1]);\\n      if (stderr_buf != NULL) {\\n        munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to fork\\\");\\n      }\\n      report.errored++;\\n      result = MUNIT_ERROR;\\n    } else {\\n      close(pipefd[1]);\\n      do {\\n        read_res = read(pipefd[0], ((munit_uint8_t*) (&report)) + bytes_read, sizeof(report) - bytes_read);\\n        if (read_res < 1)\\n          break;\\n        bytes_read += read_res;\\n      } while (bytes_read < (ssize_t) sizeof(report));\\n\\n      changed_pid = waitpid(fork_pid, &status, 0);\\n\\n      if (MUNIT_LIKELY(changed_pid == fork_pid) && MUNIT_LIKELY(WIFEXITED(status))) {\\n        if (bytes_read != sizeof(report)) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child exited unexpectedly with status %d\\\", WEXITSTATUS(status));\\n          report.errored++;\\n        } else if (WEXITSTATUS(status) != EXIT_SUCCESS) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child exited with status %d\\\", WEXITSTATUS(status));\\n          report.errored++;\\n        }\\n      } else {\\n        if (WIFSIGNALED(status)) {\\n#if defined(_XOPEN_VERSION) && (_XOPEN_VERSION >= 700)\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child killed by signal %d (%s)\\\", WTERMSIG(status), strsignal(WTERMSIG(status)));\\n#else\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child killed by signal %d\\\", WTERMSIG(status));\\n#endif\\n        } else if (WIFSTOPPED(status)) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child stopped by signal %d\\\", WSTOPSIG(status));\\n        }\\n        report.errored++;\\n      }\\n\\n      close(pipefd[0]);\\n      waitpid(fork_pid, NULL, 0);\\n    }\\n  } else\\n#endif\\n  {\\n#if !defined(MUNIT_NO_BUFFER)\\n    const volatile int orig_stderr = munit_replace_stderr(stderr_buf);\\n#endif\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\n    if (MUNIT_UNLIKELY(setjmp(munit_error_jmp_buf) != 0)) {\\n      result = MUNIT_FAIL;\\n      report.failed++;\\n    } else {\\n      munit_error_jmp_buf_valid = 1;\\n      result = munit_test_runner_exec(runner, test, params, &report);\\n    }\\n#else\\n    result = munit_test_runner_exec(runner, test, params, &report);\\n#endif\\n\\n#if !defined(MUNIT_NO_BUFFER)\\n    munit_restore_stderr(orig_stderr);\\n#endif\\n\\n    /* Here just so that the label is used on Windows and we don't get\\n     * a warning */\\n    goto print_result;\\n  }\\n\\n print_result:\\n\\n  fputs(\\\"[ \\\", MUNIT_OUTPUT_FILE);\\n  if ((test->options & MUNIT_TEST_OPTION_TODO) == MUNIT_TEST_OPTION_TODO) {\\n    if (report.failed != 0 || report.errored != 0 || report.skipped != 0) {\\n      munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_TODO, '3');\\n      result = MUNIT_OK;\\n    } else {\\n      munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_ERROR, '1');\\n      if (MUNIT_LIKELY(stderr_buf != NULL))\\n        munit_log_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"Test marked TODO, but was successful.\\\");\\n      runner->report.failed++;\\n      result = MUNIT_ERROR;\\n    }\\n  } else if (report.failed > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_FAIL, '1');\\n    runner->report.failed++;\\n    result = MUNIT_FAIL;\\n  } else if (report.errored > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_ERROR, '1');\\n    runner->report.errored++;\\n    result = MUNIT_ERROR;\\n  } else if (report.skipped > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_SKIP, '3');\\n    runner->report.skipped++;\\n    result = MUNIT_SKIP;\\n  } else if (report.successful > 1) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_OK, '2');\\n#if defined(MUNIT_ENABLE_TIMING)\\n    fputs(\\\" ] [ \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock / report.successful);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock / report.successful);\\n    fprintf(MUNIT_OUTPUT_FILE, \\\" CPU ]\\\\n  %-\\\" MUNIT_XSTRINGIFY(MUNIT_TEST_NAME_LEN) \\\"s Total: [ \\\", \\\"\\\");\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock);\\n    fputs(\\\" CPU\\\", MUNIT_OUTPUT_FILE);\\n#endif\\n    runner->report.successful++;\\n    result = MUNIT_OK;\\n  } else if (report.successful > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_OK, '2');\\n#if defined(MUNIT_ENABLE_TIMING)\\n    fputs(\\\" ] [ \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock);\\n    fputs(\\\" CPU\\\", MUNIT_OUTPUT_FILE);\\n#endif\\n    runner->report.successful++;\\n    result = MUNIT_OK;\\n  }\\n  fputs(\\\" ]\\\\n\\\", MUNIT_OUTPUT_FILE);\\n\\n  if (stderr_buf != NULL) {\\n    if (result == MUNIT_FAIL || result == MUNIT_ERROR || runner->show_stderr) {\\n      fflush(MUNIT_OUTPUT_FILE);\\n\\n      rewind(stderr_buf);\\n      munit_splice(fileno(stderr_buf), STDERR_FILENO);\\n\\n      fflush(stderr);\\n    }\\n\\n    fclose(stderr_buf);\\n  }\\n}\\n\\nstatic void\\nmunit_test_runner_run_test_wild(MunitTestRunner* runner,\\n                                const MunitTest* test,\\n                                const char* test_name,\\n                                MunitParameter* params,\\n                                MunitParameter* p) {\\n  const MunitParameterEnum* pe;\\n  char** values;\\n  MunitParameter* next;\\n\\n  for (pe = test->parameters ; pe != NULL && pe->name != NULL ; pe++) {\\n    if (p->name == pe->name)\\n      break;\\n  }\\n\\n  if (pe == NULL)\\n    return;\\n\\n  for (values = pe->values ; *values != NULL ; values++) {\\n    next = p + 1;\\n    p->value = *values;\\n    if (next->name == NULL) {\\n      munit_test_runner_run_test_with_params(runner, test, params);\\n    } else {\\n      munit_test_runner_run_test_wild(runner, test, test_name, params, next);\\n    }\\n    if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n      break;\\n  }\\n}\\n\\n/* Run a single test, with every combination of parameters\\n * requested. */\\nstatic void\\nmunit_test_runner_run_test(MunitTestRunner* runner,\\n                           const MunitTest* test,\\n                           const char* prefix) {\\n  char* test_name = munit_maybe_concat(NULL, (char*) prefix, (char*) test->name);\\n  /* The array of parameters to pass to\\n   * munit_test_runner_run_test_with_params */\\n  MunitParameter* params = NULL;\\n  size_t params_l = 0;\\n  /* Wildcard parameters are parameters which have possible values\\n   * specified in the test, but no specific value was passed to the\\n   * CLI.  That means we want to run the test once for every\\n   * possible combination of parameter values or, if --single was\\n   * passed to the CLI, a single time with a random set of\\n   * parameters. */\\n  MunitParameter* wild_params = NULL;\\n  size_t wild_params_l = 0;\\n  const MunitParameterEnum* pe;\\n  const MunitParameter* cli_p;\\n  munit_bool filled;\\n  unsigned int possible;\\n  char** vals;\\n  size_t first_wild;\\n  const MunitParameter* wp;\\n  int pidx;\\n\\n  munit_rand_seed(runner->seed);\\n\\n  fprintf(MUNIT_OUTPUT_FILE, \\\"%-\\\" MUNIT_XSTRINGIFY(MUNIT_TEST_NAME_LEN) \\\"s\\\", test_name);\\n\\n  if (test->parameters == NULL) {\\n    /* No parameters.  Simple, nice. */\\n    munit_test_runner_run_test_with_params(runner, test, NULL);\\n  } else {\\n    fputc('\\\\n', MUNIT_OUTPUT_FILE);\\n\\n    for (pe = test->parameters ; pe != NULL && pe->name != NULL ; pe++) {\\n      /* Did we received a value for this parameter from the CLI? */\\n      filled = 0;\\n      for (cli_p = runner->parameters ; cli_p != NULL && cli_p->name != NULL ; cli_p++) {\\n        if (strcmp(cli_p->name, pe->name) == 0) {\\n          if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, cli_p->value) != MUNIT_OK))\\n            goto cleanup;\\n          filled = 1;\\n          break;\\n        }\\n      }\\n      if (filled)\\n        continue;\\n\\n      /* Nothing from CLI, is the enum NULL/empty?  We're not a\\n       * fuzzer\\u2026 */\\n      if (pe->values == NULL || pe->values[0] == NULL)\\n        continue;\\n\\n      /* If --single was passed to the CLI, choose a value from the\\n       * list of possibilities randomly. */\\n      if (runner->single_parameter_mode) {\\n        possible = 0;\\n        for (vals = pe->values ; *vals != NULL ; vals++)\\n          possible++;\\n        /* We want the tests to be reproducible, even if you're only\\n         * running a single test, but we don't want every test with\\n         * the same number of parameters to choose the same parameter\\n         * number, so use the test name as a primitive salt. */\\n        pidx = munit_rand_at_most(munit_str_hash(test_name), possible - 1);\\n        if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, pe->values[pidx]) != MUNIT_OK))\\n          goto cleanup;\\n      } else {\\n        /* We want to try every permutation.  Put in a placeholder\\n         * entry, we'll iterate through them later. */\\n        if (MUNIT_UNLIKELY(munit_parameters_add(&wild_params_l, &wild_params, pe->name, NULL) != MUNIT_OK))\\n          goto cleanup;\\n      }\\n    }\\n\\n    if (wild_params_l != 0) {\\n      first_wild = params_l;\\n      for (wp = wild_params ; wp != NULL && wp->name != NULL ; wp++) {\\n        for (pe = test->parameters ; pe != NULL && pe->name != NULL && pe->values != NULL ; pe++) {\\n          if (strcmp(wp->name, pe->name) == 0) {\\n            if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, pe->values[0]) != MUNIT_OK))\\n              goto cleanup;\\n          }\\n        }\\n      }\\n\\n      munit_test_runner_run_test_wild(runner, test, test_name, params, params + first_wild);\\n    } else {\\n      munit_test_runner_run_test_with_params(runner, test, params);\\n    }\\n\\n  cleanup:\\n    free(params);\\n    free(wild_params);\\n  }\\n\\n  munit_maybe_free_concat(test_name, prefix, test->name);\\n}\\n\\n/* Recurse through the suite and run all the tests.  If a list of\\n * tests to run was provied on the command line, run only those\\n * tests.  */\\nstatic void\\nmunit_test_runner_run_suite(MunitTestRunner* runner,\\n                            const MunitSuite* suite,\\n                            const char* prefix) {\\n  size_t pre_l;\\n  char* pre = munit_maybe_concat(&pre_l, (char*) prefix, (char*) suite->prefix);\\n  const MunitTest* test;\\n  const char** test_name;\\n  const MunitSuite* child_suite;\\n\\n  /* Run the tests. */\\n  for (test = suite->tests ; test != NULL && test->test != NULL ; test++) {\\n    if (runner->tests != NULL) { /* Specific tests were requested on the CLI */\\n      for (test_name = runner->tests ; test_name != NULL && *test_name != NULL ; test_name++) {\\n        if ((pre_l == 0 || strncmp(pre, *test_name, pre_l) == 0) &&\\n            strncmp(test->name, *test_name + pre_l, strlen(*test_name + pre_l)) == 0) {\\n          munit_test_runner_run_test(runner, test, pre);\\n          if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n            goto cleanup;\\n        }\\n      }\\n    } else { /* Run all tests */\\n      munit_test_runner_run_test(runner, test, pre);\\n    }\\n  }\\n\\n  if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n    goto cleanup;\\n\\n  /* Run any child suites. */\\n  for (child_suite = suite->suites ; child_suite != NULL && child_suite->prefix != NULL ; child_suite++) {\\n    munit_test_runner_run_suite(runner, child_suite, pre);\\n  }\\n\\n cleanup:\\n\\n  munit_maybe_free_concat(pre, prefix, suite->prefix);\\n}\\n\\nstatic void\\nmunit_test_runner_run(MunitTestRunner* runner) {\\n  munit_test_runner_run_suite(runner, runner->suite, NULL);\\n}\\n\\nstatic void\\nmunit_print_help(int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)], void* user_data, const MunitArgument arguments[]) {\\n  const MunitArgument* arg;\\n  (void) argc;\\n\\n  printf(\\\"USAGE: %s [OPTIONS...] [TEST...]\\\\n\\\\n\\\", argv[0]);\\n  puts(\\\" --seed SEED\\\\n\\\"\\n       \\\"           Value used to seed the PRNG.  Must be a 32-bit integer in decimal\\\\n\\\"\\n       \\\"           notation with no separators (commas, decimals, spaces, etc.), or\\\\n\\\"\\n       \\\"           hexidecimal prefixed by \\\\\\\"0x\\\\\\\".\\\\n\\\"\\n       \\\" --iterations N\\\\n\\\"\\n       \\\"           Run each test N times.  0 means the default number.\\\\n\\\"\\n       \\\" --param name value\\\\n\\\"\\n       \\\"           A parameter key/value pair which will be passed to any test with\\\\n\\\"\\n       \\\"           takes a parameter of that name.  If not provided, the test will be\\\\n\\\"\\n       \\\"           run once for each possible parameter value.\\\\n\\\"\\n       \\\" --list    Write a list of all available tests.\\\\n\\\"\\n       \\\" --list-params\\\\n\\\"\\n       \\\"           Write a list of all available tests and their possible parameters.\\\\n\\\"\\n       \\\" --single  Run each parameterized test in a single configuration instead of\\\\n\\\"\\n       \\\"           every possible combination\\\\n\\\"\\n       \\\" --log-visible debug|info|warning|error\\\\n\\\"\\n       \\\" --log-fatal debug|info|warning|error\\\\n\\\"\\n       \\\"           Set the level at which messages of different severities are visible,\\\\n\\\"\\n       \\\"           or cause the test to terminate.\\\\n\\\"\\n#if !defined(MUNIT_NO_FORK)\\n       \\\" --no-fork Do not execute tests in a child process.  If this option is supplied\\\\n\\\"\\n       \\\"           and a test crashes (including by failing an assertion), no further\\\\n\\\"\\n       \\\"           tests will be performed.\\\\n\\\"\\n#endif\\n       \\\" --fatal-failures\\\\n\\\"\\n       \\\"           Stop executing tests as soon as a failure is found.\\\\n\\\"\\n       \\\" --show-stderr\\\\n\\\"\\n       \\\"           Show data written to stderr by the tests, even if the test succeeds.\\\\n\\\"\\n       \\\" --color auto|always|never\\\\n\\\"\\n       \\\"           Colorize (or don't) the output.\\\\n\\\"\\n     /* 12345678901234567890123456789012345678901234567890123456789012345678901234567890 */\\n       \\\" --help    Print this help message and exit.\\\\n\\\");\\n#if defined(MUNIT_NL_LANGINFO)\\n  setlocale(LC_ALL, \\\"\\\");\\n  fputs((strcasecmp(\\\"UTF-8\\\", nl_langinfo(CODESET)) == 0) ? \\\"\\u00b5nit\\\" : \\\"munit\\\", stdout);\\n#else\\n  puts(\\\"munit\\\");\\n#endif\\n  printf(\\\" %d.%d.%d\\\\n\\\"\\n         \\\"Full documentation at: https://nemequ.github.io/munit/\\\\n\\\",\\n         (MUNIT_CURRENT_VERSION >> 16) & 0xff,\\n         (MUNIT_CURRENT_VERSION >> 8) & 0xff,\\n         (MUNIT_CURRENT_VERSION >> 0) & 0xff);\\n  for (arg = arguments ; arg != NULL && arg->name != NULL ; arg++)\\n    arg->write_help(arg, user_data);\\n}\\n\\nstatic const MunitArgument*\\nmunit_arguments_find(const MunitArgument arguments[], const char* name) {\\n  const MunitArgument* arg;\\n\\n  for (arg = arguments ; arg != NULL && arg->name != NULL ; arg++)\\n    if (strcmp(arg->name, name) == 0)\\n      return arg;\\n\\n  return NULL;\\n}\\n\\nstatic void\\nmunit_suite_list_tests(const MunitSuite* suite, munit_bool show_params, const char* prefix) {\\n  size_t pre_l;\\n  char* pre = munit_maybe_concat(&pre_l, (char*) prefix, (char*) suite->prefix);\\n  const MunitTest* test;\\n  const MunitParameterEnum* params;\\n  munit_bool first;\\n  char** val;\\n  const MunitSuite* child_suite;\\n\\n  for (test = suite->tests ;\\n       test != NULL && test->name != NULL ;\\n       test++) {\\n    if (pre != NULL)\\n      fputs(pre, stdout);\\n    puts(test->name);\\n\\n    if (show_params) {\\n      for (params = test->parameters ;\\n           params != NULL && params->name != NULL ;\\n           params++) {\\n        fprintf(stdout, \\\" - %s: \\\", params->name);\\n        if (params->values == NULL) {\\n          puts(\\\"Any\\\");\\n        } else {\\n          first = 1;\\n          for (val = params->values ;\\n               *val != NULL ;\\n               val++ ) {\\n            if(!first) {\\n              fputs(\\\", \\\", stdout);\\n            } else {\\n              first = 0;\\n            }\\n            fputs(*val, stdout);\\n          }\\n          putc('\\\\n', stdout);\\n        }\\n      }\\n    }\\n  }\\n\\n  for (child_suite = suite->suites ; child_suite != NULL && child_suite->prefix != NULL ; child_suite++) {\\n    munit_suite_list_tests(child_suite, show_params, pre);\\n  }\\n\\n  munit_maybe_free_concat(pre, prefix, suite->prefix);\\n}\\n\\nstatic munit_bool\\nmunit_stream_supports_ansi(FILE *stream) {\\n#if !defined(_WIN32)\\n  return isatty(fileno(stream));\\n#else\\n\\n#if !defined(__MINGW32__)\\n  size_t ansicon_size = 0;\\n#endif\\n\\n  if (isatty(fileno(stream))) {\\n#if !defined(__MINGW32__)\\n    getenv_s(&ansicon_size, NULL, 0, \\\"ANSICON\\\");\\n    return ansicon_size != 0;\\n#else\\n    return getenv(\\\"ANSICON\\\") != NULL;\\n#endif\\n  }\\n  return 0;\\n#endif\\n}\\n\\nint\\nmunit_suite_main_custom(const MunitSuite* suite, void* user_data,\\n                        int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)],\\n                        const MunitArgument arguments[]) {\\n  int result = EXIT_FAILURE;\\n  MunitTestRunner runner;\\n  size_t parameters_size = 0;\\n  size_t tests_size = 0;\\n  int arg;\\n\\n  char* envptr;\\n  unsigned long ts;\\n  char* endptr;\\n  unsigned long long iterations;\\n  MunitLogLevel level;\\n  const MunitArgument* argument;\\n  const char** runner_tests;\\n  unsigned int tests_run;\\n  unsigned int tests_total;\\n\\n  runner.prefix = NULL;\\n  runner.suite = NULL;\\n  runner.tests = NULL;\\n  runner.seed = 0;\\n  runner.iterations = 0;\\n  runner.parameters = NULL;\\n  runner.single_parameter_mode = 0;\\n  runner.user_data = NULL;\\n\\n  runner.report.successful = 0;\\n  runner.report.skipped = 0;\\n  runner.report.failed = 0;\\n  runner.report.errored = 0;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  runner.report.cpu_clock = 0;\\n  runner.report.wall_clock = 0;\\n#endif\\n\\n  runner.colorize = 0;\\n#if !defined(_WIN32)\\n  runner.fork = 1;\\n#else\\n  runner.fork = 0;\\n#endif\\n  runner.show_stderr = 0;\\n  runner.fatal_failures = 0;\\n  runner.suite = suite;\\n  runner.user_data = user_data;\\n  runner.seed = munit_rand_generate_seed();\\n  runner.colorize = munit_stream_supports_ansi(MUNIT_OUTPUT_FILE);\\n\\n  for (arg = 1 ; arg < argc ; arg++) {\\n    if (strncmp(\\\"--\\\", argv[arg], 2) == 0) {\\n      if (strcmp(\\\"seed\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        envptr = argv[arg + 1];\\n        ts = strtoul(argv[arg + 1], &envptr, 0);\\n        if (*envptr != '\\\\0' || ts > (~((munit_uint32_t) 0U))) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n        runner.seed = (munit_uint32_t) ts;\\n\\n        arg++;\\n      } else if (strcmp(\\\"iterations\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        endptr = argv[arg + 1];\\n        iterations = strtoul(argv[arg + 1], &endptr, 0);\\n        if (*endptr != '\\\\0' || iterations > UINT_MAX) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        runner.iterations = (unsigned int) iterations;\\n\\n        arg++;\\n      } else if (strcmp(\\\"param\\\", argv[arg] + 2) == 0) {\\n        if (arg + 2 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires two arguments\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        runner.parameters = realloc(runner.parameters, sizeof(MunitParameter) * (parameters_size + 2));\\n        if (runner.parameters == NULL) {\\n          munit_log_internal(MUNIT_LOG_ERROR, stderr, \\\"failed to allocate memory\\\");\\n          goto cleanup;\\n        }\\n        runner.parameters[parameters_size].name = (char*) argv[arg + 1];\\n        runner.parameters[parameters_size].value = (char*) argv[arg + 2];\\n        parameters_size++;\\n        runner.parameters[parameters_size].name = NULL;\\n        runner.parameters[parameters_size].value = NULL;\\n        arg += 2;\\n      } else if (strcmp(\\\"color\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(argv[arg + 1], \\\"always\\\") == 0)\\n          runner.colorize = 1;\\n        else if (strcmp(argv[arg + 1], \\\"never\\\") == 0)\\n          runner.colorize = 0;\\n        else if (strcmp(argv[arg + 1], \\\"auto\\\") == 0)\\n          runner.colorize = munit_stream_supports_ansi(MUNIT_OUTPUT_FILE);\\n        else {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        arg++;\\n      } else if (strcmp(\\\"help\\\", argv[arg] + 2) == 0) {\\n        munit_print_help(argc, argv, user_data, arguments);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else if (strcmp(\\\"single\\\", argv[arg] + 2) == 0) {\\n        runner.single_parameter_mode = 1;\\n      } else if (strcmp(\\\"show-stderr\\\", argv[arg] + 2) == 0) {\\n        runner.show_stderr = 1;\\n#if !defined(_WIN32)\\n      } else if (strcmp(\\\"no-fork\\\", argv[arg] + 2) == 0) {\\n        runner.fork = 0;\\n#endif\\n      } else if (strcmp(\\\"fatal-failures\\\", argv[arg] + 2) == 0) {\\n        runner.fatal_failures = 1;\\n      } else if (strcmp(\\\"log-visible\\\", argv[arg] + 2) == 0 ||\\n                 strcmp(\\\"log-fatal\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(argv[arg + 1], \\\"debug\\\") == 0)\\n          level = MUNIT_LOG_DEBUG;\\n        else if (strcmp(argv[arg + 1], \\\"info\\\") == 0)\\n          level = MUNIT_LOG_INFO;\\n        else if (strcmp(argv[arg + 1], \\\"warning\\\") == 0)\\n          level = MUNIT_LOG_WARNING;\\n        else if (strcmp(argv[arg + 1], \\\"error\\\") == 0)\\n          level = MUNIT_LOG_ERROR;\\n        else {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(\\\"log-visible\\\", argv[arg] + 2) == 0)\\n          munit_log_level_visible = level;\\n        else\\n          munit_log_level_fatal = level;\\n\\n        arg++;\\n      } else if (strcmp(\\\"list\\\", argv[arg] + 2) == 0) {\\n        munit_suite_list_tests(suite, 0, NULL);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else if (strcmp(\\\"list-params\\\", argv[arg] + 2) == 0) {\\n        munit_suite_list_tests(suite, 1, NULL);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else {\\n        argument = munit_arguments_find(arguments, argv[arg] + 2);\\n        if (argument == NULL) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"unknown argument ('%s')\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (!argument->parse_argument(suite, user_data, &arg, argc, argv))\\n          goto cleanup;\\n      }\\n    } else {\\n      runner_tests = realloc((void*) runner.tests, sizeof(char*) * (tests_size + 2));\\n      if (runner_tests == NULL) {\\n        munit_log_internal(MUNIT_LOG_ERROR, stderr, \\\"failed to allocate memory\\\");\\n        goto cleanup;\\n      }\\n      runner.tests = runner_tests;\\n      runner.tests[tests_size++] = argv[arg];\\n      runner.tests[tests_size] = NULL;\\n    }\\n  }\\n\\n  fflush(stderr);\\n  fprintf(MUNIT_OUTPUT_FILE, \\\"Running test suite with seed 0x%08\\\" PRIx32 \\\"...\\\\n\\\", runner.seed);\\n\\n  munit_test_runner_run(&runner);\\n\\n  tests_run = runner.report.successful + runner.report.failed + runner.report.errored;\\n  tests_total = tests_run + runner.report.skipped;\\n  if (tests_run == 0) {\\n    fprintf(stderr, \\\"No tests run, %d (100%%) skipped.\\\\n\\\", runner.report.skipped);\\n  } else {\\n    fprintf(MUNIT_OUTPUT_FILE, \\\"%d of %d (%0.0f%%) tests successful, %d (%0.0f%%) test skipped.\\\\n\\\",\\n            runner.report.successful, tests_run,\\n            (((double) runner.report.successful) / ((double) tests_run)) * 100.0,\\n            runner.report.skipped,\\n            (((double) runner.report.skipped) / ((double) tests_total)) * 100.0);\\n  }\\n\\n  if (runner.report.failed == 0 && runner.report.errored == 0) {\\n    result = EXIT_SUCCESS;\\n  }\\n\\n cleanup:\\n  free(runner.parameters);\\n  free((void*) runner.tests);\\n\\n  return result;\\n}\\n\\nint\\nmunit_suite_main(const MunitSuite* suite, void* user_data,\\n                 int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)]) {\\n  return munit_suite_main_custom(suite, user_data, argc, argv, NULL);\\n}\\n\", \"embeddings\": [-0.005421310663223267, 0.12594695389270782, 0.00220419280230999, 0.15391899645328522, 0.4005681872367859, -0.22558769583702087, 0.06338940560817719, 0.2784753143787384, 0.1481841802597046, -0.18032822012901306, -0.006846636533737183, -0.13148006796836853, -0.09492190182209015, 0.12466643750667572, 0.02817954495549202, -0.18115612864494324, 0.05748864263296127, 0.04120136797428131, 0.14464342594146729, -0.35013553500175476, -0.16184915602207184, 0.07591669261455536, 0.08258851617574692, 0.22345981001853943, 0.29062891006469727, 0.04301340505480766, 0.21527890861034393, 0.07232315838336945, 0.23407810926437378, -0.22263972461223602, 1.2889504432678223e-05, 0.044501692056655884, 0.036254193633794785, -0.24410057067871094, 0.09778767824172974, -0.004026636481285095, 0.10189543664455414, 0.021100882440805435, -0.11197507381439209, 0.05000483989715576, -0.24902498722076416, 0.03154187276959419, 0.1593424677848816, 0.13403260707855225, 0.10276855528354645, -0.031779587268829346, 0.10900434851646423, 0.16523876786231995, -0.06037629768252373, 0.04642590135335922, 0.08170032501220703, -0.07013744115829468, -0.00041754916310310364, -0.04809141159057617, -0.11022049188613892, -0.15447059273719788, 0.010989511385560036, 0.2632032036781311, -0.04749132692813873, 0.00417385995388031, -0.05679786205291748, -0.12331046164035797, -0.17842131853103638, 0.044534072279930115, 0.07005928456783295, 0.10609719157218933, -0.16344280540943146, -0.1609596461057663, -0.06523343920707703, -0.06681684404611588, 0.09019683301448822, 0.0376802459359169, 0.15831232070922852, -0.20458804070949554, -0.12874539196491241, -0.0646524578332901, 0.005548201501369476, 0.600050151348114, -0.052274249494075775, 0.13378454744815826, 0.2387371063232422, -0.11757960915565491, 0.1472303569316864, 0.07541050016880035, 0.09346531331539154, -0.03624378889799118, -0.08592423796653748, 0.01318030059337616, 0.06431058794260025, 0.1636781096458435, -0.028033219277858734, 0.1257152408361435, -0.016656741499900818, 0.03191658854484558, -0.00394706055521965, 0.02451189234852791, -0.002886313945055008, -0.20339693129062653, 0.06237521395087242, 0.300275057554245, -0.16843678057193756, -0.07673466205596924, -0.25190380215644836, 0.004808291792869568, -0.054734088480472565, -0.049401115626096725, -0.06084282696247101, 0.03939467668533325, 0.057919226586818695, -0.03249841183423996, 0.09232845902442932, 0.025994129478931427, 0.025681987404823303, 0.09183227270841599, -0.1113802045583725, -0.10014478862285614, 0.10825828462839127, -0.0249052494764328, 0.16199733316898346, -0.040993377566337585, 0.11829729378223419, 0.07682034373283386, 0.06583210080862045, -0.07734218239784241, -0.05667179077863693, 0.10264717042446136, 0.12806831300258636, -0.16422292590141296, 0.1529911458492279, 0.12201552093029022, -0.04327455908060074, -0.1478416621685028, 0.03219445422291756, -0.11975418031215668, 0.1323334127664566, 0.050912149250507355, 0.041829172521829605, -0.004610240459442139, -0.011125266551971436, 0.022937893867492676, -0.05552093684673309, -0.013521276414394379, 0.2621617317199707, -0.0653015673160553, 0.15396401286125183, -0.06062186136841774, 0.13192737102508545, 0.138119176030159, -0.287655234336853, -0.2441137284040451, 0.04947509989142418, -0.07315835356712341, 0.0453568771481514, 0.028782127425074577, -0.1686350554227829, 0.6944052577018738, 0.16064491868019104, -0.09239009767770767, -0.03569336235523224, -0.02569536119699478, 0.07288546115159988, -0.2878945469856262, -0.017868779599666595, 0.15696831047534943, 0.06292488425970078, 0.11238352209329605, 0.03917989507317543, 0.05883277580142021, 0.07776356488466263, 0.013549108058214188, 0.08538854122161865, -0.05889430642127991, -0.036125730723142624, 0.13430695235729218, -0.09157764166593552, -0.1862901747226715, -0.18402795493602753, 0.06853364408016205, -0.058603569865226746, 0.017261017113924026, -0.04833029955625534, 0.046458370983600616, -0.15629062056541443, -0.01953129470348358, 0.022990699857473373, -0.04764252528548241, 0.08416009694337845, -0.00034906325163319707, 0.09609007090330124, -0.018112843856215477, 0.14731410145759583, 0.11750088632106781, 0.05057363957166672, -0.0598592609167099, -0.08839277178049088, 0.17486798763275146, -0.11466453224420547, -0.09475447982549667, 0.19238163530826569, -0.02586953341960907, -0.008816113695502281, -0.045255038887262344, 0.1954466849565506, -0.1580260545015335, 0.0025646761059761047, 0.2336946725845337, -0.16657772660255432, -0.02426828444004059, 0.01159939169883728, -0.037277303636074066, -0.014294072985649109, 0.27954891324043274, 0.04859958216547966, 0.04819709062576294, 0.028483137488365173, -0.15588265657424927, 0.08777473866939545, 0.11454867571592331, -0.0370473638176918, -0.12696118652820587, 0.1542101949453354, 0.22082814574241638, -0.02334265597164631, -0.05603586137294769, -0.0643344447016716, 0.1746104210615158, 0.19252490997314453, 0.06489711254835129, -0.011785909533500671, 0.05878368020057678, 0.27067720890045166, 0.18649742007255554, -0.20491613447666168, 0.08026152849197388, 0.08232180029153824, -0.1842816174030304, -0.07664808630943298, 0.03117624670267105, 0.06590253859758377, -0.08970479667186737, 0.010422907769680023, 0.12919627130031586, 0.1790228635072708, 0.25505661964416504, 0.024950463324785233, 0.09873344004154205, -0.12856654822826385, -0.0818687379360199, 0.002081366255879402, 0.033589571714401245, -0.06252703815698624, -0.006520441733300686, 0.03876171261072159, -0.09557108581066132, -0.09791941940784454, -0.04599994048476219, -0.15073716640472412, 0.04707363620400429, 0.13362468779087067, 0.30020272731781006, -0.011990368366241455, -0.09159136563539505, 0.07943834364414215, -0.0368373766541481, -0.16373729705810547, -0.3618171811103821, -0.003331318497657776, 0.017805948853492737, -0.04543747007846832, 0.0128627372905612, 0.05912012606859207, -0.03596421331167221, 0.26510876417160034, 0.09184335917234421, -0.004083510488271713, -0.02116800844669342, 0.071370430290699, -0.0114537812769413, -0.17209714651107788, -0.01188846305012703, -0.06077003851532936, 0.08086766302585602, -0.10301938652992249, 0.00806339830160141, 0.04728499799966812, 0.06131184101104736, 0.045314040035009384, -0.048001714050769806, 0.06696148961782455, -0.0015618354082107544, 0.04954886436462402, 0.02306457608938217, 0.04017492011189461, 0.15370100736618042, 0.0021982230246067047, 0.13919752836227417, 0.19386577606201172, -0.04002001881599426, 0.056733764708042145, -0.19986367225646973, -0.0043950676918029785, -0.268070250749588, 0.05327976867556572, -0.11394043266773224, 0.33922266960144043, -0.15738403797149658, 0.09862217307090759, -0.023863933980464935, 0.2657250165939331, 0.002548079937696457, 0.03611169010400772, 0.03792410343885422, -0.11647207289934158, 0.1498485505580902, -0.12434893846511841, 0.020073052495718002, 0.0305659007281065, -0.13693785667419434, -0.004037573933601379, -0.018513746559619904, -0.002568308264017105, 0.1314476877450943, 0.23041023313999176, 0.08325289189815521, 0.045776233077049255, 0.14238978922367096, 0.13803896307945251, 0.05850250646471977, -0.09527613967657089, 0.6731199026107788, -0.6889142394065857, 0.21313130855560303, -0.08431622385978699, 0.3781532645225525, -0.07892844080924988, 0.1785227358341217, 0.01719573140144348, 0.12682394683361053, 0.13047762215137482, 0.15277627110481262, -0.15477213263511658, 0.005537526682019234, -0.11614346504211426, 0.2632446587085724, 0.11251893639564514, 0.21215230226516724, 0.20760124921798706, -0.05119398608803749, 0.12625043094158173, -0.15363429486751556, -0.04613833874464035, 0.15361349284648895, 0.05022306740283966, -0.07071252167224884, 0.10382376611232758, 0.32422754168510437, -0.040584780275821686, -0.11516386270523071, -0.021450050175189972, 0.050826311111450195, 0.09144303947687149, -0.1215117946267128, 0.10791872441768646, -0.10043321549892426, 0.33016979694366455, -0.3334406316280365, -0.3683086931705475, 0.11567091196775436, -0.12716427445411682, 0.023828260600566864, 0.13255104422569275, 0.17697927355766296, 0.09584715217351913, -0.1658608466386795, 0.09670422971248627, -0.012215904891490936, -0.02495943009853363, 0.0388018935918808, 0.02672535553574562, 0.20119813084602356, 0.003429718315601349, 0.012833751738071442, 0.0296200942248106, 0.018599120900034904, 0.01995772123336792, -0.213029682636261, 0.20355066657066345, 0.15122538805007935, 0.2000187337398529, -0.06225520744919777, 0.08941622078418732, -0.08890225738286972, 0.012814141809940338, -0.07367122173309326, 0.059457115828990936, 0.09599585831165314, -0.13889524340629578, 0.19743449985980988, -0.2281934916973114, -0.10209937393665314, 0.143016517162323, 0.16293393075466156, -0.02549843117594719, 0.22792746126651764, 0.1368691772222519, 0.14881831407546997, 0.1145917996764183, -0.2483358234167099, -0.08158328384160995, -0.28090760111808777, 0.11206329613924026, 0.09810186922550201, 0.05837387591600418, -0.11177370697259903, 0.16153211891651154, -0.05822987109422684, -0.026956211775541306, -0.18557670712471008, 0.02979465015232563, 0.13106775283813477, 0.19467568397521973, 0.18277379870414734, 0.05638200789690018, -0.1951868236064911, -0.11152005195617676, 0.031909458339214325, 0.02291610836982727, -0.06874613463878632, 0.03911817818880081, -0.12831884622573853, 0.0006084330379962921, 0.36741194128990173, 0.11847815662622452, 0.09222770482301712, 0.03693532571196556, -0.08948251605033875, -0.14852547645568848, -0.016178958117961884, 0.02383611910045147, -0.04051505774259567, 0.031292688101530075, 0.02034870721399784, 0.09140339493751526, 0.13781459629535675, -0.0038496311753988266, -0.04651173949241638, 0.39623770117759705, 0.09818209707736969, -0.09602893888950348, 0.0884903073310852, -0.12393517792224884, -0.013082608580589294, -0.15745370090007782, -0.27337831258773804, 0.15669021010398865, 0.12810340523719788, 0.11033984273672104, 0.076777383685112, 0.0647272914648056, 0.03307052329182625, -0.05176948010921478, 0.09130430221557617, -0.0982091873884201, -0.17788973450660706, 0.05612068250775337, -0.08513111621141434, 0.1310335248708725, 0.021176813170313835, 0.18196839094161987, 0.11417894065380096, 0.0014019981026649475, 0.14118066430091858, 0.008499912917613983, -0.16580913960933685, 0.06126607954502106, -0.06806301325559616, 0.014801078476011753, -0.16503338515758514, -0.02996661141514778, -0.2349529266357422, 0.05220048874616623, 0.08368164300918579, 0.1409495323896408, 0.0448986291885376, 0.027326125651597977, -0.16757991909980774, 0.18871742486953735, 0.1685064733028412, -0.10105106234550476, 0.04554835334420204, -0.04593688249588013, 0.02645288035273552, 0.026814816519618034, 0.11722953617572784, 0.2665080428123474, 0.10752201080322266, 0.08986203372478485, 0.0709846168756485, 0.31744399666786194, -0.0918116346001625, 0.039838358759880066, 0.05019286274909973, 0.032260965555906296, -0.045183729380369186, -0.05560075864195824, -0.10574086755514145, -0.04244382679462433, 0.08835409581661224, 0.04125719517469406, -0.1698048710823059, -0.04632540047168732, -0.17990189790725708, 0.11223895847797394, -0.009959321469068527, -0.000146426260471344, -0.011053033173084259, 0.09222865104675293, -0.03004840761423111, -0.060569822788238525, 0.2832905650138855, -0.13892903923988342, -0.11469843983650208, -0.06978638470172882, 0.03393113613128662, -0.13819730281829834, 0.06007887423038483, 0.12592071294784546, -0.06241486221551895, 0.02196095883846283, 0.06313422322273254, 0.07831718772649765, -0.07151418924331665, 0.1037541851401329, 0.1879337728023529, -0.029919538646936417, 0.0847475677728653, 0.06584793329238892, -0.020658425986766815, 0.18997006118297577, 0.017736200243234634, -0.16242314875125885, -0.1289764642715454, 0.08826358616352081, -0.0867602676153183, 0.08521047979593277, 0.05714280903339386, 0.10288716107606888, 0.028018251061439514, -0.028665952384471893, -0.00873931497335434, -0.002107996493577957, -0.7579187750816345, -0.02609872817993164, 0.15632423758506775, -0.03592783585190773, 0.02262270823121071, 0.16916923224925995, 0.05843646824359894, 0.0022090449929237366, 0.14323556423187256, 0.09071535617113113, 0.08055556565523148, 0.18880675733089447, 0.1700522005558014, 0.05641048401594162, -0.05737106129527092, 0.05266841500997543, 0.13129691779613495, -0.2760237455368042, 0.1773107349872589, -0.1567206233739853, -0.07568826526403427, 0.06921414285898209, 0.2503591775894165, -0.06077516824007034, 0.06655526161193848, 0.2615855932235718, 0.026380950585007668, 0.1331906020641327, -0.05495527386665344, 0.08681058883666992, 0.2544545531272888, 0.12131891399621964, -0.23559527099132538, 0.05015946552157402, 0.08864565193653107, 0.22725524008274078, 0.11163284629583359, 13.782625198364258, -0.005233430303633213, 0.2767896354198456, -0.09711221605539322, -0.06193801760673523, -0.08554258942604065, -0.12179019302129745, 0.044371381402015686, -0.09449584782123566, -0.03370276838541031, 0.12693873047828674, -0.056990958750247955, 0.018391219899058342, 0.03803624212741852, -0.015776649117469788, 0.010258883237838745, 0.059289854019880295, -0.0971122682094574, 0.15218228101730347, 0.0355091392993927, -0.12586429715156555, -0.06400196254253387, -0.026745572686195374, -0.2172979712486267, 0.058047134429216385, -0.1373264193534851, 0.07368635386228561, 0.054884172976017, 0.017002329230308533, -0.009237349033355713, 0.1266731321811676, 0.1131497174501419, 0.1477264016866684, -0.014643840491771698, -0.042185477912425995, -0.1942112296819687, -0.3978751301765442, -0.08714783191680908, 0.08441194891929626, -0.02289540320634842, -0.025508850812911987, -0.0046191588044166565, 0.14906878769397736, -0.06879488378763199, 0.10481025278568268, 0.07349159568548203, -0.16239087283611298, 0.21004897356033325, -0.00915943831205368, -0.04791628569364548, 0.19414684176445007, 0.15851065516471863, 0.2359708696603775, 0.006331084296107292, -0.1348724663257599, -0.2134309560060501, 0.30697959661483765, -0.022150404751300812, -0.029056772589683533, 0.20409567654132843, 0.0017702914774417877, 0.05336785316467285, -0.07870441675186157, 0.0013028420507907867, -0.0593915618956089, -0.04040611535310745, 0.11513165384531021, 0.11237120628356934, -0.12519773840904236, 0.022228635847568512, 0.19517534971237183, -0.16382531821727753, 0.08793509751558304, 0.06083045154809952, -0.0803784728050232, 0.11957844346761703, -0.11592809110879898, -0.0076714977622032166, 0.08739308267831802, -0.2471368908882141, 0.016794804483652115, 0.0015256330370903015, -0.19113197922706604, -0.04885853826999664, -0.29700028896331787, 0.040956802666187286, -0.04954938217997551, 0.23706276714801788, 0.22838670015335083, -0.048866234719753265, -0.12405857443809509, 0.06422539055347443, -0.026133596897125244, -0.18101415038108826, 0.250571072101593, -0.051122717559337616, 0.005644975230097771, -0.1858316957950592, 0.08488593995571136, 0.12056779861450195, -0.06589743494987488, -0.04009842500090599, -0.029366903007030487, 0.07650773227214813, -0.14203378558158875, 0.012737508863210678, -0.016430553048849106, -0.055834248661994934, 0.05510310083627701, 0.08204534649848938, 0.028019921854138374, 0.12666577100753784, 0.12891963124275208, -0.1418035477399826, -0.08686428517103195, 0.028415018692612648, 0.062452882528305054, 0.040909238159656525, 0.2239864468574524, 0.13848991692066193, 0.14284183084964752, 0.07137353718280792, -0.15530185401439667, -0.018760595470666885, 0.10417027026414871, -0.15129491686820984, 0.06909694522619247, 0.07735994458198547, 0.08092834055423737, -0.08762764930725098, 0.010365214198827744, -0.07142352312803268, 0.38120588660240173, 0.14167200028896332, 0.07264291495084763, -0.013521015644073486, 0.011254608631134033, 0.018647752702236176, 0.15553492307662964, 0.195042222738266, 0.09842444211244583, -0.01383315771818161, 0.19001930952072144, -0.09972058981657028, -0.062736377120018, 0.24638116359710693, 0.1556897759437561, 0.08831164240837097, -0.1030881255865097, 0.09869049489498138, 0.08928697556257248, 0.18330621719360352, -0.22009101510047913, -0.10638867318630219, -0.14499731361865997, -0.23348866403102875, -0.08422812819480896, 0.0791582316160202, -0.02220235764980316, -0.058019008487463, 0.1756078600883484, -0.31108856201171875, 0.03013620898127556, -0.18992413580417633, -0.015103574842214584, 0.11124949157238007, 0.11206500977277756, 0.10429903864860535, 0.12540516257286072, -0.08828365057706833, 0.10257601737976074, 0.02745460718870163, -0.02709871716797352, 0.042932212352752686, -0.041215866804122925, 0.060886792838573456, 0.12912899255752563, -0.29344725608825684, -0.12999652326107025, 0.12318398058414459]}"
"{\"sha\": \"00ede07ca6c77e3b71aaa699b2c48b9718700cc8\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"test/unit/munit.c\", \"func_name\": \"munit_maybe_free_concat\", \"original_string\": \"static void\\nmunit_maybe_free_concat(char* s, const char* prefix, const char* suffix) {\\n  if (prefix != s && suffix != s)\\n    free(s);\\n}\", \"code_tokens\": [\"static\", \"void\", \"munit_maybe_free_concat\", \"(\", \"char\", \"*\", \"s\", \",\", \"const\", \"char\", \"*\", \"prefix\", \",\", \"const\", \"char\", \"*\", \"suffix\", \")\", \"{\", \"if\", \"(\", \"prefix\", \"!=\", \"s\", \"&&\", \"suffix\", \"!=\", \"s\", \")\", \"free\", \"(\", \"s\", \")\", \";\", \"}\"], \"docstring\": \"/* Possbily free a string returned by munit_maybe_concat. */\", \"docstring_tokens\": [\"/\", \"*\", \"Possbily\", \"free\", \"a\", \"string\", \"returned\", \"by\", \"munit_maybe_concat\", \".\", \"*\", \"/\"], \"raw_contents\": \"/* Copyright (c) 2013-2018 Evan Nemerson <evan@nemerson.com>\\n *\\n * Permission is hereby granted, free of charge, to any person\\n * obtaining a copy of this software and associated documentation\\n * files (the \\\"Software\\\"), to deal in the Software without\\n * restriction, including without limitation the rights to use, copy,\\n * modify, merge, publish, distribute, sublicense, and/or sell copies\\n * of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be\\n * included in all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND,\\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n * SOFTWARE.\\n */\\n\\n/*** Configuration ***/\\n\\n/* This is just where the output from the test goes.  It's really just\\n * meant to let you choose stdout or stderr, but if anyone really want\\n * to direct it to a file let me know, it would be fairly easy to\\n * support. */\\n#if !defined(MUNIT_OUTPUT_FILE)\\n#  define MUNIT_OUTPUT_FILE stdout\\n#endif\\n\\n/* This is a bit more useful; it tells \\u00b5nit how to format the seconds in\\n * timed tests.  If your tests run for longer you might want to reduce\\n * it, and if your computer is really fast and your tests are tiny you\\n * can increase it. */\\n#if !defined(MUNIT_TEST_TIME_FORMAT)\\n#  define MUNIT_TEST_TIME_FORMAT \\\"0.8f\\\"\\n#endif\\n\\n/* If you have long test names you might want to consider bumping\\n * this.  The result information takes 43 characters. */\\n#if !defined(MUNIT_TEST_NAME_LEN)\\n#  define MUNIT_TEST_NAME_LEN 37\\n#endif\\n\\n/* If you don't like the timing information, you can disable it by\\n * defining MUNIT_DISABLE_TIMING. */\\n#if !defined(MUNIT_DISABLE_TIMING)\\n#  define MUNIT_ENABLE_TIMING\\n#endif\\n\\n/*** End configuration ***/\\n\\n#if defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE < 200809L)\\n#  undef _POSIX_C_SOURCE\\n#endif\\n#if !defined(_POSIX_C_SOURCE)\\n#  define _POSIX_C_SOURCE 200809L\\n#endif\\n\\n/* Solaris freaks out if you try to use a POSIX or SUS standard without\\n * the \\\"right\\\" C standard. */\\n#if defined(_XOPEN_SOURCE)\\n#  undef _XOPEN_SOURCE\\n#endif\\n\\n#if defined(__STDC_VERSION__)\\n#  if __STDC_VERSION__ >= 201112L\\n#    define _XOPEN_SOURCE 700\\n#  elif __STDC_VERSION__ >= 199901L\\n#    define _XOPEN_SOURCE 600\\n#  endif\\n#endif\\n\\n/* Because, according to Microsoft, POSIX is deprecated.  You've got\\n * to appreciate the chutzpah. */\\n#if defined(_MSC_VER) && !defined(_CRT_NONSTDC_NO_DEPRECATE)\\n#  define _CRT_NONSTDC_NO_DEPRECATE\\n#endif\\n\\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\\n#  include <stdbool.h>\\n#elif defined(_WIN32)\\n/* https://msdn.microsoft.com/en-us/library/tf4dy80a.aspx */\\n#endif\\n\\n#include <limits.h>\\n#include <time.h>\\n#include <errno.h>\\n#include <string.h>\\n#include <stdlib.h>\\n#include <stdio.h>\\n#include <stdarg.h>\\n#include <setjmp.h>\\n\\n#if !defined(MUNIT_NO_NL_LANGINFO) && !defined(_WIN32)\\n#define MUNIT_NL_LANGINFO\\n#include <locale.h>\\n#include <langinfo.h>\\n#include <strings.h>\\n#endif\\n\\n#if !defined(_WIN32)\\n#  include <unistd.h>\\n#  include <sys/types.h>\\n#  include <sys/wait.h>\\n#else\\n#  include <windows.h>\\n#  include <io.h>\\n#  include <fcntl.h>\\n#  if !defined(STDERR_FILENO)\\n#    define STDERR_FILENO _fileno(stderr)\\n#  endif\\n#endif\\n\\n#include \\\"munit.h\\\"\\n\\n#define MUNIT_STRINGIFY(x) #x\\n#define MUNIT_XSTRINGIFY(x) MUNIT_STRINGIFY(x)\\n\\n#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__SUNPRO_CC) || defined(__IBMCPP__)\\n#  define MUNIT_THREAD_LOCAL __thread\\n#elif (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201102L)) || defined(_Thread_local)\\n#  define MUNIT_THREAD_LOCAL _Thread_local\\n#elif defined(_WIN32)\\n#  define MUNIT_THREAD_LOCAL __declspec(thread)\\n#endif\\n\\n/* MSVC 12.0 will emit a warning at /W4 for code like 'do { ... }\\n * while (0)', or 'do { ... } while (1)'.  I'm pretty sure nobody\\n * at Microsoft compiles with /W4. */\\n#if defined(_MSC_VER) && (_MSC_VER <= 1800)\\n#pragma warning(disable: 4127)\\n#endif\\n\\n#if defined(_WIN32) || defined(__EMSCRIPTEN__)\\n#  define MUNIT_NO_FORK\\n#endif\\n\\n#if defined(__EMSCRIPTEN__)\\n#  define MUNIT_NO_BUFFER\\n#endif\\n\\n/*** Logging ***/\\n\\nstatic MunitLogLevel munit_log_level_visible = MUNIT_LOG_INFO;\\nstatic MunitLogLevel munit_log_level_fatal = MUNIT_LOG_ERROR;\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\nstatic MUNIT_THREAD_LOCAL munit_bool munit_error_jmp_buf_valid = 0;\\nstatic MUNIT_THREAD_LOCAL jmp_buf munit_error_jmp_buf;\\n#endif\\n\\n/* At certain warning levels, mingw will trigger warnings about\\n * suggesting the format attribute, which we've explicity *not* set\\n * because it will then choke on our attempts to use the MS-specific\\n * I64 modifier for size_t (which we have to use since MSVC doesn't\\n * support the C99 z modifier). */\\n\\n#if defined(__MINGW32__) || defined(__MINGW64__)\\n#  pragma GCC diagnostic push\\n#  pragma GCC diagnostic ignored \\\"-Wsuggest-attribute=format\\\"\\n#endif\\n\\nMUNIT_PRINTF(5,0)\\nstatic void\\nmunit_logf_exv(MunitLogLevel level, FILE* fp, const char* filename, int line, const char* format, va_list ap) {\\n  if (level < munit_log_level_visible)\\n    return;\\n\\n  switch (level) {\\n    case MUNIT_LOG_DEBUG:\\n      fputs(\\\"Debug\\\", fp);\\n      break;\\n    case MUNIT_LOG_INFO:\\n      fputs(\\\"Info\\\", fp);\\n      break;\\n    case MUNIT_LOG_WARNING:\\n      fputs(\\\"Warning\\\", fp);\\n      break;\\n    case MUNIT_LOG_ERROR:\\n      fputs(\\\"Error\\\", fp);\\n      break;\\n    default:\\n      munit_logf_ex(MUNIT_LOG_ERROR, filename, line, \\\"Invalid log level (%d)\\\", level);\\n      return;\\n  }\\n\\n  fputs(\\\": \\\", fp);\\n  if (filename != NULL)\\n    fprintf(fp, \\\"%s:%d: \\\", filename, line);\\n  vfprintf(fp, format, ap);\\n  fputc('\\\\n', fp);\\n}\\n\\nMUNIT_PRINTF(3,4)\\nstatic void\\nmunit_logf_internal(MunitLogLevel level, FILE* fp, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(level, fp, NULL, 0, format, ap);\\n  va_end(ap);\\n}\\n\\nstatic void\\nmunit_log_internal(MunitLogLevel level, FILE* fp, const char* message) {\\n  munit_logf_internal(level, fp, \\\"%s\\\", message);\\n}\\n\\nvoid\\nmunit_logf_ex(MunitLogLevel level, const char* filename, int line, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(level, stderr, filename, line, format, ap);\\n  va_end(ap);\\n\\n  if (level >= munit_log_level_fatal) {\\n#if defined(MUNIT_THREAD_LOCAL)\\n    if (munit_error_jmp_buf_valid)\\n      longjmp(munit_error_jmp_buf, 1);\\n#endif\\n    abort();\\n  }\\n}\\n\\nvoid\\nmunit_errorf_ex(const char* filename, int line, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(MUNIT_LOG_ERROR, stderr, filename, line, format, ap);\\n  va_end(ap);\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\n  if (munit_error_jmp_buf_valid)\\n    longjmp(munit_error_jmp_buf, 1);\\n#endif\\n  abort();\\n}\\n\\n#if defined(__MINGW32__) || defined(__MINGW64__)\\n#pragma GCC diagnostic pop\\n#endif\\n\\n#if !defined(MUNIT_STRERROR_LEN)\\n#  define MUNIT_STRERROR_LEN 80\\n#endif\\n\\nstatic void\\nmunit_log_errno(MunitLogLevel level, FILE* fp, const char* msg) {\\n#if defined(MUNIT_NO_STRERROR_R) || (defined(__MINGW32__) && !defined(MINGW_HAS_SECURE_API))\\n  munit_logf_internal(level, fp, \\\"%s: %s (%d)\\\", msg, strerror(errno), errno);\\n#else\\n  char munit_error_str[MUNIT_STRERROR_LEN];\\n  munit_error_str[0] = '\\\\0';\\n\\n#if !defined(_WIN32)\\n  strerror_r(errno, munit_error_str, MUNIT_STRERROR_LEN);\\n#else\\n  strerror_s(munit_error_str, MUNIT_STRERROR_LEN, errno);\\n#endif\\n\\n  munit_logf_internal(level, fp, \\\"%s: %s (%d)\\\", msg, munit_error_str, errno);\\n#endif\\n}\\n\\n/*** Memory allocation ***/\\n\\nvoid*\\nmunit_malloc_ex(const char* filename, int line, size_t size) {\\n  void* ptr;\\n\\n  if (size == 0)\\n    return NULL;\\n\\n  ptr = calloc(1, size);\\n  if (MUNIT_UNLIKELY(ptr == NULL)) {\\n    munit_logf_ex(MUNIT_LOG_ERROR, filename, line, \\\"Failed to allocate %\\\" MUNIT_SIZE_MODIFIER \\\"u bytes.\\\", size);\\n  }\\n\\n  return ptr;\\n}\\n\\n/*** Timer code ***/\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n\\n#define psnip_uint64_t munit_uint64_t\\n#define psnip_uint32_t munit_uint32_t\\n\\n/* Code copied from portable-snippets\\n * <https://github.com/nemequ/portable-snippets/>.  If you need to\\n * change something, please do it there so we can keep the code in\\n * sync. */\\n\\n/* Clocks (v1)\\n * Portable Snippets - https://gitub.com/nemequ/portable-snippets\\n * Created by Evan Nemerson <evan@nemerson.com>\\n *\\n *   To the extent possible under law, the authors have waived all\\n *   copyright and related or neighboring rights to this code.  For\\n *   details, see the Creative Commons Zero 1.0 Universal license at\\n *   https://creativecommons.org/publicdomain/zero/1.0/\\n */\\n\\n#if !defined(PSNIP_CLOCK_H)\\n#define PSNIP_CLOCK_H\\n\\n#if !defined(psnip_uint64_t)\\n#  include \\\"../exact-int/exact-int.h\\\"\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_STATIC_INLINE)\\n#  if defined(__GNUC__)\\n#    define PSNIP_CLOCK__COMPILER_ATTRIBUTES __attribute__((__unused__))\\n#  else\\n#    define PSNIP_CLOCK__COMPILER_ATTRIBUTES\\n#  endif\\n\\n#  define PSNIP_CLOCK__FUNCTION PSNIP_CLOCK__COMPILER_ATTRIBUTES static\\n#endif\\n\\nenum PsnipClockType {\\n  /* This clock provides the current time, in units since 1970-01-01\\n   * 00:00:00 UTC not including leap seconds.  In other words, UNIX\\n   * time.  Keep in mind that this clock doesn't account for leap\\n   * seconds, and can go backwards (think NTP adjustments). */\\n  PSNIP_CLOCK_TYPE_WALL = 1,\\n  /* The CPU time is a clock which increases only when the current\\n   * process is active (i.e., it doesn't increment while blocking on\\n   * I/O). */\\n  PSNIP_CLOCK_TYPE_CPU = 2,\\n  /* Monotonic time is always running (unlike CPU time), but it only\\n     ever moves forward unless you reboot the system.  Things like NTP\\n     adjustments have no effect on this clock. */\\n  PSNIP_CLOCK_TYPE_MONOTONIC = 3\\n};\\n\\nstruct PsnipClockTimespec {\\n  psnip_uint64_t seconds;\\n  psnip_uint64_t nanoseconds;\\n};\\n\\n/* Methods we support: */\\n\\n#define PSNIP_CLOCK_METHOD_CLOCK_GETTIME                   1\\n#define PSNIP_CLOCK_METHOD_TIME                            2\\n#define PSNIP_CLOCK_METHOD_GETTIMEOFDAY                    3\\n#define PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER         4\\n#define PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME              5\\n#define PSNIP_CLOCK_METHOD_CLOCK                           6\\n#define PSNIP_CLOCK_METHOD_GETPROCESSTIMES                 7\\n#define PSNIP_CLOCK_METHOD_GETRUSAGE                       8\\n#define PSNIP_CLOCK_METHOD_GETSYSTEMTIMEPRECISEASFILETIME  9\\n#define PSNIP_CLOCK_METHOD_GETTICKCOUNT64                 10\\n\\n#include <assert.h>\\n\\n#if defined(HEDLEY_UNREACHABLE)\\n#  define PSNIP_CLOCK_UNREACHABLE() HEDLEY_UNREACHABLE()\\n#else\\n#  define PSNIP_CLOCK_UNREACHABLE() assert(0)\\n#endif\\n\\n/* Choose an implementation */\\n\\n/* #undef PSNIP_CLOCK_WALL_METHOD */\\n/* #undef PSNIP_CLOCK_CPU_METHOD */\\n/* #undef PSNIP_CLOCK_MONOTONIC_METHOD */\\n\\n/* We want to be able to detect the libc implementation, so we include\\n   <limits.h> (<features.h> isn't available everywhere). */\\n\\n#if defined(__unix__) || defined(__unix) || defined(__linux__)\\n#  include <limits.h>\\n#  include <unistd.h>\\n#endif\\n\\n#if defined(_POSIX_TIMERS) && (_POSIX_TIMERS > 0)\\n/* These are known to work without librt.  If you know of others\\n * please let us know so we can add them. */\\n#  if \\\\\\n  (defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 17))) || \\\\\\n  (defined(__FreeBSD__))\\n#    define PSNIP_CLOCK_HAVE_CLOCK_GETTIME\\n#  elif !defined(PSNIP_CLOCK_NO_LIBRT)\\n#    define PSNIP_CLOCK_HAVE_CLOCK_GETTIME\\n#  endif\\n#endif\\n\\n#if defined(_WIN32)\\n#  if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#    define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n#  endif\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n#  endif\\n#endif\\n\\n#if defined(__MACH__) && !defined(__gnu_hurd__)\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n#  endif\\n#endif\\n\\n#if defined(PSNIP_CLOCK_HAVE_CLOCK_GETTIME)\\n#  include <time.h>\\n#  if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#    if defined(CLOCK_REALTIME_PRECISE)\\n#      define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_WALL CLOCK_REALTIME_PRECISE\\n#    elif !defined(__sun)\\n#      define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_WALL CLOCK_REALTIME\\n#    endif\\n#  endif\\n#  if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#    if defined(_POSIX_CPUTIME) || defined(CLOCK_PROCESS_CPUTIME_ID)\\n#      define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_CPU CLOCK_PROCESS_CPUTIME_ID\\n#    elif defined(CLOCK_VIRTUAL)\\n#      define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_CPU CLOCK_VIRTUAL\\n#    endif\\n#  endif\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    if defined(CLOCK_MONOTONIC_RAW)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC\\n#    elif defined(CLOCK_MONOTONIC_PRECISE)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC_PRECISE\\n#    elif defined(_POSIX_MONOTONIC_CLOCK) || defined(CLOCK_MONOTONIC)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC\\n#    endif\\n#  endif\\n#endif\\n\\n#if defined(_POSIX_VERSION) && (_POSIX_VERSION >= 200112L)\\n#  if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#    define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n#  endif\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#  define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_TIME\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#  define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK\\n#endif\\n\\n/* Primarily here for testing. */\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD) && defined(PSNIP_CLOCK_REQUIRE_MONOTONIC)\\n#  error No monotonic clock found.\\n#endif\\n\\n/* Implementations */\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_TIME))\\n#  include <time.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETTIMEOFDAY)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETTIMEOFDAY)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY))\\n#  include <sys/time.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETTICKCOUNT64)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETTICKCOUNT64)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64))\\n#  include <windows.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETRUSAGE)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETRUSAGE)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETRUSAGE))\\n#  include <sys/time.h>\\n#  include <sys/resource.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME))\\n#  include <CoreServices/CoreServices.h>\\n#  include <mach/mach.h>\\n#  include <mach/mach_time.h>\\n#endif\\n\\n/*** Implementations ***/\\n\\n#define PSNIP_CLOCK_NSEC_PER_SEC ((psnip_uint32_t) (1000000000ULL))\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME))\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock__clock_getres (clockid_t clk_id) {\\n  struct timespec res;\\n  int r;\\n\\n  r = clock_getres(clk_id, &res);\\n  if (r != 0)\\n    return 0;\\n\\n  return (psnip_uint32_t) (PSNIP_CLOCK_NSEC_PER_SEC / res.tv_nsec);\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock__clock_gettime (clockid_t clk_id, struct PsnipClockTimespec* res) {\\n  struct timespec ts;\\n\\n  if (clock_gettime(clk_id, &ts) != 0)\\n    return -10;\\n\\n  res->seconds = (psnip_uint64_t) (ts.tv_sec);\\n  res->nanoseconds = (psnip_uint64_t) (ts.tv_nsec);\\n\\n  return 0;\\n}\\n#endif\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_wall_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_WALL);\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n  return 1000000;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_TIME\\n  return 1;\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_wall_get_time (struct PsnipClockTimespec* res) {\\n  (void) res;\\n\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n  return -2;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_WALL, res);\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_TIME\\n  res->seconds = time(NULL);\\n  res->nanoseconds = 0;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n  struct timeval tv;\\n\\n  if (gettimeofday(&tv, NULL) != 0)\\n    return -6;\\n\\n  res->seconds = tv.tv_sec;\\n  res->nanoseconds = tv.tv_usec * 1000;\\n#else\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_cpu_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_CPU);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK\\n  return CLOCKS_PER_SEC;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n  return PSNIP_CLOCK_NSEC_PER_SEC / 100;\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_cpu_get_time (struct PsnipClockTimespec* res) {\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n  (void) res;\\n  return -2;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_CPU, res);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK\\n  clock_t t = clock();\\n  if (t == ((clock_t) -1))\\n    return -5;\\n  res->seconds = t / CLOCKS_PER_SEC;\\n  res->nanoseconds = (t % CLOCKS_PER_SEC) * (PSNIP_CLOCK_NSEC_PER_SEC / CLOCKS_PER_SEC);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n  FILETIME CreationTime, ExitTime, KernelTime, UserTime;\\n  LARGE_INTEGER date, adjust;\\n\\n  if (!GetProcessTimes(GetCurrentProcess(), &CreationTime, &ExitTime, &KernelTime, &UserTime))\\n    return -7;\\n\\n  /* http://www.frenk.com/2009/12/convert-filetime-to-unix-timestamp/ */\\n  date.HighPart = UserTime.dwHighDateTime;\\n  date.LowPart = UserTime.dwLowDateTime;\\n  adjust.QuadPart = 11644473600000 * 10000;\\n  date.QuadPart -= adjust.QuadPart;\\n\\n  res->seconds = date.QuadPart / 10000000;\\n  res->nanoseconds = (date.QuadPart % 10000000) * (PSNIP_CLOCK_NSEC_PER_SEC / 100);\\n#elif PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETRUSAGE\\n  struct rusage usage;\\n  if (getrusage(RUSAGE_SELF, &usage) != 0)\\n    return -8;\\n\\n  res->seconds = usage.ru_utime.tv_sec;\\n  res->nanoseconds = tv.tv_usec * 1000;\\n#else\\n  (void) res;\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_monotonic_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n  static mach_timebase_info_data_t tbi = { 0, };\\n  if (tbi.denom == 0)\\n    mach_timebase_info(&tbi);\\n  return (psnip_uint32_t) (tbi.numer / tbi.denom);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64\\n  return 1000;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n  LARGE_INTEGER Frequency;\\n  QueryPerformanceFrequency(&Frequency);\\n  return (psnip_uint32_t) ((Frequency.QuadPart > PSNIP_CLOCK_NSEC_PER_SEC) ? PSNIP_CLOCK_NSEC_PER_SEC : Frequency.QuadPart);\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_monotonic_get_time (struct PsnipClockTimespec* res) {\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n  (void) res;\\n  return -2;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC, res);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n  psnip_uint64_t nsec = mach_absolute_time();\\n  static mach_timebase_info_data_t tbi = { 0, };\\n  if (tbi.denom == 0)\\n    mach_timebase_info(&tbi);\\n  nsec *= ((psnip_uint64_t) tbi.numer) / ((psnip_uint64_t) tbi.denom);\\n  res->seconds = nsec / PSNIP_CLOCK_NSEC_PER_SEC;\\n  res->nanoseconds = nsec % PSNIP_CLOCK_NSEC_PER_SEC;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n  LARGE_INTEGER t, f;\\n  if (QueryPerformanceCounter(&t) == 0)\\n    return -12;\\n\\n  QueryPerformanceFrequency(&f);\\n  res->seconds = t.QuadPart / f.QuadPart;\\n  res->nanoseconds = t.QuadPart % f.QuadPart;\\n  if (f.QuadPart > PSNIP_CLOCK_NSEC_PER_SEC)\\n    res->nanoseconds /= f.QuadPart / PSNIP_CLOCK_NSEC_PER_SEC;\\n  else\\n    res->nanoseconds *= PSNIP_CLOCK_NSEC_PER_SEC / f.QuadPart;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64\\n  const ULONGLONG msec = GetTickCount64();\\n  res->seconds = msec / 1000;\\n  res->nanoseconds = sec % 1000;\\n#else\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\n/* Returns the number of ticks per second for the specified clock.\\n * For example, a clock with millisecond precision would return 1000,\\n * and a clock with 1 second (such as the time() function) would\\n * return 1.\\n *\\n * If the requested clock isn't available, it will return 0.\\n * Hopefully this will be rare, but if it happens to you please let us\\n * know so we can work on finding a way to support your system.\\n *\\n * Note that different clocks on the same system often have a\\n * different precisions.\\n */\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_get_precision (enum PsnipClockType clock_type) {\\n  switch (clock_type) {\\n    case PSNIP_CLOCK_TYPE_MONOTONIC:\\n      return psnip_clock_monotonic_get_precision ();\\n    case PSNIP_CLOCK_TYPE_CPU:\\n      return psnip_clock_cpu_get_precision ();\\n    case PSNIP_CLOCK_TYPE_WALL:\\n      return psnip_clock_wall_get_precision ();\\n  }\\n\\n  PSNIP_CLOCK_UNREACHABLE();\\n  return 0;\\n}\\n\\n/* Set the provided timespec to the requested time.  Returns 0 on\\n * success, or a negative value on failure. */\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_get_time (enum PsnipClockType clock_type, struct PsnipClockTimespec* res) {\\n  assert(res != NULL);\\n\\n  switch (clock_type) {\\n    case PSNIP_CLOCK_TYPE_MONOTONIC:\\n      return psnip_clock_monotonic_get_time (res);\\n    case PSNIP_CLOCK_TYPE_CPU:\\n      return psnip_clock_cpu_get_time (res);\\n    case PSNIP_CLOCK_TYPE_WALL:\\n      return psnip_clock_wall_get_time (res);\\n  }\\n\\n  return -1;\\n}\\n\\n#endif /* !defined(PSNIP_CLOCK_H) */\\n\\nstatic psnip_uint64_t\\nmunit_clock_get_elapsed(struct PsnipClockTimespec* start, struct PsnipClockTimespec* end) {\\n  psnip_uint64_t r = (end->seconds - start->seconds) * PSNIP_CLOCK_NSEC_PER_SEC;\\n  if (end->nanoseconds < start->nanoseconds) {\\n    r -= (start->nanoseconds - end->nanoseconds);\\n  } else {\\n    r += (end->nanoseconds - start->nanoseconds);\\n  }\\n  return r;\\n}\\n\\n#else\\n#  include <time.h>\\n#endif /* defined(MUNIT_ENABLE_TIMING) */\\n\\n/*** PRNG stuff ***/\\n\\n/* This is (unless I screwed up, which is entirely possible) the\\n * version of PCG with 32-bit state.  It was chosen because it has a\\n * small enough state that we should reliably be able to use CAS\\n * instead of requiring a lock for thread-safety.\\n *\\n * If I did screw up, I probably will not bother changing it unless\\n * there is a significant bias.  It's really not important this be\\n * particularly strong, as long as it is fairly random it's much more\\n * important that it be reproducible, so bug reports have a better\\n * chance of being reproducible. */\\n\\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__) && !defined(__EMSCRIPTEN__) && (!defined(__GNUC_MINOR__) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ > 8))\\n#  define HAVE_STDATOMIC\\n#elif defined(__clang__)\\n#  if __has_extension(c_atomic)\\n#    define HAVE_CLANG_ATOMICS\\n#  endif\\n#endif\\n\\n/* Workaround for http://llvm.org/bugs/show_bug.cgi?id=26911 */\\n#if defined(__clang__) && defined(_WIN32)\\n#  undef HAVE_STDATOMIC\\n#  if defined(__c2__)\\n#    undef HAVE_CLANG_ATOMICS\\n#  endif\\n#endif\\n\\n#if defined(_OPENMP)\\n#  define ATOMIC_UINT32_T uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#elif defined(HAVE_STDATOMIC)\\n#  include <stdatomic.h>\\n#  define ATOMIC_UINT32_T _Atomic uint32_t\\n#  define ATOMIC_UINT32_INIT(x) ATOMIC_VAR_INIT(x)\\n#elif defined(HAVE_CLANG_ATOMICS)\\n#  define ATOMIC_UINT32_T _Atomic uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#elif defined(_WIN32)\\n#  define ATOMIC_UINT32_T volatile LONG\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#else\\n#  define ATOMIC_UINT32_T volatile uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#endif\\n\\nstatic ATOMIC_UINT32_T munit_rand_state = ATOMIC_UINT32_INIT(42);\\n\\n#if defined(_OPENMP)\\nstatic inline void\\nmunit_atomic_store(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T value) {\\n#pragma omp critical (munit_atomics)\\n  *dest = value;\\n}\\n\\nstatic inline uint32_t\\nmunit_atomic_load(ATOMIC_UINT32_T* src) {\\n  int ret;\\n#pragma omp critical (munit_atomics)\\n  ret = *src;\\n  return ret;\\n}\\n\\nstatic inline uint32_t\\nmunit_atomic_cas(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T* expected, ATOMIC_UINT32_T desired) {\\n  munit_bool ret;\\n\\n#pragma omp critical (munit_atomics)\\n  {\\n    if (*dest == *expected) {\\n      *dest = desired;\\n      ret = 1;\\n    } else {\\n      ret = 0;\\n    }\\n  }\\n\\n  return ret;\\n}\\n#elif defined(HAVE_STDATOMIC)\\n#  define munit_atomic_store(dest, value)         atomic_store(dest, value)\\n#  define munit_atomic_load(src)                  atomic_load(src)\\n#  define munit_atomic_cas(dest, expected, value) atomic_compare_exchange_weak(dest, expected, value)\\n#elif defined(HAVE_CLANG_ATOMICS)\\n#  define munit_atomic_store(dest, value)         __c11_atomic_store(dest, value, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_load(src)                  __c11_atomic_load(src, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_cas(dest, expected, value) __c11_atomic_compare_exchange_weak(dest, expected, value, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\\n#elif defined(__GNUC__) && (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)\\n#  define munit_atomic_store(dest, value)         __atomic_store_n(dest, value, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_load(src)                  __atomic_load_n(src, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_cas(dest, expected, value) __atomic_compare_exchange_n(dest, expected, value, 1, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\\n#elif defined(__GNUC__) && (__GNUC__ >= 4)\\n#  define munit_atomic_store(dest,value)          do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\n#  define munit_atomic_cas(dest, expected, value) __sync_bool_compare_and_swap(dest, *expected, value)\\n#elif defined(_WIN32) /* Untested */\\n#  define munit_atomic_store(dest,value)          do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\n#  define munit_atomic_cas(dest, expected, value) InterlockedCompareExchange((dest), (value), *(expected))\\n#else\\n#  warning No atomic implementation, PRNG will not be thread-safe\\n#  define munit_atomic_store(dest, value)         do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\nstatic inline munit_bool\\nmunit_atomic_cas(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T* expected, ATOMIC_UINT32_T desired) {\\n  if (*dest == *expected) {\\n    *dest = desired;\\n    return 1;\\n  } else {\\n    return 0;\\n  }\\n}\\n#endif\\n\\n#define MUNIT_PRNG_MULTIPLIER (747796405U)\\n#define MUNIT_PRNG_INCREMENT  (1729U)\\n\\nstatic munit_uint32_t\\nmunit_rand_next_state(munit_uint32_t state) {\\n  return state * MUNIT_PRNG_MULTIPLIER + MUNIT_PRNG_INCREMENT;\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_from_state(munit_uint32_t state) {\\n  munit_uint32_t res = ((state >> ((state >> 28) + 4)) ^ state) * (277803737U);\\n  res ^= res >> 22;\\n  return res;\\n}\\n\\nvoid\\nmunit_rand_seed(munit_uint32_t seed) {\\n  munit_uint32_t state = munit_rand_next_state(seed + MUNIT_PRNG_INCREMENT);\\n  munit_atomic_store(&munit_rand_state, state);\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_generate_seed(void) {\\n  munit_uint32_t seed, state;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  struct PsnipClockTimespec wc = { 0, };\\n\\n  psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wc);\\n  seed = (munit_uint32_t) wc.nanoseconds;\\n#else\\n  seed = (munit_uint32_t) time(NULL);\\n#endif\\n\\n  state = munit_rand_next_state(seed + MUNIT_PRNG_INCREMENT);\\n  return munit_rand_from_state(state);\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_state_uint32(munit_uint32_t* state) {\\n  const munit_uint32_t old = *state;\\n  *state = munit_rand_next_state(old);\\n  return munit_rand_from_state(old);\\n}\\n\\nmunit_uint32_t\\nmunit_rand_uint32(void) {\\n  munit_uint32_t old, state;\\n\\n  do {\\n    old = munit_atomic_load(&munit_rand_state);\\n    state = munit_rand_next_state(old);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return munit_rand_from_state(old);\\n}\\n\\nstatic void\\nmunit_rand_state_memory(munit_uint32_t* state, size_t size, munit_uint8_t data[MUNIT_ARRAY_PARAM(size)]) {\\n  size_t members_remaining = size / sizeof(munit_uint32_t);\\n  size_t bytes_remaining = size % sizeof(munit_uint32_t);\\n  munit_uint8_t* b = data;\\n  munit_uint32_t rv;\\n  while (members_remaining-- > 0) {\\n    rv = munit_rand_state_uint32(state);\\n    memcpy(b, &rv, sizeof(munit_uint32_t));\\n    b += sizeof(munit_uint32_t);\\n  }\\n  if (bytes_remaining != 0) {\\n    rv = munit_rand_state_uint32(state);\\n    memcpy(b, &rv, bytes_remaining);\\n  }\\n}\\n\\nvoid\\nmunit_rand_memory(size_t size, munit_uint8_t data[MUNIT_ARRAY_PARAM(size)]) {\\n  munit_uint32_t old, state;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n    munit_rand_state_memory(&state, size, data);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_state_at_most(munit_uint32_t* state, munit_uint32_t salt, munit_uint32_t max) {\\n  /* We want (UINT32_MAX + 1) % max, which in unsigned arithmetic is the same\\n   * as (UINT32_MAX + 1 - max) % max = -max % max. We compute -max using not\\n   * to avoid compiler warnings.\\n   */\\n  const munit_uint32_t min = (~max + 1U) % max;\\n  munit_uint32_t x;\\n\\n  if (max == (~((munit_uint32_t) 0U)))\\n    return munit_rand_state_uint32(state) ^ salt;\\n\\n  max++;\\n\\n  do {\\n    x = munit_rand_state_uint32(state) ^ salt;\\n  } while (x < min);\\n\\n  return x % max;\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_at_most(munit_uint32_t salt, munit_uint32_t max) {\\n  munit_uint32_t old, state;\\n  munit_uint32_t retval;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n    retval = munit_rand_state_at_most(&state, salt, max);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return retval;\\n}\\n\\nint\\nmunit_rand_int_range(int min, int max) {\\n  munit_uint64_t range = (munit_uint64_t) max - (munit_uint64_t) min;\\n\\n  if (min > max)\\n    return munit_rand_int_range(max, min);\\n\\n  if (range > (~((munit_uint32_t) 0U)))\\n    range = (~((munit_uint32_t) 0U));\\n\\n  return min + munit_rand_at_most(0, (munit_uint32_t) range);\\n}\\n\\ndouble\\nmunit_rand_double(void) {\\n  munit_uint32_t old, state;\\n  double retval = 0.0;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n\\n    /* See http://mumble.net/~campbell/tmp/random_real.c for how to do\\n     * this right.  Patches welcome if you feel that this is too\\n     * biased. */\\n    retval = munit_rand_state_uint32(&state) / ((~((munit_uint32_t) 0U)) + 1.0);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return retval;\\n}\\n\\n/*** Test suite handling ***/\\n\\ntypedef struct {\\n  unsigned int successful;\\n  unsigned int skipped;\\n  unsigned int failed;\\n  unsigned int errored;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  munit_uint64_t cpu_clock;\\n  munit_uint64_t wall_clock;\\n#endif\\n} MunitReport;\\n\\ntypedef struct {\\n  const char* prefix;\\n  const MunitSuite* suite;\\n  const char** tests;\\n  munit_uint32_t seed;\\n  unsigned int iterations;\\n  MunitParameter* parameters;\\n  munit_bool single_parameter_mode;\\n  void* user_data;\\n  MunitReport report;\\n  munit_bool colorize;\\n  munit_bool fork;\\n  munit_bool show_stderr;\\n  munit_bool fatal_failures;\\n} MunitTestRunner;\\n\\nconst char*\\nmunit_parameters_get(const MunitParameter params[], const char* key) {\\n  const MunitParameter* param;\\n\\n  for (param = params ; param != NULL && param->name != NULL ; param++)\\n    if (strcmp(param->name, key) == 0)\\n      return param->value;\\n  return NULL;\\n}\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\nstatic void\\nmunit_print_time(FILE* fp, munit_uint64_t nanoseconds) {\\n  fprintf(fp, \\\"%\\\" MUNIT_TEST_TIME_FORMAT, ((double) nanoseconds) / ((double) PSNIP_CLOCK_NSEC_PER_SEC));\\n}\\n#endif\\n\\n/* Add a paramter to an array of parameters. */\\nstatic MunitResult\\nmunit_parameters_add(size_t* params_size, MunitParameter* params[MUNIT_ARRAY_PARAM(*params_size)], char* name, char* value) {\\n  *params = realloc(*params, sizeof(MunitParameter) * (*params_size + 2));\\n  if (*params == NULL)\\n    return MUNIT_ERROR;\\n\\n  (*params)[*params_size].name = name;\\n  (*params)[*params_size].value = value;\\n  (*params_size)++;\\n  (*params)[*params_size].name = NULL;\\n  (*params)[*params_size].value = NULL;\\n\\n  return MUNIT_OK;\\n}\\n\\n/* Concatenate two strings, but just return one of the components\\n * unaltered if the other is NULL or \\\"\\\". */\\nstatic char*\\nmunit_maybe_concat(size_t* len, char* prefix, char* suffix) {\\n  char* res;\\n  size_t res_l;\\n  const size_t prefix_l = prefix != NULL ? strlen(prefix) : 0;\\n  const size_t suffix_l = suffix != NULL ? strlen(suffix) : 0;\\n  if (prefix_l == 0 && suffix_l == 0) {\\n    res = NULL;\\n    res_l = 0;\\n  } else if (prefix_l == 0 && suffix_l != 0) {\\n    res = suffix;\\n    res_l = suffix_l;\\n  } else if (prefix_l != 0 && suffix_l == 0) {\\n    res = prefix;\\n    res_l = prefix_l;\\n  } else {\\n    res_l = prefix_l + suffix_l;\\n    res = malloc(res_l + 1);\\n    memcpy(res, prefix, prefix_l);\\n    memcpy(res + prefix_l, suffix, suffix_l);\\n    res[res_l] = 0;\\n  }\\n\\n  if (len != NULL)\\n    *len = res_l;\\n\\n  return res;\\n}\\n\\n/* Possbily free a string returned by munit_maybe_concat. */\\nstatic void\\nmunit_maybe_free_concat(char* s, const char* prefix, const char* suffix) {\\n  if (prefix != s && suffix != s)\\n    free(s);\\n}\\n\\n/* Cheap string hash function, just used to salt the PRNG. */\\nstatic munit_uint32_t\\nmunit_str_hash(const char* name) {\\n  const char *p;\\n  munit_uint32_t h = 5381U;\\n\\n  for (p = name; *p != '\\\\0'; p++)\\n    h = (h << 5) + h + *p;\\n\\n  return h;\\n}\\n\\nstatic void\\nmunit_splice(int from, int to) {\\n  munit_uint8_t buf[1024];\\n#if !defined(_WIN32)\\n  ssize_t len;\\n  ssize_t bytes_written;\\n  ssize_t write_res;\\n#else\\n  int len;\\n  int bytes_written;\\n  int write_res;\\n#endif\\n  do {\\n    len = read(from, buf, sizeof(buf));\\n    if (len > 0) {\\n      bytes_written = 0;\\n      do {\\n        write_res = write(to, buf + bytes_written, len - bytes_written);\\n        if (write_res < 0)\\n          break;\\n        bytes_written += write_res;\\n      } while (bytes_written < len);\\n    }\\n    else\\n      break;\\n  } while (1);\\n}\\n\\n/* This is the part that should be handled in the child process */\\nstatic MunitResult\\nmunit_test_runner_exec(MunitTestRunner* runner, const MunitTest* test, const MunitParameter params[], MunitReport* report) {\\n  unsigned int iterations = runner->iterations;\\n  MunitResult result = MUNIT_FAIL;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  struct PsnipClockTimespec wall_clock_begin = { 0, }, wall_clock_end = { 0, };\\n  struct PsnipClockTimespec cpu_clock_begin = { 0, }, cpu_clock_end = { 0, };\\n#endif\\n  unsigned int i = 0;\\n\\n  if ((test->options & MUNIT_TEST_OPTION_SINGLE_ITERATION) == MUNIT_TEST_OPTION_SINGLE_ITERATION)\\n    iterations = 1;\\n  else if (iterations == 0)\\n    iterations = runner->suite->iterations;\\n\\n  munit_rand_seed(runner->seed);\\n\\n  do {\\n    void* data = (test->setup == NULL) ? runner->user_data : test->setup(params, runner->user_data);\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wall_clock_begin);\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_CPU, &cpu_clock_begin);\\n#endif\\n\\n    result = test->test(params, data);\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wall_clock_end);\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_CPU, &cpu_clock_end);\\n#endif\\n\\n    if (test->tear_down != NULL)\\n      test->tear_down(data);\\n\\n    if (MUNIT_LIKELY(result == MUNIT_OK)) {\\n      report->successful++;\\n#if defined(MUNIT_ENABLE_TIMING)\\n      report->wall_clock += munit_clock_get_elapsed(&wall_clock_begin, &wall_clock_end);\\n      report->cpu_clock += munit_clock_get_elapsed(&cpu_clock_begin, &cpu_clock_end);\\n#endif\\n    } else {\\n      switch ((int) result) {\\n        case MUNIT_SKIP:\\n          report->skipped++;\\n          break;\\n        case MUNIT_FAIL:\\n          report->failed++;\\n          break;\\n        case MUNIT_ERROR:\\n          report->errored++;\\n          break;\\n        default:\\n          break;\\n      }\\n      break;\\n    }\\n  } while (++i < iterations);\\n\\n  return result;\\n}\\n\\n#if defined(MUNIT_EMOTICON)\\n#  define MUNIT_RESULT_STRING_OK    \\\":)\\\"\\n#  define MUNIT_RESULT_STRING_SKIP  \\\":|\\\"\\n#  define MUNIT_RESULT_STRING_FAIL  \\\":(\\\"\\n#  define MUNIT_RESULT_STRING_ERROR \\\":o\\\"\\n#  define MUNIT_RESULT_STRING_TODO  \\\":/\\\"\\n#else\\n#  define MUNIT_RESULT_STRING_OK    \\\"OK   \\\"\\n#  define MUNIT_RESULT_STRING_SKIP  \\\"SKIP \\\"\\n#  define MUNIT_RESULT_STRING_FAIL  \\\"FAIL \\\"\\n#  define MUNIT_RESULT_STRING_ERROR \\\"ERROR\\\"\\n#  define MUNIT_RESULT_STRING_TODO  \\\"TODO \\\"\\n#endif\\n\\nstatic void\\nmunit_test_runner_print_color(const MunitTestRunner* runner, const char* string, char color) {\\n  if (runner->colorize)\\n    fprintf(MUNIT_OUTPUT_FILE, \\\"\\\\x1b[3%cm%s\\\\x1b[39m\\\", color, string);\\n  else\\n    fputs(string, MUNIT_OUTPUT_FILE);\\n}\\n\\n#if !defined(MUNIT_NO_BUFFER)\\nstatic int\\nmunit_replace_stderr(FILE* stderr_buf) {\\n  if (stderr_buf != NULL) {\\n    const int orig_stderr = dup(STDERR_FILENO);\\n\\n    int errfd = fileno(stderr_buf);\\n    if (MUNIT_UNLIKELY(errfd == -1)) {\\n      exit(EXIT_FAILURE);\\n    }\\n\\n    dup2(errfd, STDERR_FILENO);\\n\\n    return orig_stderr;\\n  }\\n\\n  return -1;\\n}\\n\\nstatic void\\nmunit_restore_stderr(int orig_stderr) {\\n  if (orig_stderr != -1) {\\n    dup2(orig_stderr, STDERR_FILENO);\\n    close(orig_stderr);\\n  }\\n}\\n#endif /* !defined(MUNIT_NO_BUFFER) */\\n\\n/* Run a test with the specified parameters. */\\nstatic void\\nmunit_test_runner_run_test_with_params(MunitTestRunner* runner, const MunitTest* test, const MunitParameter params[]) {\\n  MunitResult result = MUNIT_OK;\\n  MunitReport report = {\\n    0, 0, 0, 0,\\n#if defined(MUNIT_ENABLE_TIMING)\\n    0, 0\\n#endif\\n  };\\n  unsigned int output_l;\\n  munit_bool first;\\n  const MunitParameter* param;\\n  FILE* stderr_buf;\\n#if !defined(MUNIT_NO_FORK)\\n  int pipefd[2];\\n  pid_t fork_pid;\\n  int orig_stderr;\\n  ssize_t bytes_written = 0;\\n  ssize_t write_res;\\n  ssize_t bytes_read = 0;\\n  ssize_t read_res;\\n  int status = 0;\\n  pid_t changed_pid;\\n#endif\\n\\n  if (params != NULL) {\\n    output_l = 2;\\n    fputs(\\\"  \\\", MUNIT_OUTPUT_FILE);\\n    first = 1;\\n    for (param = params ; param != NULL && param->name != NULL ; param++) {\\n      if (!first) {\\n        fputs(\\\", \\\", MUNIT_OUTPUT_FILE);\\n        output_l += 2;\\n      } else {\\n        first = 0;\\n      }\\n\\n      output_l += fprintf(MUNIT_OUTPUT_FILE, \\\"%s=%s\\\", param->name, param->value);\\n    }\\n    while (output_l++ < MUNIT_TEST_NAME_LEN) {\\n      fputc(' ', MUNIT_OUTPUT_FILE);\\n    }\\n  }\\n\\n  fflush(MUNIT_OUTPUT_FILE);\\n\\n  stderr_buf = NULL;\\n#if !defined(_WIN32) || defined(__MINGW32__)\\n  stderr_buf = tmpfile();\\n#else\\n  tmpfile_s(&stderr_buf);\\n#endif\\n  if (stderr_buf == NULL) {\\n    munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to create buffer for stderr\\\");\\n    result = MUNIT_ERROR;\\n    goto print_result;\\n  }\\n\\n#if !defined(MUNIT_NO_FORK)\\n  if (runner->fork) {\\n    pipefd[0] = -1;\\n    pipefd[1] = -1;\\n    if (pipe(pipefd) != 0) {\\n      munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to create pipe\\\");\\n      result = MUNIT_ERROR;\\n      goto print_result;\\n    }\\n\\n    fork_pid = fork();\\n    if (fork_pid == 0) {\\n      close(pipefd[0]);\\n\\n      orig_stderr = munit_replace_stderr(stderr_buf);\\n      munit_test_runner_exec(runner, test, params, &report);\\n\\n      /* Note that we don't restore stderr.  This is so we can buffer\\n       * things written to stderr later on (such as by\\n       * asan/tsan/ubsan, valgrind, etc.) */\\n      close(orig_stderr);\\n\\n      do {\\n        write_res = write(pipefd[1], ((munit_uint8_t*) (&report)) + bytes_written, sizeof(report) - bytes_written);\\n        if (write_res < 0) {\\n          if (stderr_buf != NULL) {\\n            munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to write to pipe\\\");\\n          }\\n          exit(EXIT_FAILURE);\\n        }\\n        bytes_written += write_res;\\n      } while ((size_t) bytes_written < sizeof(report));\\n\\n      if (stderr_buf != NULL)\\n        fclose(stderr_buf);\\n      close(pipefd[1]);\\n\\n      exit(EXIT_SUCCESS);\\n    } else if (fork_pid == -1) {\\n      close(pipefd[0]);\\n      close(pipefd[1]);\\n      if (stderr_buf != NULL) {\\n        munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to fork\\\");\\n      }\\n      report.errored++;\\n      result = MUNIT_ERROR;\\n    } else {\\n      close(pipefd[1]);\\n      do {\\n        read_res = read(pipefd[0], ((munit_uint8_t*) (&report)) + bytes_read, sizeof(report) - bytes_read);\\n        if (read_res < 1)\\n          break;\\n        bytes_read += read_res;\\n      } while (bytes_read < (ssize_t) sizeof(report));\\n\\n      changed_pid = waitpid(fork_pid, &status, 0);\\n\\n      if (MUNIT_LIKELY(changed_pid == fork_pid) && MUNIT_LIKELY(WIFEXITED(status))) {\\n        if (bytes_read != sizeof(report)) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child exited unexpectedly with status %d\\\", WEXITSTATUS(status));\\n          report.errored++;\\n        } else if (WEXITSTATUS(status) != EXIT_SUCCESS) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child exited with status %d\\\", WEXITSTATUS(status));\\n          report.errored++;\\n        }\\n      } else {\\n        if (WIFSIGNALED(status)) {\\n#if defined(_XOPEN_VERSION) && (_XOPEN_VERSION >= 700)\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child killed by signal %d (%s)\\\", WTERMSIG(status), strsignal(WTERMSIG(status)));\\n#else\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child killed by signal %d\\\", WTERMSIG(status));\\n#endif\\n        } else if (WIFSTOPPED(status)) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child stopped by signal %d\\\", WSTOPSIG(status));\\n        }\\n        report.errored++;\\n      }\\n\\n      close(pipefd[0]);\\n      waitpid(fork_pid, NULL, 0);\\n    }\\n  } else\\n#endif\\n  {\\n#if !defined(MUNIT_NO_BUFFER)\\n    const volatile int orig_stderr = munit_replace_stderr(stderr_buf);\\n#endif\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\n    if (MUNIT_UNLIKELY(setjmp(munit_error_jmp_buf) != 0)) {\\n      result = MUNIT_FAIL;\\n      report.failed++;\\n    } else {\\n      munit_error_jmp_buf_valid = 1;\\n      result = munit_test_runner_exec(runner, test, params, &report);\\n    }\\n#else\\n    result = munit_test_runner_exec(runner, test, params, &report);\\n#endif\\n\\n#if !defined(MUNIT_NO_BUFFER)\\n    munit_restore_stderr(orig_stderr);\\n#endif\\n\\n    /* Here just so that the label is used on Windows and we don't get\\n     * a warning */\\n    goto print_result;\\n  }\\n\\n print_result:\\n\\n  fputs(\\\"[ \\\", MUNIT_OUTPUT_FILE);\\n  if ((test->options & MUNIT_TEST_OPTION_TODO) == MUNIT_TEST_OPTION_TODO) {\\n    if (report.failed != 0 || report.errored != 0 || report.skipped != 0) {\\n      munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_TODO, '3');\\n      result = MUNIT_OK;\\n    } else {\\n      munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_ERROR, '1');\\n      if (MUNIT_LIKELY(stderr_buf != NULL))\\n        munit_log_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"Test marked TODO, but was successful.\\\");\\n      runner->report.failed++;\\n      result = MUNIT_ERROR;\\n    }\\n  } else if (report.failed > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_FAIL, '1');\\n    runner->report.failed++;\\n    result = MUNIT_FAIL;\\n  } else if (report.errored > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_ERROR, '1');\\n    runner->report.errored++;\\n    result = MUNIT_ERROR;\\n  } else if (report.skipped > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_SKIP, '3');\\n    runner->report.skipped++;\\n    result = MUNIT_SKIP;\\n  } else if (report.successful > 1) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_OK, '2');\\n#if defined(MUNIT_ENABLE_TIMING)\\n    fputs(\\\" ] [ \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock / report.successful);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock / report.successful);\\n    fprintf(MUNIT_OUTPUT_FILE, \\\" CPU ]\\\\n  %-\\\" MUNIT_XSTRINGIFY(MUNIT_TEST_NAME_LEN) \\\"s Total: [ \\\", \\\"\\\");\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock);\\n    fputs(\\\" CPU\\\", MUNIT_OUTPUT_FILE);\\n#endif\\n    runner->report.successful++;\\n    result = MUNIT_OK;\\n  } else if (report.successful > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_OK, '2');\\n#if defined(MUNIT_ENABLE_TIMING)\\n    fputs(\\\" ] [ \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock);\\n    fputs(\\\" CPU\\\", MUNIT_OUTPUT_FILE);\\n#endif\\n    runner->report.successful++;\\n    result = MUNIT_OK;\\n  }\\n  fputs(\\\" ]\\\\n\\\", MUNIT_OUTPUT_FILE);\\n\\n  if (stderr_buf != NULL) {\\n    if (result == MUNIT_FAIL || result == MUNIT_ERROR || runner->show_stderr) {\\n      fflush(MUNIT_OUTPUT_FILE);\\n\\n      rewind(stderr_buf);\\n      munit_splice(fileno(stderr_buf), STDERR_FILENO);\\n\\n      fflush(stderr);\\n    }\\n\\n    fclose(stderr_buf);\\n  }\\n}\\n\\nstatic void\\nmunit_test_runner_run_test_wild(MunitTestRunner* runner,\\n                                const MunitTest* test,\\n                                const char* test_name,\\n                                MunitParameter* params,\\n                                MunitParameter* p) {\\n  const MunitParameterEnum* pe;\\n  char** values;\\n  MunitParameter* next;\\n\\n  for (pe = test->parameters ; pe != NULL && pe->name != NULL ; pe++) {\\n    if (p->name == pe->name)\\n      break;\\n  }\\n\\n  if (pe == NULL)\\n    return;\\n\\n  for (values = pe->values ; *values != NULL ; values++) {\\n    next = p + 1;\\n    p->value = *values;\\n    if (next->name == NULL) {\\n      munit_test_runner_run_test_with_params(runner, test, params);\\n    } else {\\n      munit_test_runner_run_test_wild(runner, test, test_name, params, next);\\n    }\\n    if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n      break;\\n  }\\n}\\n\\n/* Run a single test, with every combination of parameters\\n * requested. */\\nstatic void\\nmunit_test_runner_run_test(MunitTestRunner* runner,\\n                           const MunitTest* test,\\n                           const char* prefix) {\\n  char* test_name = munit_maybe_concat(NULL, (char*) prefix, (char*) test->name);\\n  /* The array of parameters to pass to\\n   * munit_test_runner_run_test_with_params */\\n  MunitParameter* params = NULL;\\n  size_t params_l = 0;\\n  /* Wildcard parameters are parameters which have possible values\\n   * specified in the test, but no specific value was passed to the\\n   * CLI.  That means we want to run the test once for every\\n   * possible combination of parameter values or, if --single was\\n   * passed to the CLI, a single time with a random set of\\n   * parameters. */\\n  MunitParameter* wild_params = NULL;\\n  size_t wild_params_l = 0;\\n  const MunitParameterEnum* pe;\\n  const MunitParameter* cli_p;\\n  munit_bool filled;\\n  unsigned int possible;\\n  char** vals;\\n  size_t first_wild;\\n  const MunitParameter* wp;\\n  int pidx;\\n\\n  munit_rand_seed(runner->seed);\\n\\n  fprintf(MUNIT_OUTPUT_FILE, \\\"%-\\\" MUNIT_XSTRINGIFY(MUNIT_TEST_NAME_LEN) \\\"s\\\", test_name);\\n\\n  if (test->parameters == NULL) {\\n    /* No parameters.  Simple, nice. */\\n    munit_test_runner_run_test_with_params(runner, test, NULL);\\n  } else {\\n    fputc('\\\\n', MUNIT_OUTPUT_FILE);\\n\\n    for (pe = test->parameters ; pe != NULL && pe->name != NULL ; pe++) {\\n      /* Did we received a value for this parameter from the CLI? */\\n      filled = 0;\\n      for (cli_p = runner->parameters ; cli_p != NULL && cli_p->name != NULL ; cli_p++) {\\n        if (strcmp(cli_p->name, pe->name) == 0) {\\n          if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, cli_p->value) != MUNIT_OK))\\n            goto cleanup;\\n          filled = 1;\\n          break;\\n        }\\n      }\\n      if (filled)\\n        continue;\\n\\n      /* Nothing from CLI, is the enum NULL/empty?  We're not a\\n       * fuzzer\\u2026 */\\n      if (pe->values == NULL || pe->values[0] == NULL)\\n        continue;\\n\\n      /* If --single was passed to the CLI, choose a value from the\\n       * list of possibilities randomly. */\\n      if (runner->single_parameter_mode) {\\n        possible = 0;\\n        for (vals = pe->values ; *vals != NULL ; vals++)\\n          possible++;\\n        /* We want the tests to be reproducible, even if you're only\\n         * running a single test, but we don't want every test with\\n         * the same number of parameters to choose the same parameter\\n         * number, so use the test name as a primitive salt. */\\n        pidx = munit_rand_at_most(munit_str_hash(test_name), possible - 1);\\n        if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, pe->values[pidx]) != MUNIT_OK))\\n          goto cleanup;\\n      } else {\\n        /* We want to try every permutation.  Put in a placeholder\\n         * entry, we'll iterate through them later. */\\n        if (MUNIT_UNLIKELY(munit_parameters_add(&wild_params_l, &wild_params, pe->name, NULL) != MUNIT_OK))\\n          goto cleanup;\\n      }\\n    }\\n\\n    if (wild_params_l != 0) {\\n      first_wild = params_l;\\n      for (wp = wild_params ; wp != NULL && wp->name != NULL ; wp++) {\\n        for (pe = test->parameters ; pe != NULL && pe->name != NULL && pe->values != NULL ; pe++) {\\n          if (strcmp(wp->name, pe->name) == 0) {\\n            if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, pe->values[0]) != MUNIT_OK))\\n              goto cleanup;\\n          }\\n        }\\n      }\\n\\n      munit_test_runner_run_test_wild(runner, test, test_name, params, params + first_wild);\\n    } else {\\n      munit_test_runner_run_test_with_params(runner, test, params);\\n    }\\n\\n  cleanup:\\n    free(params);\\n    free(wild_params);\\n  }\\n\\n  munit_maybe_free_concat(test_name, prefix, test->name);\\n}\\n\\n/* Recurse through the suite and run all the tests.  If a list of\\n * tests to run was provied on the command line, run only those\\n * tests.  */\\nstatic void\\nmunit_test_runner_run_suite(MunitTestRunner* runner,\\n                            const MunitSuite* suite,\\n                            const char* prefix) {\\n  size_t pre_l;\\n  char* pre = munit_maybe_concat(&pre_l, (char*) prefix, (char*) suite->prefix);\\n  const MunitTest* test;\\n  const char** test_name;\\n  const MunitSuite* child_suite;\\n\\n  /* Run the tests. */\\n  for (test = suite->tests ; test != NULL && test->test != NULL ; test++) {\\n    if (runner->tests != NULL) { /* Specific tests were requested on the CLI */\\n      for (test_name = runner->tests ; test_name != NULL && *test_name != NULL ; test_name++) {\\n        if ((pre_l == 0 || strncmp(pre, *test_name, pre_l) == 0) &&\\n            strncmp(test->name, *test_name + pre_l, strlen(*test_name + pre_l)) == 0) {\\n          munit_test_runner_run_test(runner, test, pre);\\n          if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n            goto cleanup;\\n        }\\n      }\\n    } else { /* Run all tests */\\n      munit_test_runner_run_test(runner, test, pre);\\n    }\\n  }\\n\\n  if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n    goto cleanup;\\n\\n  /* Run any child suites. */\\n  for (child_suite = suite->suites ; child_suite != NULL && child_suite->prefix != NULL ; child_suite++) {\\n    munit_test_runner_run_suite(runner, child_suite, pre);\\n  }\\n\\n cleanup:\\n\\n  munit_maybe_free_concat(pre, prefix, suite->prefix);\\n}\\n\\nstatic void\\nmunit_test_runner_run(MunitTestRunner* runner) {\\n  munit_test_runner_run_suite(runner, runner->suite, NULL);\\n}\\n\\nstatic void\\nmunit_print_help(int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)], void* user_data, const MunitArgument arguments[]) {\\n  const MunitArgument* arg;\\n  (void) argc;\\n\\n  printf(\\\"USAGE: %s [OPTIONS...] [TEST...]\\\\n\\\\n\\\", argv[0]);\\n  puts(\\\" --seed SEED\\\\n\\\"\\n       \\\"           Value used to seed the PRNG.  Must be a 32-bit integer in decimal\\\\n\\\"\\n       \\\"           notation with no separators (commas, decimals, spaces, etc.), or\\\\n\\\"\\n       \\\"           hexidecimal prefixed by \\\\\\\"0x\\\\\\\".\\\\n\\\"\\n       \\\" --iterations N\\\\n\\\"\\n       \\\"           Run each test N times.  0 means the default number.\\\\n\\\"\\n       \\\" --param name value\\\\n\\\"\\n       \\\"           A parameter key/value pair which will be passed to any test with\\\\n\\\"\\n       \\\"           takes a parameter of that name.  If not provided, the test will be\\\\n\\\"\\n       \\\"           run once for each possible parameter value.\\\\n\\\"\\n       \\\" --list    Write a list of all available tests.\\\\n\\\"\\n       \\\" --list-params\\\\n\\\"\\n       \\\"           Write a list of all available tests and their possible parameters.\\\\n\\\"\\n       \\\" --single  Run each parameterized test in a single configuration instead of\\\\n\\\"\\n       \\\"           every possible combination\\\\n\\\"\\n       \\\" --log-visible debug|info|warning|error\\\\n\\\"\\n       \\\" --log-fatal debug|info|warning|error\\\\n\\\"\\n       \\\"           Set the level at which messages of different severities are visible,\\\\n\\\"\\n       \\\"           or cause the test to terminate.\\\\n\\\"\\n#if !defined(MUNIT_NO_FORK)\\n       \\\" --no-fork Do not execute tests in a child process.  If this option is supplied\\\\n\\\"\\n       \\\"           and a test crashes (including by failing an assertion), no further\\\\n\\\"\\n       \\\"           tests will be performed.\\\\n\\\"\\n#endif\\n       \\\" --fatal-failures\\\\n\\\"\\n       \\\"           Stop executing tests as soon as a failure is found.\\\\n\\\"\\n       \\\" --show-stderr\\\\n\\\"\\n       \\\"           Show data written to stderr by the tests, even if the test succeeds.\\\\n\\\"\\n       \\\" --color auto|always|never\\\\n\\\"\\n       \\\"           Colorize (or don't) the output.\\\\n\\\"\\n     /* 12345678901234567890123456789012345678901234567890123456789012345678901234567890 */\\n       \\\" --help    Print this help message and exit.\\\\n\\\");\\n#if defined(MUNIT_NL_LANGINFO)\\n  setlocale(LC_ALL, \\\"\\\");\\n  fputs((strcasecmp(\\\"UTF-8\\\", nl_langinfo(CODESET)) == 0) ? \\\"\\u00b5nit\\\" : \\\"munit\\\", stdout);\\n#else\\n  puts(\\\"munit\\\");\\n#endif\\n  printf(\\\" %d.%d.%d\\\\n\\\"\\n         \\\"Full documentation at: https://nemequ.github.io/munit/\\\\n\\\",\\n         (MUNIT_CURRENT_VERSION >> 16) & 0xff,\\n         (MUNIT_CURRENT_VERSION >> 8) & 0xff,\\n         (MUNIT_CURRENT_VERSION >> 0) & 0xff);\\n  for (arg = arguments ; arg != NULL && arg->name != NULL ; arg++)\\n    arg->write_help(arg, user_data);\\n}\\n\\nstatic const MunitArgument*\\nmunit_arguments_find(const MunitArgument arguments[], const char* name) {\\n  const MunitArgument* arg;\\n\\n  for (arg = arguments ; arg != NULL && arg->name != NULL ; arg++)\\n    if (strcmp(arg->name, name) == 0)\\n      return arg;\\n\\n  return NULL;\\n}\\n\\nstatic void\\nmunit_suite_list_tests(const MunitSuite* suite, munit_bool show_params, const char* prefix) {\\n  size_t pre_l;\\n  char* pre = munit_maybe_concat(&pre_l, (char*) prefix, (char*) suite->prefix);\\n  const MunitTest* test;\\n  const MunitParameterEnum* params;\\n  munit_bool first;\\n  char** val;\\n  const MunitSuite* child_suite;\\n\\n  for (test = suite->tests ;\\n       test != NULL && test->name != NULL ;\\n       test++) {\\n    if (pre != NULL)\\n      fputs(pre, stdout);\\n    puts(test->name);\\n\\n    if (show_params) {\\n      for (params = test->parameters ;\\n           params != NULL && params->name != NULL ;\\n           params++) {\\n        fprintf(stdout, \\\" - %s: \\\", params->name);\\n        if (params->values == NULL) {\\n          puts(\\\"Any\\\");\\n        } else {\\n          first = 1;\\n          for (val = params->values ;\\n               *val != NULL ;\\n               val++ ) {\\n            if(!first) {\\n              fputs(\\\", \\\", stdout);\\n            } else {\\n              first = 0;\\n            }\\n            fputs(*val, stdout);\\n          }\\n          putc('\\\\n', stdout);\\n        }\\n      }\\n    }\\n  }\\n\\n  for (child_suite = suite->suites ; child_suite != NULL && child_suite->prefix != NULL ; child_suite++) {\\n    munit_suite_list_tests(child_suite, show_params, pre);\\n  }\\n\\n  munit_maybe_free_concat(pre, prefix, suite->prefix);\\n}\\n\\nstatic munit_bool\\nmunit_stream_supports_ansi(FILE *stream) {\\n#if !defined(_WIN32)\\n  return isatty(fileno(stream));\\n#else\\n\\n#if !defined(__MINGW32__)\\n  size_t ansicon_size = 0;\\n#endif\\n\\n  if (isatty(fileno(stream))) {\\n#if !defined(__MINGW32__)\\n    getenv_s(&ansicon_size, NULL, 0, \\\"ANSICON\\\");\\n    return ansicon_size != 0;\\n#else\\n    return getenv(\\\"ANSICON\\\") != NULL;\\n#endif\\n  }\\n  return 0;\\n#endif\\n}\\n\\nint\\nmunit_suite_main_custom(const MunitSuite* suite, void* user_data,\\n                        int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)],\\n                        const MunitArgument arguments[]) {\\n  int result = EXIT_FAILURE;\\n  MunitTestRunner runner;\\n  size_t parameters_size = 0;\\n  size_t tests_size = 0;\\n  int arg;\\n\\n  char* envptr;\\n  unsigned long ts;\\n  char* endptr;\\n  unsigned long long iterations;\\n  MunitLogLevel level;\\n  const MunitArgument* argument;\\n  const char** runner_tests;\\n  unsigned int tests_run;\\n  unsigned int tests_total;\\n\\n  runner.prefix = NULL;\\n  runner.suite = NULL;\\n  runner.tests = NULL;\\n  runner.seed = 0;\\n  runner.iterations = 0;\\n  runner.parameters = NULL;\\n  runner.single_parameter_mode = 0;\\n  runner.user_data = NULL;\\n\\n  runner.report.successful = 0;\\n  runner.report.skipped = 0;\\n  runner.report.failed = 0;\\n  runner.report.errored = 0;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  runner.report.cpu_clock = 0;\\n  runner.report.wall_clock = 0;\\n#endif\\n\\n  runner.colorize = 0;\\n#if !defined(_WIN32)\\n  runner.fork = 1;\\n#else\\n  runner.fork = 0;\\n#endif\\n  runner.show_stderr = 0;\\n  runner.fatal_failures = 0;\\n  runner.suite = suite;\\n  runner.user_data = user_data;\\n  runner.seed = munit_rand_generate_seed();\\n  runner.colorize = munit_stream_supports_ansi(MUNIT_OUTPUT_FILE);\\n\\n  for (arg = 1 ; arg < argc ; arg++) {\\n    if (strncmp(\\\"--\\\", argv[arg], 2) == 0) {\\n      if (strcmp(\\\"seed\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        envptr = argv[arg + 1];\\n        ts = strtoul(argv[arg + 1], &envptr, 0);\\n        if (*envptr != '\\\\0' || ts > (~((munit_uint32_t) 0U))) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n        runner.seed = (munit_uint32_t) ts;\\n\\n        arg++;\\n      } else if (strcmp(\\\"iterations\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        endptr = argv[arg + 1];\\n        iterations = strtoul(argv[arg + 1], &endptr, 0);\\n        if (*endptr != '\\\\0' || iterations > UINT_MAX) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        runner.iterations = (unsigned int) iterations;\\n\\n        arg++;\\n      } else if (strcmp(\\\"param\\\", argv[arg] + 2) == 0) {\\n        if (arg + 2 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires two arguments\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        runner.parameters = realloc(runner.parameters, sizeof(MunitParameter) * (parameters_size + 2));\\n        if (runner.parameters == NULL) {\\n          munit_log_internal(MUNIT_LOG_ERROR, stderr, \\\"failed to allocate memory\\\");\\n          goto cleanup;\\n        }\\n        runner.parameters[parameters_size].name = (char*) argv[arg + 1];\\n        runner.parameters[parameters_size].value = (char*) argv[arg + 2];\\n        parameters_size++;\\n        runner.parameters[parameters_size].name = NULL;\\n        runner.parameters[parameters_size].value = NULL;\\n        arg += 2;\\n      } else if (strcmp(\\\"color\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(argv[arg + 1], \\\"always\\\") == 0)\\n          runner.colorize = 1;\\n        else if (strcmp(argv[arg + 1], \\\"never\\\") == 0)\\n          runner.colorize = 0;\\n        else if (strcmp(argv[arg + 1], \\\"auto\\\") == 0)\\n          runner.colorize = munit_stream_supports_ansi(MUNIT_OUTPUT_FILE);\\n        else {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        arg++;\\n      } else if (strcmp(\\\"help\\\", argv[arg] + 2) == 0) {\\n        munit_print_help(argc, argv, user_data, arguments);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else if (strcmp(\\\"single\\\", argv[arg] + 2) == 0) {\\n        runner.single_parameter_mode = 1;\\n      } else if (strcmp(\\\"show-stderr\\\", argv[arg] + 2) == 0) {\\n        runner.show_stderr = 1;\\n#if !defined(_WIN32)\\n      } else if (strcmp(\\\"no-fork\\\", argv[arg] + 2) == 0) {\\n        runner.fork = 0;\\n#endif\\n      } else if (strcmp(\\\"fatal-failures\\\", argv[arg] + 2) == 0) {\\n        runner.fatal_failures = 1;\\n      } else if (strcmp(\\\"log-visible\\\", argv[arg] + 2) == 0 ||\\n                 strcmp(\\\"log-fatal\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(argv[arg + 1], \\\"debug\\\") == 0)\\n          level = MUNIT_LOG_DEBUG;\\n        else if (strcmp(argv[arg + 1], \\\"info\\\") == 0)\\n          level = MUNIT_LOG_INFO;\\n        else if (strcmp(argv[arg + 1], \\\"warning\\\") == 0)\\n          level = MUNIT_LOG_WARNING;\\n        else if (strcmp(argv[arg + 1], \\\"error\\\") == 0)\\n          level = MUNIT_LOG_ERROR;\\n        else {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(\\\"log-visible\\\", argv[arg] + 2) == 0)\\n          munit_log_level_visible = level;\\n        else\\n          munit_log_level_fatal = level;\\n\\n        arg++;\\n      } else if (strcmp(\\\"list\\\", argv[arg] + 2) == 0) {\\n        munit_suite_list_tests(suite, 0, NULL);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else if (strcmp(\\\"list-params\\\", argv[arg] + 2) == 0) {\\n        munit_suite_list_tests(suite, 1, NULL);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else {\\n        argument = munit_arguments_find(arguments, argv[arg] + 2);\\n        if (argument == NULL) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"unknown argument ('%s')\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (!argument->parse_argument(suite, user_data, &arg, argc, argv))\\n          goto cleanup;\\n      }\\n    } else {\\n      runner_tests = realloc((void*) runner.tests, sizeof(char*) * (tests_size + 2));\\n      if (runner_tests == NULL) {\\n        munit_log_internal(MUNIT_LOG_ERROR, stderr, \\\"failed to allocate memory\\\");\\n        goto cleanup;\\n      }\\n      runner.tests = runner_tests;\\n      runner.tests[tests_size++] = argv[arg];\\n      runner.tests[tests_size] = NULL;\\n    }\\n  }\\n\\n  fflush(stderr);\\n  fprintf(MUNIT_OUTPUT_FILE, \\\"Running test suite with seed 0x%08\\\" PRIx32 \\\"...\\\\n\\\", runner.seed);\\n\\n  munit_test_runner_run(&runner);\\n\\n  tests_run = runner.report.successful + runner.report.failed + runner.report.errored;\\n  tests_total = tests_run + runner.report.skipped;\\n  if (tests_run == 0) {\\n    fprintf(stderr, \\\"No tests run, %d (100%%) skipped.\\\\n\\\", runner.report.skipped);\\n  } else {\\n    fprintf(MUNIT_OUTPUT_FILE, \\\"%d of %d (%0.0f%%) tests successful, %d (%0.0f%%) test skipped.\\\\n\\\",\\n            runner.report.successful, tests_run,\\n            (((double) runner.report.successful) / ((double) tests_run)) * 100.0,\\n            runner.report.skipped,\\n            (((double) runner.report.skipped) / ((double) tests_total)) * 100.0);\\n  }\\n\\n  if (runner.report.failed == 0 && runner.report.errored == 0) {\\n    result = EXIT_SUCCESS;\\n  }\\n\\n cleanup:\\n  free(runner.parameters);\\n  free((void*) runner.tests);\\n\\n  return result;\\n}\\n\\nint\\nmunit_suite_main(const MunitSuite* suite, void* user_data,\\n                 int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)]) {\\n  return munit_suite_main_custom(suite, user_data, argc, argv, NULL);\\n}\\n\", \"embeddings\": [-0.02594861388206482, 0.07000009715557098, -0.00989580899477005, 0.028883393853902817, 0.16601696610450745, -0.20992150902748108, 0.04424680769443512, 0.24179187417030334, 0.02111639827489853, -0.059468552470207214, -0.0644422397017479, -0.05334005504846573, -0.05601748824119568, 0.04056316241621971, 0.06510000675916672, 0.0006483197212219238, 0.037188440561294556, 0.024794287979602814, 0.08126384019851685, -0.1455894112586975, -0.10581839084625244, 0.08300134539604187, 0.14323684573173523, 0.1793336272239685, 0.2152457982301712, -0.02924736961722374, 0.21160176396369934, 0.12935715913772583, 0.1994577795267105, -0.16979773342609406, 0.06705436110496521, -0.013156749308109283, 0.07962952554225922, -0.1466875970363617, 0.0031836479902267456, 0.041636109352111816, 0.03797660768032074, -0.0052362531423568726, 0.05114772543311119, 0.05992284044623375, -0.14738327264785767, -0.11738239228725433, 0.10788717120885849, 0.17027588188648224, 0.0561777800321579, -0.0052072033286094666, -0.025566987693309784, 0.12784744799137115, -0.16600866615772247, 0.0016574002802371979, 0.10803990066051483, 0.0437348335981369, -0.10516799241304398, -0.03247017413377762, -0.1652291715145111, -0.10167389363050461, -0.010347187519073486, 0.317216694355011, 0.07487666606903076, -0.0035284534096717834, -0.06407336890697479, 0.026839468628168106, -0.11842100322246552, 0.05800418555736542, 0.11376946419477463, 0.04634939506649971, -0.07666248083114624, -0.07520218938589096, -0.08636681735515594, -0.017158400267362595, 0.11912670731544495, 0.030168110504746437, 0.06264187395572662, -0.2226230800151825, -0.036808647215366364, 0.005378890782594681, 0.15803593397140503, 0.5929312705993652, -0.10686902701854706, 0.14967131614685059, 0.21992263197898865, -0.09801661968231201, -0.05572499334812164, 0.19764462113380432, 0.0010668858885765076, -0.014250237494707108, -0.09364265948534012, 0.024710409343242645, 0.0850745290517807, 0.14680248498916626, 0.03414382040500641, 0.03653743118047714, -0.0710546150803566, -0.030488278716802597, -0.010365258902311325, -0.07320544123649597, 0.02460164949297905, -0.39285463094711304, 0.04463306814432144, 0.20026282966136932, -0.0634230524301529, -0.052987951785326004, -0.22314852476119995, -0.0015746131539344788, -0.00034870952367782593, -0.022782396525144577, 0.06170371547341347, 0.021121226251125336, 0.0373423770070076, -0.048871077597141266, 0.10410620272159576, 0.11219030618667603, 0.029863258823752403, 0.05346199870109558, 0.05970605090260506, -0.10685903578996658, 0.06484334170818329, -0.010207422077655792, 0.04575609043240547, -0.11234239488840103, 0.1418205052614212, 0.023826345801353455, -0.08836493641138077, -0.048728980123996735, 0.054395344108343124, 0.052110910415649414, 0.06556922197341919, -0.16231486201286316, 0.14185380935668945, 0.16600146889686584, 0.04463157057762146, -0.11768383532762527, 0.010363344103097916, 0.024204909801483154, 0.18816277384757996, 0.054237205535173416, 0.05187895521521568, 0.020253926515579224, -0.03151913732290268, 0.021794691681861877, -0.0885101929306984, 0.04735342413187027, 0.30963200330734253, -0.00922435149550438, 0.1880146563053131, -0.10971084237098694, 0.1128527894616127, 0.11935743689537048, -0.27952268719673157, -0.19272275269031525, 0.06967811286449432, -0.12681728601455688, 0.03353722393512726, 0.03542572259902954, -0.1712879240512848, 0.7103771567344666, 0.09495119750499725, -0.12720689177513123, -0.09242859482765198, 0.01963159441947937, 0.06003430485725403, -0.22107508778572083, -0.02942690998315811, 0.11939245462417603, 0.03092961758375168, 0.11730347573757172, 0.05397331714630127, 0.1456441432237625, 0.08568262308835983, 0.04766789451241493, 0.05386491119861603, -0.07887580990791321, -0.059596531093120575, 0.19138936698436737, -0.04288315773010254, -0.06338147073984146, -0.20471179485321045, 0.034654706716537476, -0.037392303347587585, 0.0916307121515274, -0.07682274281978607, 0.021015699952840805, -0.17515993118286133, -0.04877878725528717, 0.024468693882226944, 0.057396501302719116, 0.08655013144016266, -0.12167762219905853, 0.10514792054891586, 0.09331852197647095, -0.07945890724658966, 0.10365507751703262, 0.08072036504745483, -0.00022777915000915527, -0.08280938118696213, 0.11228416860103607, -0.05964045971632004, -0.06382713466882706, 0.10890812426805496, -0.04301465302705765, -0.01066337339580059, -0.08487922698259354, 0.13474884629249573, -0.07728813588619232, 0.05205490067601204, 0.11685752868652344, -0.10071337968111038, 0.0508195124566555, 0.011455263942480087, -0.0810750275850296, -0.03250756487250328, 0.23305121064186096, 0.07986472547054291, 0.0019250614568591118, -0.07829773426055908, -0.10553789883852005, -0.05066097900271416, 0.011983167380094528, 0.026789173483848572, -0.16636371612548828, 0.1416827142238617, 0.18620747327804565, -0.06462383270263672, -0.056724756956100464, 0.007742498070001602, 0.2176927924156189, 0.2638205289840698, 0.01979782059788704, 0.05200514942407608, 0.055967483669519424, 0.21508994698524475, 0.09505663812160492, -0.16119998693466187, 0.10498704016208649, 0.06001155078411102, -0.1537153273820877, -0.032565586268901825, 0.02685832604765892, 0.02008800208568573, -0.018864475190639496, -0.05660518631339073, 0.04429405927658081, 0.0960887223482132, 0.26631855964660645, 0.05529855936765671, -0.014993079006671906, -0.11003747582435608, -0.003386114723980427, -0.07387980073690414, 0.06645406037569046, -0.059164486825466156, -0.14547023177146912, 0.0678330808877945, -0.0606912262737751, -0.08998739719390869, -0.0196574404835701, -0.059426188468933105, 0.08725082874298096, 0.10514119267463684, 0.03674808889627457, -0.06994389742612839, -0.07084258645772934, -0.0066172778606414795, -0.01390228420495987, -0.05117156356573105, -0.31557902693748474, 0.008570119738578796, 0.0290147103369236, 0.04862254485487938, 0.01457173004746437, 0.011974133551120758, -0.050734274089336395, 0.223575621843338, 0.16909265518188477, 0.09297777712345123, 0.01571018248796463, 0.0870371013879776, 0.009083952754735947, -0.13441553711891174, -0.003028314560651779, -0.030815448611974716, 0.116831474006176, -0.033947739750146866, 0.03214125335216522, 0.03142814710736275, -0.006930502597242594, -0.06748800724744797, -0.033477783203125, 0.05141128972172737, 0.01557004451751709, 0.0173359252512455, 0.038670431822538376, 0.09269639104604721, 0.0994696170091629, 0.032795533537864685, 0.166595458984375, 0.20153844356536865, -0.05835914611816406, 0.10318446159362793, -0.16652753949165344, 0.011482350528240204, -0.12247061729431152, 0.0009590524714440107, -0.1253689080476761, 0.3108498454093933, -0.1603662371635437, 0.14048543572425842, -0.008333951234817505, 0.21513241529464722, -0.031358156353235245, 0.061340998858213425, 0.08404833823442459, -0.1301238089799881, 0.159209743142128, -0.11452312767505646, 0.03090899996459484, 0.047362688928842545, -0.09617218375205994, -0.009852156043052673, -0.002486981451511383, -0.08535240590572357, 0.1187744289636612, 0.09363680332899094, 0.06400052458047867, -0.00041995570063591003, 0.160170316696167, 0.20066654682159424, -0.026683904230594635, -0.09802337735891342, 0.7324175834655762, -0.4985933303833008, 0.19045507907867432, -0.1384538859128952, 0.24488992989063263, 0.02868949994444847, 0.21702611446380615, -0.041201330721378326, 0.030468393117189407, 0.11524130403995514, 0.06894112378358841, -0.07037314772605896, -0.0015498306602239609, -0.11201418936252594, 0.20156323909759521, 0.051480911672115326, 0.10717305541038513, 0.16223302483558655, -0.08568891882896423, 0.14570313692092896, -0.07852348685264587, -0.05117282271385193, 0.07419441640377045, -0.07140929251909256, -0.12671294808387756, 0.12985415756702423, 0.2287437915802002, -0.01348813995718956, -0.04609004035592079, -0.019610177725553513, 0.07657495141029358, 0.16267408430576324, -0.06012021005153656, 0.08060618489980698, -0.05969315022230148, 0.268751323223114, -0.29401835799217224, -0.23212090134620667, 0.04388821870088577, -0.09635232388973236, 0.08824462443590164, 0.07331733405590057, 0.28240010142326355, 0.09753621369600296, -0.23095262050628662, 0.002102769911289215, -0.04604487493634224, -0.11614570021629333, 0.0476662814617157, 0.060146264731884, 0.15609602630138397, 0.08147872984409332, 0.12188826501369476, 0.006272779777646065, 0.02958153747022152, 0.03373827040195465, -0.16061735153198242, 0.23720623552799225, 0.18360692262649536, 0.17029733955860138, -0.07780781388282776, 0.10842658579349518, -0.07737483084201813, 0.04772091656923294, 0.012681938707828522, 0.09387687593698502, 0.02363809570670128, -0.1016339510679245, 0.017591185867786407, -0.1701747626066208, -0.08574080467224121, 0.057209163904190063, 0.13581037521362305, -0.027455929666757584, 0.07022896409034729, 0.11045326292514801, 0.10974518954753876, -0.07685550302267075, -0.1129523515701294, -0.06178075820207596, -0.18093308806419373, 0.028525471687316895, 0.0012450739741325378, 0.00921284407377243, 0.021874569356441498, 0.07122364640235901, -0.05708806961774826, 0.02695104479789734, -0.17148537933826447, 0.08043926954269409, 0.17182490229606628, 0.11179507523775101, 0.15068680047988892, -0.04925857484340668, -0.10737713426351547, -0.03849073499441147, -0.04798686504364014, -0.049521878361701965, -0.07204999029636383, 0.15725494921207428, -0.04503545165061951, 0.018786460161209106, 0.25424498319625854, 0.029059765860438347, 0.14411868155002594, 0.04469172656536102, -0.013743419200181961, -0.11246265470981598, -0.10870181024074554, 0.007213640958070755, 0.07248089462518692, 0.034806348383426666, 0.01793249323964119, -0.00035553425550460815, 0.1307862102985382, -0.07562659680843353, -0.05138374865055084, 0.2840733826160431, 0.0835462361574173, -0.12377017736434937, 0.08118405938148499, -0.1189831793308258, 0.08226624876260757, -0.09356079995632172, -0.5465725064277649, 0.10559982061386108, 0.1648750603199005, 0.0862811803817749, 0.014530990272760391, 0.0626220554113388, 0.04038384556770325, 0.05558150261640549, 0.1416504830121994, 0.026471765711903572, -0.13642451167106628, 0.05592907965183258, -0.004916556179523468, 0.1372320055961609, -0.014037545770406723, 0.11764314770698547, 0.11126138269901276, 0.05148612707853317, 0.11239096522331238, 0.03536560758948326, -0.11553208529949188, 0.004773704335093498, 0.008397333323955536, -0.04976623132824898, -0.0759219378232956, 0.09266471117734909, -0.16357502341270447, 0.023681355640292168, 0.06114504858851433, 0.14128246903419495, -0.05149821192026138, -0.025053827092051506, -0.1536114513874054, 0.18470969796180725, 0.1189674660563469, -0.0949731171131134, -0.01996864750981331, -0.018854808062314987, 0.008527655154466629, -0.032922688871622086, 0.1302787959575653, 0.2732394337654114, 0.08618615567684174, 0.1553768515586853, 0.07317845523357391, 0.23776504397392273, -0.0496869757771492, 0.025630664080381393, 0.13107088208198547, 0.08120720088481903, 0.029150092974305153, -0.10661111772060394, -0.07087495177984238, 0.001851322129368782, 0.08171737939119339, 0.002196885645389557, -0.1368863582611084, -0.06393321603536606, 0.038674719631671906, 0.15935929119586945, -0.009667497128248215, 0.05857199430465698, 0.02460826188325882, 0.06010746210813522, 0.07147156447172165, 0.05333245173096657, 0.28219154477119446, -0.16295042634010315, -0.10997524857521057, -0.03411928191781044, 0.02426011860370636, -0.0703926682472229, 0.057143524289131165, 0.12141943722963333, -0.09598352760076523, 0.092860147356987, 0.055574048310518265, 0.07542520016431808, 0.028770864009857178, 0.023251410573720932, 0.12114080786705017, -0.07421663403511047, 0.052116893231868744, 0.06251299381256104, -0.035562679171562195, 0.13588754832744598, -0.06463413685560226, -0.18922032415866852, -0.09097412973642349, 0.14075219631195068, -0.054216478019952774, 0.0516943633556366, 0.0450664684176445, 0.2073192000389099, 0.01021905243396759, 0.06834439933300018, -0.07193467766046524, -0.08874775469303131, -0.783177375793457, -0.006343428045511246, 0.08316025137901306, -0.054887499660253525, 0.021325454115867615, 0.15038800239562988, 0.08669916540384293, 0.013450730592012405, 0.10759054124355316, 0.04413490742444992, -0.01774255931377411, 0.1543612778186798, 0.10423032194375992, -0.1129070594906807, -0.05055064335465431, 0.10332400351762772, 0.13100270926952362, -0.18246324360370636, 0.11668446660041809, -0.07311072200536728, -0.07666679471731186, -0.032719992101192474, 0.19346877932548523, 0.011818408966064453, 0.026574844494462013, 0.2487582266330719, 0.10648731142282486, 0.16960787773132324, -0.03613510727882385, 0.06472161412239075, 0.2012302726507187, 0.09540081024169922, -0.22276081144809723, 0.06565435975790024, 0.06654330343008041, 0.08329421281814575, 0.15826261043548584, 13.483729362487793, -0.12249388545751572, 0.1706937849521637, 0.07538042217493057, -0.05600668489933014, -0.0490591824054718, -0.058201394975185394, 0.10139624029397964, -0.05080355703830719, -0.02859947830438614, 0.0852142870426178, 0.007844227366149426, -0.015957890078425407, 0.10300016403198242, -0.0019557401537895203, 0.0032468512654304504, 0.032187964767217636, -0.07061374932527542, 0.1543484479188919, 0.007753312587738037, 0.003191038966178894, -0.10486207902431488, 0.001570485532283783, -0.2447759360074997, -0.0734962597489357, 0.0046587660908699036, 0.14511016011238098, 0.11526764929294586, 0.06640252470970154, 0.012625418603420258, 0.1944357007741928, 0.14917981624603271, 0.07888337224721909, -0.04545620083808899, -0.07407499104738235, -0.23370948433876038, -0.4531000256538391, -0.01910039782524109, 0.07311441004276276, -0.10076174139976501, 0.053800661116838455, -0.016018494963645935, 0.11217597126960754, -0.09725334495306015, 0.018144093453884125, 0.024404261261224747, -0.1387242078781128, 0.1682460904121399, 0.022635802626609802, -0.07178722321987152, 0.1517418622970581, 0.051946744322776794, 0.26300662755966187, 0.02822338603436947, -0.08904289454221725, -0.18224482238292694, 0.21021835505962372, 0.0626133382320404, 0.054964225739240646, 0.3149664103984833, -0.035579048097133636, -0.0552624836564064, -0.07281506061553955, -0.07469257712364197, -0.09934056550264359, 0.10275167226791382, 0.15537503361701965, 0.08970794826745987, 0.01190408319234848, 0.045677173882722855, 0.10880255699157715, -0.10552342981100082, 0.013608820736408234, 0.10158831626176834, -0.08521527051925659, 0.1875787228345871, -0.0838535949587822, -0.004040185362100601, 0.10173361003398895, -0.17568941414356232, 0.058781079947948456, -0.01239195466041565, -0.13630390167236328, -0.05723603814840317, -0.12105190753936768, 0.13550469279289246, -0.11430300772190094, 0.1863725483417511, 0.18639908730983734, -0.022947661578655243, -0.07500056177377701, 0.007554255425930023, -0.06166854500770569, -0.13088110089302063, 0.18872877955436707, -0.08657639473676682, 0.07119116932153702, -0.15648283064365387, 0.07831373810768127, 0.10422679036855698, -0.03327923268079758, -0.17633554339408875, -0.03160254657268524, 0.19918067753314972, -0.1394539624452591, 0.007118798792362213, 0.02758261188864708, 0.04292762652039528, -0.0680711567401886, 0.04610488563776016, 0.07744847238063812, 0.19106829166412354, 0.09285105764865875, -0.2091846913099289, -0.11474256217479706, 0.02144519053399563, 0.03786828741431236, -0.03754047676920891, 0.16282962262630463, 0.05555936321616173, 0.11155438423156738, 0.05942327529191971, -0.08846147358417511, -0.03305536136031151, 0.1304682195186615, -0.027471909299492836, 0.06935429573059082, 0.17893154919147491, 0.11035072058439255, -0.011049743741750717, 0.0991918295621872, -0.1211329773068428, 0.3338169455528259, 0.06871973723173141, 0.01145944744348526, 0.07952331751585007, 0.03435855731368065, 0.07755311578512192, 0.11478961259126663, 0.14917343854904175, 0.0752972811460495, 0.05578126013278961, 0.1966169774532318, -0.10928107798099518, -0.027940675616264343, 0.1485503613948822, 0.21000441908836365, -0.03952416032552719, -0.07227210700511932, 0.16388335824012756, 0.15612463653087616, 0.22636678814888, -0.10657484829425812, -0.15483589470386505, -0.13581787049770355, -0.1220904290676117, -0.1057058721780777, 0.05088192597031593, 0.05937235802412033, 0.0010785618796944618, 0.25801989436149597, -0.42761704325675964, -0.00677221454679966, -0.2522778809070587, -0.16501647233963013, 0.10277602076530457, 0.06945442408323288, 0.0558786615729332, 0.04771868884563446, -0.11969379335641861, 0.13777118921279907, -0.006259305402636528, -0.248647540807724, -0.036615751683712006, -0.04371622949838638, 0.068387471139431, 0.19729799032211304, -0.2660233676433563, -0.13358376920223236, 0.06664583832025528]}"
"{\"sha\": \"00ede07ca6c77e3b71aaa699b2c48b9718700cc8\", \"repo\": \"/Users/rlucas/Collections-C\", \"path\": \"test/unit/munit.c\", \"func_name\": \"munit_str_hash\", \"original_string\": \"static munit_uint32_t\\nmunit_str_hash(const char* name) {\\n  const char *p;\\n  munit_uint32_t h = 5381U;\\n\\n  for (p = name; *p != '\\\\0'; p++)\\n    h = (h << 5) + h + *p;\\n\\n  return h;\\n}\", \"code_tokens\": [\"static\", \"munit_uint32_t\", \"munit_str_hash\", \"(\", \"const\", \"char\", \"*\", \"name\", \")\", \"{\", \"const\", \"char\", \"*\", \"p\", \";\", \"munit_uint32_t\", \"h\", \"=\", \"5381U\", \";\", \"for\", \"(\", \"p\", \"=\", \"name\", \";\", \"*\", \"p\", \"!=\", \"'\", \"\\\\0\", \"'\", \";\", \"p\", \"++\", \")\", \"h\", \"=\", \"(\", \"h\", \"<<\", \"5\", \")\", \"+\", \"h\", \"+\", \"*\", \"p\", \";\", \"return\", \"h\", \";\", \"}\"], \"docstring\": \"/* Cheap string hash function, just used to salt the PRNG. */\", \"docstring_tokens\": [\"/\", \"*\", \"Cheap\", \"string\", \"hash\", \"function\", \"just\", \"used\", \"to\", \"salt\", \"the\", \"PRNG\", \".\", \"*\", \"/\"], \"raw_contents\": \"/* Copyright (c) 2013-2018 Evan Nemerson <evan@nemerson.com>\\n *\\n * Permission is hereby granted, free of charge, to any person\\n * obtaining a copy of this software and associated documentation\\n * files (the \\\"Software\\\"), to deal in the Software without\\n * restriction, including without limitation the rights to use, copy,\\n * modify, merge, publish, distribute, sublicense, and/or sell copies\\n * of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be\\n * included in all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND,\\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n * SOFTWARE.\\n */\\n\\n/*** Configuration ***/\\n\\n/* This is just where the output from the test goes.  It's really just\\n * meant to let you choose stdout or stderr, but if anyone really want\\n * to direct it to a file let me know, it would be fairly easy to\\n * support. */\\n#if !defined(MUNIT_OUTPUT_FILE)\\n#  define MUNIT_OUTPUT_FILE stdout\\n#endif\\n\\n/* This is a bit more useful; it tells \\u00b5nit how to format the seconds in\\n * timed tests.  If your tests run for longer you might want to reduce\\n * it, and if your computer is really fast and your tests are tiny you\\n * can increase it. */\\n#if !defined(MUNIT_TEST_TIME_FORMAT)\\n#  define MUNIT_TEST_TIME_FORMAT \\\"0.8f\\\"\\n#endif\\n\\n/* If you have long test names you might want to consider bumping\\n * this.  The result information takes 43 characters. */\\n#if !defined(MUNIT_TEST_NAME_LEN)\\n#  define MUNIT_TEST_NAME_LEN 37\\n#endif\\n\\n/* If you don't like the timing information, you can disable it by\\n * defining MUNIT_DISABLE_TIMING. */\\n#if !defined(MUNIT_DISABLE_TIMING)\\n#  define MUNIT_ENABLE_TIMING\\n#endif\\n\\n/*** End configuration ***/\\n\\n#if defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE < 200809L)\\n#  undef _POSIX_C_SOURCE\\n#endif\\n#if !defined(_POSIX_C_SOURCE)\\n#  define _POSIX_C_SOURCE 200809L\\n#endif\\n\\n/* Solaris freaks out if you try to use a POSIX or SUS standard without\\n * the \\\"right\\\" C standard. */\\n#if defined(_XOPEN_SOURCE)\\n#  undef _XOPEN_SOURCE\\n#endif\\n\\n#if defined(__STDC_VERSION__)\\n#  if __STDC_VERSION__ >= 201112L\\n#    define _XOPEN_SOURCE 700\\n#  elif __STDC_VERSION__ >= 199901L\\n#    define _XOPEN_SOURCE 600\\n#  endif\\n#endif\\n\\n/* Because, according to Microsoft, POSIX is deprecated.  You've got\\n * to appreciate the chutzpah. */\\n#if defined(_MSC_VER) && !defined(_CRT_NONSTDC_NO_DEPRECATE)\\n#  define _CRT_NONSTDC_NO_DEPRECATE\\n#endif\\n\\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\\n#  include <stdbool.h>\\n#elif defined(_WIN32)\\n/* https://msdn.microsoft.com/en-us/library/tf4dy80a.aspx */\\n#endif\\n\\n#include <limits.h>\\n#include <time.h>\\n#include <errno.h>\\n#include <string.h>\\n#include <stdlib.h>\\n#include <stdio.h>\\n#include <stdarg.h>\\n#include <setjmp.h>\\n\\n#if !defined(MUNIT_NO_NL_LANGINFO) && !defined(_WIN32)\\n#define MUNIT_NL_LANGINFO\\n#include <locale.h>\\n#include <langinfo.h>\\n#include <strings.h>\\n#endif\\n\\n#if !defined(_WIN32)\\n#  include <unistd.h>\\n#  include <sys/types.h>\\n#  include <sys/wait.h>\\n#else\\n#  include <windows.h>\\n#  include <io.h>\\n#  include <fcntl.h>\\n#  if !defined(STDERR_FILENO)\\n#    define STDERR_FILENO _fileno(stderr)\\n#  endif\\n#endif\\n\\n#include \\\"munit.h\\\"\\n\\n#define MUNIT_STRINGIFY(x) #x\\n#define MUNIT_XSTRINGIFY(x) MUNIT_STRINGIFY(x)\\n\\n#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__SUNPRO_CC) || defined(__IBMCPP__)\\n#  define MUNIT_THREAD_LOCAL __thread\\n#elif (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201102L)) || defined(_Thread_local)\\n#  define MUNIT_THREAD_LOCAL _Thread_local\\n#elif defined(_WIN32)\\n#  define MUNIT_THREAD_LOCAL __declspec(thread)\\n#endif\\n\\n/* MSVC 12.0 will emit a warning at /W4 for code like 'do { ... }\\n * while (0)', or 'do { ... } while (1)'.  I'm pretty sure nobody\\n * at Microsoft compiles with /W4. */\\n#if defined(_MSC_VER) && (_MSC_VER <= 1800)\\n#pragma warning(disable: 4127)\\n#endif\\n\\n#if defined(_WIN32) || defined(__EMSCRIPTEN__)\\n#  define MUNIT_NO_FORK\\n#endif\\n\\n#if defined(__EMSCRIPTEN__)\\n#  define MUNIT_NO_BUFFER\\n#endif\\n\\n/*** Logging ***/\\n\\nstatic MunitLogLevel munit_log_level_visible = MUNIT_LOG_INFO;\\nstatic MunitLogLevel munit_log_level_fatal = MUNIT_LOG_ERROR;\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\nstatic MUNIT_THREAD_LOCAL munit_bool munit_error_jmp_buf_valid = 0;\\nstatic MUNIT_THREAD_LOCAL jmp_buf munit_error_jmp_buf;\\n#endif\\n\\n/* At certain warning levels, mingw will trigger warnings about\\n * suggesting the format attribute, which we've explicity *not* set\\n * because it will then choke on our attempts to use the MS-specific\\n * I64 modifier for size_t (which we have to use since MSVC doesn't\\n * support the C99 z modifier). */\\n\\n#if defined(__MINGW32__) || defined(__MINGW64__)\\n#  pragma GCC diagnostic push\\n#  pragma GCC diagnostic ignored \\\"-Wsuggest-attribute=format\\\"\\n#endif\\n\\nMUNIT_PRINTF(5,0)\\nstatic void\\nmunit_logf_exv(MunitLogLevel level, FILE* fp, const char* filename, int line, const char* format, va_list ap) {\\n  if (level < munit_log_level_visible)\\n    return;\\n\\n  switch (level) {\\n    case MUNIT_LOG_DEBUG:\\n      fputs(\\\"Debug\\\", fp);\\n      break;\\n    case MUNIT_LOG_INFO:\\n      fputs(\\\"Info\\\", fp);\\n      break;\\n    case MUNIT_LOG_WARNING:\\n      fputs(\\\"Warning\\\", fp);\\n      break;\\n    case MUNIT_LOG_ERROR:\\n      fputs(\\\"Error\\\", fp);\\n      break;\\n    default:\\n      munit_logf_ex(MUNIT_LOG_ERROR, filename, line, \\\"Invalid log level (%d)\\\", level);\\n      return;\\n  }\\n\\n  fputs(\\\": \\\", fp);\\n  if (filename != NULL)\\n    fprintf(fp, \\\"%s:%d: \\\", filename, line);\\n  vfprintf(fp, format, ap);\\n  fputc('\\\\n', fp);\\n}\\n\\nMUNIT_PRINTF(3,4)\\nstatic void\\nmunit_logf_internal(MunitLogLevel level, FILE* fp, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(level, fp, NULL, 0, format, ap);\\n  va_end(ap);\\n}\\n\\nstatic void\\nmunit_log_internal(MunitLogLevel level, FILE* fp, const char* message) {\\n  munit_logf_internal(level, fp, \\\"%s\\\", message);\\n}\\n\\nvoid\\nmunit_logf_ex(MunitLogLevel level, const char* filename, int line, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(level, stderr, filename, line, format, ap);\\n  va_end(ap);\\n\\n  if (level >= munit_log_level_fatal) {\\n#if defined(MUNIT_THREAD_LOCAL)\\n    if (munit_error_jmp_buf_valid)\\n      longjmp(munit_error_jmp_buf, 1);\\n#endif\\n    abort();\\n  }\\n}\\n\\nvoid\\nmunit_errorf_ex(const char* filename, int line, const char* format, ...) {\\n  va_list ap;\\n\\n  va_start(ap, format);\\n  munit_logf_exv(MUNIT_LOG_ERROR, stderr, filename, line, format, ap);\\n  va_end(ap);\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\n  if (munit_error_jmp_buf_valid)\\n    longjmp(munit_error_jmp_buf, 1);\\n#endif\\n  abort();\\n}\\n\\n#if defined(__MINGW32__) || defined(__MINGW64__)\\n#pragma GCC diagnostic pop\\n#endif\\n\\n#if !defined(MUNIT_STRERROR_LEN)\\n#  define MUNIT_STRERROR_LEN 80\\n#endif\\n\\nstatic void\\nmunit_log_errno(MunitLogLevel level, FILE* fp, const char* msg) {\\n#if defined(MUNIT_NO_STRERROR_R) || (defined(__MINGW32__) && !defined(MINGW_HAS_SECURE_API))\\n  munit_logf_internal(level, fp, \\\"%s: %s (%d)\\\", msg, strerror(errno), errno);\\n#else\\n  char munit_error_str[MUNIT_STRERROR_LEN];\\n  munit_error_str[0] = '\\\\0';\\n\\n#if !defined(_WIN32)\\n  strerror_r(errno, munit_error_str, MUNIT_STRERROR_LEN);\\n#else\\n  strerror_s(munit_error_str, MUNIT_STRERROR_LEN, errno);\\n#endif\\n\\n  munit_logf_internal(level, fp, \\\"%s: %s (%d)\\\", msg, munit_error_str, errno);\\n#endif\\n}\\n\\n/*** Memory allocation ***/\\n\\nvoid*\\nmunit_malloc_ex(const char* filename, int line, size_t size) {\\n  void* ptr;\\n\\n  if (size == 0)\\n    return NULL;\\n\\n  ptr = calloc(1, size);\\n  if (MUNIT_UNLIKELY(ptr == NULL)) {\\n    munit_logf_ex(MUNIT_LOG_ERROR, filename, line, \\\"Failed to allocate %\\\" MUNIT_SIZE_MODIFIER \\\"u bytes.\\\", size);\\n  }\\n\\n  return ptr;\\n}\\n\\n/*** Timer code ***/\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n\\n#define psnip_uint64_t munit_uint64_t\\n#define psnip_uint32_t munit_uint32_t\\n\\n/* Code copied from portable-snippets\\n * <https://github.com/nemequ/portable-snippets/>.  If you need to\\n * change something, please do it there so we can keep the code in\\n * sync. */\\n\\n/* Clocks (v1)\\n * Portable Snippets - https://gitub.com/nemequ/portable-snippets\\n * Created by Evan Nemerson <evan@nemerson.com>\\n *\\n *   To the extent possible under law, the authors have waived all\\n *   copyright and related or neighboring rights to this code.  For\\n *   details, see the Creative Commons Zero 1.0 Universal license at\\n *   https://creativecommons.org/publicdomain/zero/1.0/\\n */\\n\\n#if !defined(PSNIP_CLOCK_H)\\n#define PSNIP_CLOCK_H\\n\\n#if !defined(psnip_uint64_t)\\n#  include \\\"../exact-int/exact-int.h\\\"\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_STATIC_INLINE)\\n#  if defined(__GNUC__)\\n#    define PSNIP_CLOCK__COMPILER_ATTRIBUTES __attribute__((__unused__))\\n#  else\\n#    define PSNIP_CLOCK__COMPILER_ATTRIBUTES\\n#  endif\\n\\n#  define PSNIP_CLOCK__FUNCTION PSNIP_CLOCK__COMPILER_ATTRIBUTES static\\n#endif\\n\\nenum PsnipClockType {\\n  /* This clock provides the current time, in units since 1970-01-01\\n   * 00:00:00 UTC not including leap seconds.  In other words, UNIX\\n   * time.  Keep in mind that this clock doesn't account for leap\\n   * seconds, and can go backwards (think NTP adjustments). */\\n  PSNIP_CLOCK_TYPE_WALL = 1,\\n  /* The CPU time is a clock which increases only when the current\\n   * process is active (i.e., it doesn't increment while blocking on\\n   * I/O). */\\n  PSNIP_CLOCK_TYPE_CPU = 2,\\n  /* Monotonic time is always running (unlike CPU time), but it only\\n     ever moves forward unless you reboot the system.  Things like NTP\\n     adjustments have no effect on this clock. */\\n  PSNIP_CLOCK_TYPE_MONOTONIC = 3\\n};\\n\\nstruct PsnipClockTimespec {\\n  psnip_uint64_t seconds;\\n  psnip_uint64_t nanoseconds;\\n};\\n\\n/* Methods we support: */\\n\\n#define PSNIP_CLOCK_METHOD_CLOCK_GETTIME                   1\\n#define PSNIP_CLOCK_METHOD_TIME                            2\\n#define PSNIP_CLOCK_METHOD_GETTIMEOFDAY                    3\\n#define PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER         4\\n#define PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME              5\\n#define PSNIP_CLOCK_METHOD_CLOCK                           6\\n#define PSNIP_CLOCK_METHOD_GETPROCESSTIMES                 7\\n#define PSNIP_CLOCK_METHOD_GETRUSAGE                       8\\n#define PSNIP_CLOCK_METHOD_GETSYSTEMTIMEPRECISEASFILETIME  9\\n#define PSNIP_CLOCK_METHOD_GETTICKCOUNT64                 10\\n\\n#include <assert.h>\\n\\n#if defined(HEDLEY_UNREACHABLE)\\n#  define PSNIP_CLOCK_UNREACHABLE() HEDLEY_UNREACHABLE()\\n#else\\n#  define PSNIP_CLOCK_UNREACHABLE() assert(0)\\n#endif\\n\\n/* Choose an implementation */\\n\\n/* #undef PSNIP_CLOCK_WALL_METHOD */\\n/* #undef PSNIP_CLOCK_CPU_METHOD */\\n/* #undef PSNIP_CLOCK_MONOTONIC_METHOD */\\n\\n/* We want to be able to detect the libc implementation, so we include\\n   <limits.h> (<features.h> isn't available everywhere). */\\n\\n#if defined(__unix__) || defined(__unix) || defined(__linux__)\\n#  include <limits.h>\\n#  include <unistd.h>\\n#endif\\n\\n#if defined(_POSIX_TIMERS) && (_POSIX_TIMERS > 0)\\n/* These are known to work without librt.  If you know of others\\n * please let us know so we can add them. */\\n#  if \\\\\\n  (defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 17))) || \\\\\\n  (defined(__FreeBSD__))\\n#    define PSNIP_CLOCK_HAVE_CLOCK_GETTIME\\n#  elif !defined(PSNIP_CLOCK_NO_LIBRT)\\n#    define PSNIP_CLOCK_HAVE_CLOCK_GETTIME\\n#  endif\\n#endif\\n\\n#if defined(_WIN32)\\n#  if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#    define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n#  endif\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n#  endif\\n#endif\\n\\n#if defined(__MACH__) && !defined(__gnu_hurd__)\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n#  endif\\n#endif\\n\\n#if defined(PSNIP_CLOCK_HAVE_CLOCK_GETTIME)\\n#  include <time.h>\\n#  if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#    if defined(CLOCK_REALTIME_PRECISE)\\n#      define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_WALL CLOCK_REALTIME_PRECISE\\n#    elif !defined(__sun)\\n#      define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_WALL CLOCK_REALTIME\\n#    endif\\n#  endif\\n#  if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#    if defined(_POSIX_CPUTIME) || defined(CLOCK_PROCESS_CPUTIME_ID)\\n#      define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_CPU CLOCK_PROCESS_CPUTIME_ID\\n#    elif defined(CLOCK_VIRTUAL)\\n#      define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_CPU CLOCK_VIRTUAL\\n#    endif\\n#  endif\\n#  if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n#    if defined(CLOCK_MONOTONIC_RAW)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC\\n#    elif defined(CLOCK_MONOTONIC_PRECISE)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC_PRECISE\\n#    elif defined(_POSIX_MONOTONIC_CLOCK) || defined(CLOCK_MONOTONIC)\\n#      define PSNIP_CLOCK_MONOTONIC_METHOD PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n#      define PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC CLOCK_MONOTONIC\\n#    endif\\n#  endif\\n#endif\\n\\n#if defined(_POSIX_VERSION) && (_POSIX_VERSION >= 200112L)\\n#  if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#    define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n#  endif\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n#  define PSNIP_CLOCK_WALL_METHOD PSNIP_CLOCK_METHOD_TIME\\n#endif\\n\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n#  define PSNIP_CLOCK_CPU_METHOD PSNIP_CLOCK_METHOD_CLOCK\\n#endif\\n\\n/* Primarily here for testing. */\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD) && defined(PSNIP_CLOCK_REQUIRE_MONOTONIC)\\n#  error No monotonic clock found.\\n#endif\\n\\n/* Implementations */\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_TIME))\\n#  include <time.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETTIMEOFDAY)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETTIMEOFDAY)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY))\\n#  include <sys/time.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES)) || \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETTICKCOUNT64)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETTICKCOUNT64)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64))\\n#  include <windows.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_GETRUSAGE)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_GETRUSAGE)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETRUSAGE))\\n#  include <sys/time.h>\\n#  include <sys/resource.h>\\n#endif\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME))\\n#  include <CoreServices/CoreServices.h>\\n#  include <mach/mach.h>\\n#  include <mach/mach_time.h>\\n#endif\\n\\n/*** Implementations ***/\\n\\n#define PSNIP_CLOCK_NSEC_PER_SEC ((psnip_uint32_t) (1000000000ULL))\\n\\n#if \\\\\\n  (defined(PSNIP_CLOCK_CPU_METHOD)       && (PSNIP_CLOCK_CPU_METHOD       == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_WALL_METHOD)      && (PSNIP_CLOCK_WALL_METHOD      == PSNIP_CLOCK_METHOD_CLOCK_GETTIME)) || \\\\\\n  (defined(PSNIP_CLOCK_MONOTONIC_METHOD) && (PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME))\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock__clock_getres (clockid_t clk_id) {\\n  struct timespec res;\\n  int r;\\n\\n  r = clock_getres(clk_id, &res);\\n  if (r != 0)\\n    return 0;\\n\\n  return (psnip_uint32_t) (PSNIP_CLOCK_NSEC_PER_SEC / res.tv_nsec);\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock__clock_gettime (clockid_t clk_id, struct PsnipClockTimespec* res) {\\n  struct timespec ts;\\n\\n  if (clock_gettime(clk_id, &ts) != 0)\\n    return -10;\\n\\n  res->seconds = (psnip_uint64_t) (ts.tv_sec);\\n  res->nanoseconds = (psnip_uint64_t) (ts.tv_nsec);\\n\\n  return 0;\\n}\\n#endif\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_wall_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_WALL);\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n  return 1000000;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_TIME\\n  return 1;\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_wall_get_time (struct PsnipClockTimespec* res) {\\n  (void) res;\\n\\n#if !defined(PSNIP_CLOCK_WALL_METHOD)\\n  return -2;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_WALL, res);\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_TIME\\n  res->seconds = time(NULL);\\n  res->nanoseconds = 0;\\n#elif defined(PSNIP_CLOCK_WALL_METHOD) && PSNIP_CLOCK_WALL_METHOD == PSNIP_CLOCK_METHOD_GETTIMEOFDAY\\n  struct timeval tv;\\n\\n  if (gettimeofday(&tv, NULL) != 0)\\n    return -6;\\n\\n  res->seconds = tv.tv_sec;\\n  res->nanoseconds = tv.tv_usec * 1000;\\n#else\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_cpu_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_CPU);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK\\n  return CLOCKS_PER_SEC;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n  return PSNIP_CLOCK_NSEC_PER_SEC / 100;\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_cpu_get_time (struct PsnipClockTimespec* res) {\\n#if !defined(PSNIP_CLOCK_CPU_METHOD)\\n  (void) res;\\n  return -2;\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_CPU, res);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_CLOCK\\n  clock_t t = clock();\\n  if (t == ((clock_t) -1))\\n    return -5;\\n  res->seconds = t / CLOCKS_PER_SEC;\\n  res->nanoseconds = (t % CLOCKS_PER_SEC) * (PSNIP_CLOCK_NSEC_PER_SEC / CLOCKS_PER_SEC);\\n#elif defined(PSNIP_CLOCK_CPU_METHOD) && PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETPROCESSTIMES\\n  FILETIME CreationTime, ExitTime, KernelTime, UserTime;\\n  LARGE_INTEGER date, adjust;\\n\\n  if (!GetProcessTimes(GetCurrentProcess(), &CreationTime, &ExitTime, &KernelTime, &UserTime))\\n    return -7;\\n\\n  /* http://www.frenk.com/2009/12/convert-filetime-to-unix-timestamp/ */\\n  date.HighPart = UserTime.dwHighDateTime;\\n  date.LowPart = UserTime.dwLowDateTime;\\n  adjust.QuadPart = 11644473600000 * 10000;\\n  date.QuadPart -= adjust.QuadPart;\\n\\n  res->seconds = date.QuadPart / 10000000;\\n  res->nanoseconds = (date.QuadPart % 10000000) * (PSNIP_CLOCK_NSEC_PER_SEC / 100);\\n#elif PSNIP_CLOCK_CPU_METHOD == PSNIP_CLOCK_METHOD_GETRUSAGE\\n  struct rusage usage;\\n  if (getrusage(RUSAGE_SELF, &usage) != 0)\\n    return -8;\\n\\n  res->seconds = usage.ru_utime.tv_sec;\\n  res->nanoseconds = tv.tv_usec * 1000;\\n#else\\n  (void) res;\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_monotonic_get_precision (void) {\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n  return 0;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_getres(PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n  static mach_timebase_info_data_t tbi = { 0, };\\n  if (tbi.denom == 0)\\n    mach_timebase_info(&tbi);\\n  return (psnip_uint32_t) (tbi.numer / tbi.denom);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64\\n  return 1000;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n  LARGE_INTEGER Frequency;\\n  QueryPerformanceFrequency(&Frequency);\\n  return (psnip_uint32_t) ((Frequency.QuadPart > PSNIP_CLOCK_NSEC_PER_SEC) ? PSNIP_CLOCK_NSEC_PER_SEC : Frequency.QuadPart);\\n#else\\n  return 0;\\n#endif\\n}\\n\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_monotonic_get_time (struct PsnipClockTimespec* res) {\\n#if !defined(PSNIP_CLOCK_MONOTONIC_METHOD)\\n  (void) res;\\n  return -2;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_CLOCK_GETTIME\\n  return psnip_clock__clock_gettime(PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC, res);\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME\\n  psnip_uint64_t nsec = mach_absolute_time();\\n  static mach_timebase_info_data_t tbi = { 0, };\\n  if (tbi.denom == 0)\\n    mach_timebase_info(&tbi);\\n  nsec *= ((psnip_uint64_t) tbi.numer) / ((psnip_uint64_t) tbi.denom);\\n  res->seconds = nsec / PSNIP_CLOCK_NSEC_PER_SEC;\\n  res->nanoseconds = nsec % PSNIP_CLOCK_NSEC_PER_SEC;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER\\n  LARGE_INTEGER t, f;\\n  if (QueryPerformanceCounter(&t) == 0)\\n    return -12;\\n\\n  QueryPerformanceFrequency(&f);\\n  res->seconds = t.QuadPart / f.QuadPart;\\n  res->nanoseconds = t.QuadPart % f.QuadPart;\\n  if (f.QuadPart > PSNIP_CLOCK_NSEC_PER_SEC)\\n    res->nanoseconds /= f.QuadPart / PSNIP_CLOCK_NSEC_PER_SEC;\\n  else\\n    res->nanoseconds *= PSNIP_CLOCK_NSEC_PER_SEC / f.QuadPart;\\n#elif defined(PSNIP_CLOCK_MONOTONIC_METHOD) && PSNIP_CLOCK_MONOTONIC_METHOD == PSNIP_CLOCK_METHOD_GETTICKCOUNT64\\n  const ULONGLONG msec = GetTickCount64();\\n  res->seconds = msec / 1000;\\n  res->nanoseconds = sec % 1000;\\n#else\\n  return -2;\\n#endif\\n\\n  return 0;\\n}\\n\\n/* Returns the number of ticks per second for the specified clock.\\n * For example, a clock with millisecond precision would return 1000,\\n * and a clock with 1 second (such as the time() function) would\\n * return 1.\\n *\\n * If the requested clock isn't available, it will return 0.\\n * Hopefully this will be rare, but if it happens to you please let us\\n * know so we can work on finding a way to support your system.\\n *\\n * Note that different clocks on the same system often have a\\n * different precisions.\\n */\\nPSNIP_CLOCK__FUNCTION psnip_uint32_t\\npsnip_clock_get_precision (enum PsnipClockType clock_type) {\\n  switch (clock_type) {\\n    case PSNIP_CLOCK_TYPE_MONOTONIC:\\n      return psnip_clock_monotonic_get_precision ();\\n    case PSNIP_CLOCK_TYPE_CPU:\\n      return psnip_clock_cpu_get_precision ();\\n    case PSNIP_CLOCK_TYPE_WALL:\\n      return psnip_clock_wall_get_precision ();\\n  }\\n\\n  PSNIP_CLOCK_UNREACHABLE();\\n  return 0;\\n}\\n\\n/* Set the provided timespec to the requested time.  Returns 0 on\\n * success, or a negative value on failure. */\\nPSNIP_CLOCK__FUNCTION int\\npsnip_clock_get_time (enum PsnipClockType clock_type, struct PsnipClockTimespec* res) {\\n  assert(res != NULL);\\n\\n  switch (clock_type) {\\n    case PSNIP_CLOCK_TYPE_MONOTONIC:\\n      return psnip_clock_monotonic_get_time (res);\\n    case PSNIP_CLOCK_TYPE_CPU:\\n      return psnip_clock_cpu_get_time (res);\\n    case PSNIP_CLOCK_TYPE_WALL:\\n      return psnip_clock_wall_get_time (res);\\n  }\\n\\n  return -1;\\n}\\n\\n#endif /* !defined(PSNIP_CLOCK_H) */\\n\\nstatic psnip_uint64_t\\nmunit_clock_get_elapsed(struct PsnipClockTimespec* start, struct PsnipClockTimespec* end) {\\n  psnip_uint64_t r = (end->seconds - start->seconds) * PSNIP_CLOCK_NSEC_PER_SEC;\\n  if (end->nanoseconds < start->nanoseconds) {\\n    r -= (start->nanoseconds - end->nanoseconds);\\n  } else {\\n    r += (end->nanoseconds - start->nanoseconds);\\n  }\\n  return r;\\n}\\n\\n#else\\n#  include <time.h>\\n#endif /* defined(MUNIT_ENABLE_TIMING) */\\n\\n/*** PRNG stuff ***/\\n\\n/* This is (unless I screwed up, which is entirely possible) the\\n * version of PCG with 32-bit state.  It was chosen because it has a\\n * small enough state that we should reliably be able to use CAS\\n * instead of requiring a lock for thread-safety.\\n *\\n * If I did screw up, I probably will not bother changing it unless\\n * there is a significant bias.  It's really not important this be\\n * particularly strong, as long as it is fairly random it's much more\\n * important that it be reproducible, so bug reports have a better\\n * chance of being reproducible. */\\n\\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__) && !defined(__EMSCRIPTEN__) && (!defined(__GNUC_MINOR__) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ > 8))\\n#  define HAVE_STDATOMIC\\n#elif defined(__clang__)\\n#  if __has_extension(c_atomic)\\n#    define HAVE_CLANG_ATOMICS\\n#  endif\\n#endif\\n\\n/* Workaround for http://llvm.org/bugs/show_bug.cgi?id=26911 */\\n#if defined(__clang__) && defined(_WIN32)\\n#  undef HAVE_STDATOMIC\\n#  if defined(__c2__)\\n#    undef HAVE_CLANG_ATOMICS\\n#  endif\\n#endif\\n\\n#if defined(_OPENMP)\\n#  define ATOMIC_UINT32_T uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#elif defined(HAVE_STDATOMIC)\\n#  include <stdatomic.h>\\n#  define ATOMIC_UINT32_T _Atomic uint32_t\\n#  define ATOMIC_UINT32_INIT(x) ATOMIC_VAR_INIT(x)\\n#elif defined(HAVE_CLANG_ATOMICS)\\n#  define ATOMIC_UINT32_T _Atomic uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#elif defined(_WIN32)\\n#  define ATOMIC_UINT32_T volatile LONG\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#else\\n#  define ATOMIC_UINT32_T volatile uint32_t\\n#  define ATOMIC_UINT32_INIT(x) (x)\\n#endif\\n\\nstatic ATOMIC_UINT32_T munit_rand_state = ATOMIC_UINT32_INIT(42);\\n\\n#if defined(_OPENMP)\\nstatic inline void\\nmunit_atomic_store(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T value) {\\n#pragma omp critical (munit_atomics)\\n  *dest = value;\\n}\\n\\nstatic inline uint32_t\\nmunit_atomic_load(ATOMIC_UINT32_T* src) {\\n  int ret;\\n#pragma omp critical (munit_atomics)\\n  ret = *src;\\n  return ret;\\n}\\n\\nstatic inline uint32_t\\nmunit_atomic_cas(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T* expected, ATOMIC_UINT32_T desired) {\\n  munit_bool ret;\\n\\n#pragma omp critical (munit_atomics)\\n  {\\n    if (*dest == *expected) {\\n      *dest = desired;\\n      ret = 1;\\n    } else {\\n      ret = 0;\\n    }\\n  }\\n\\n  return ret;\\n}\\n#elif defined(HAVE_STDATOMIC)\\n#  define munit_atomic_store(dest, value)         atomic_store(dest, value)\\n#  define munit_atomic_load(src)                  atomic_load(src)\\n#  define munit_atomic_cas(dest, expected, value) atomic_compare_exchange_weak(dest, expected, value)\\n#elif defined(HAVE_CLANG_ATOMICS)\\n#  define munit_atomic_store(dest, value)         __c11_atomic_store(dest, value, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_load(src)                  __c11_atomic_load(src, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_cas(dest, expected, value) __c11_atomic_compare_exchange_weak(dest, expected, value, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\\n#elif defined(__GNUC__) && (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)\\n#  define munit_atomic_store(dest, value)         __atomic_store_n(dest, value, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_load(src)                  __atomic_load_n(src, __ATOMIC_SEQ_CST)\\n#  define munit_atomic_cas(dest, expected, value) __atomic_compare_exchange_n(dest, expected, value, 1, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\\n#elif defined(__GNUC__) && (__GNUC__ >= 4)\\n#  define munit_atomic_store(dest,value)          do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\n#  define munit_atomic_cas(dest, expected, value) __sync_bool_compare_and_swap(dest, *expected, value)\\n#elif defined(_WIN32) /* Untested */\\n#  define munit_atomic_store(dest,value)          do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\n#  define munit_atomic_cas(dest, expected, value) InterlockedCompareExchange((dest), (value), *(expected))\\n#else\\n#  warning No atomic implementation, PRNG will not be thread-safe\\n#  define munit_atomic_store(dest, value)         do { *(dest) = (value); } while (0)\\n#  define munit_atomic_load(src)                  (*(src))\\nstatic inline munit_bool\\nmunit_atomic_cas(ATOMIC_UINT32_T* dest, ATOMIC_UINT32_T* expected, ATOMIC_UINT32_T desired) {\\n  if (*dest == *expected) {\\n    *dest = desired;\\n    return 1;\\n  } else {\\n    return 0;\\n  }\\n}\\n#endif\\n\\n#define MUNIT_PRNG_MULTIPLIER (747796405U)\\n#define MUNIT_PRNG_INCREMENT  (1729U)\\n\\nstatic munit_uint32_t\\nmunit_rand_next_state(munit_uint32_t state) {\\n  return state * MUNIT_PRNG_MULTIPLIER + MUNIT_PRNG_INCREMENT;\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_from_state(munit_uint32_t state) {\\n  munit_uint32_t res = ((state >> ((state >> 28) + 4)) ^ state) * (277803737U);\\n  res ^= res >> 22;\\n  return res;\\n}\\n\\nvoid\\nmunit_rand_seed(munit_uint32_t seed) {\\n  munit_uint32_t state = munit_rand_next_state(seed + MUNIT_PRNG_INCREMENT);\\n  munit_atomic_store(&munit_rand_state, state);\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_generate_seed(void) {\\n  munit_uint32_t seed, state;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  struct PsnipClockTimespec wc = { 0, };\\n\\n  psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wc);\\n  seed = (munit_uint32_t) wc.nanoseconds;\\n#else\\n  seed = (munit_uint32_t) time(NULL);\\n#endif\\n\\n  state = munit_rand_next_state(seed + MUNIT_PRNG_INCREMENT);\\n  return munit_rand_from_state(state);\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_state_uint32(munit_uint32_t* state) {\\n  const munit_uint32_t old = *state;\\n  *state = munit_rand_next_state(old);\\n  return munit_rand_from_state(old);\\n}\\n\\nmunit_uint32_t\\nmunit_rand_uint32(void) {\\n  munit_uint32_t old, state;\\n\\n  do {\\n    old = munit_atomic_load(&munit_rand_state);\\n    state = munit_rand_next_state(old);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return munit_rand_from_state(old);\\n}\\n\\nstatic void\\nmunit_rand_state_memory(munit_uint32_t* state, size_t size, munit_uint8_t data[MUNIT_ARRAY_PARAM(size)]) {\\n  size_t members_remaining = size / sizeof(munit_uint32_t);\\n  size_t bytes_remaining = size % sizeof(munit_uint32_t);\\n  munit_uint8_t* b = data;\\n  munit_uint32_t rv;\\n  while (members_remaining-- > 0) {\\n    rv = munit_rand_state_uint32(state);\\n    memcpy(b, &rv, sizeof(munit_uint32_t));\\n    b += sizeof(munit_uint32_t);\\n  }\\n  if (bytes_remaining != 0) {\\n    rv = munit_rand_state_uint32(state);\\n    memcpy(b, &rv, bytes_remaining);\\n  }\\n}\\n\\nvoid\\nmunit_rand_memory(size_t size, munit_uint8_t data[MUNIT_ARRAY_PARAM(size)]) {\\n  munit_uint32_t old, state;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n    munit_rand_state_memory(&state, size, data);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_state_at_most(munit_uint32_t* state, munit_uint32_t salt, munit_uint32_t max) {\\n  /* We want (UINT32_MAX + 1) % max, which in unsigned arithmetic is the same\\n   * as (UINT32_MAX + 1 - max) % max = -max % max. We compute -max using not\\n   * to avoid compiler warnings.\\n   */\\n  const munit_uint32_t min = (~max + 1U) % max;\\n  munit_uint32_t x;\\n\\n  if (max == (~((munit_uint32_t) 0U)))\\n    return munit_rand_state_uint32(state) ^ salt;\\n\\n  max++;\\n\\n  do {\\n    x = munit_rand_state_uint32(state) ^ salt;\\n  } while (x < min);\\n\\n  return x % max;\\n}\\n\\nstatic munit_uint32_t\\nmunit_rand_at_most(munit_uint32_t salt, munit_uint32_t max) {\\n  munit_uint32_t old, state;\\n  munit_uint32_t retval;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n    retval = munit_rand_state_at_most(&state, salt, max);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return retval;\\n}\\n\\nint\\nmunit_rand_int_range(int min, int max) {\\n  munit_uint64_t range = (munit_uint64_t) max - (munit_uint64_t) min;\\n\\n  if (min > max)\\n    return munit_rand_int_range(max, min);\\n\\n  if (range > (~((munit_uint32_t) 0U)))\\n    range = (~((munit_uint32_t) 0U));\\n\\n  return min + munit_rand_at_most(0, (munit_uint32_t) range);\\n}\\n\\ndouble\\nmunit_rand_double(void) {\\n  munit_uint32_t old, state;\\n  double retval = 0.0;\\n\\n  do {\\n    state = old = munit_atomic_load(&munit_rand_state);\\n\\n    /* See http://mumble.net/~campbell/tmp/random_real.c for how to do\\n     * this right.  Patches welcome if you feel that this is too\\n     * biased. */\\n    retval = munit_rand_state_uint32(&state) / ((~((munit_uint32_t) 0U)) + 1.0);\\n  } while (!munit_atomic_cas(&munit_rand_state, &old, state));\\n\\n  return retval;\\n}\\n\\n/*** Test suite handling ***/\\n\\ntypedef struct {\\n  unsigned int successful;\\n  unsigned int skipped;\\n  unsigned int failed;\\n  unsigned int errored;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  munit_uint64_t cpu_clock;\\n  munit_uint64_t wall_clock;\\n#endif\\n} MunitReport;\\n\\ntypedef struct {\\n  const char* prefix;\\n  const MunitSuite* suite;\\n  const char** tests;\\n  munit_uint32_t seed;\\n  unsigned int iterations;\\n  MunitParameter* parameters;\\n  munit_bool single_parameter_mode;\\n  void* user_data;\\n  MunitReport report;\\n  munit_bool colorize;\\n  munit_bool fork;\\n  munit_bool show_stderr;\\n  munit_bool fatal_failures;\\n} MunitTestRunner;\\n\\nconst char*\\nmunit_parameters_get(const MunitParameter params[], const char* key) {\\n  const MunitParameter* param;\\n\\n  for (param = params ; param != NULL && param->name != NULL ; param++)\\n    if (strcmp(param->name, key) == 0)\\n      return param->value;\\n  return NULL;\\n}\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\nstatic void\\nmunit_print_time(FILE* fp, munit_uint64_t nanoseconds) {\\n  fprintf(fp, \\\"%\\\" MUNIT_TEST_TIME_FORMAT, ((double) nanoseconds) / ((double) PSNIP_CLOCK_NSEC_PER_SEC));\\n}\\n#endif\\n\\n/* Add a paramter to an array of parameters. */\\nstatic MunitResult\\nmunit_parameters_add(size_t* params_size, MunitParameter* params[MUNIT_ARRAY_PARAM(*params_size)], char* name, char* value) {\\n  *params = realloc(*params, sizeof(MunitParameter) * (*params_size + 2));\\n  if (*params == NULL)\\n    return MUNIT_ERROR;\\n\\n  (*params)[*params_size].name = name;\\n  (*params)[*params_size].value = value;\\n  (*params_size)++;\\n  (*params)[*params_size].name = NULL;\\n  (*params)[*params_size].value = NULL;\\n\\n  return MUNIT_OK;\\n}\\n\\n/* Concatenate two strings, but just return one of the components\\n * unaltered if the other is NULL or \\\"\\\". */\\nstatic char*\\nmunit_maybe_concat(size_t* len, char* prefix, char* suffix) {\\n  char* res;\\n  size_t res_l;\\n  const size_t prefix_l = prefix != NULL ? strlen(prefix) : 0;\\n  const size_t suffix_l = suffix != NULL ? strlen(suffix) : 0;\\n  if (prefix_l == 0 && suffix_l == 0) {\\n    res = NULL;\\n    res_l = 0;\\n  } else if (prefix_l == 0 && suffix_l != 0) {\\n    res = suffix;\\n    res_l = suffix_l;\\n  } else if (prefix_l != 0 && suffix_l == 0) {\\n    res = prefix;\\n    res_l = prefix_l;\\n  } else {\\n    res_l = prefix_l + suffix_l;\\n    res = malloc(res_l + 1);\\n    memcpy(res, prefix, prefix_l);\\n    memcpy(res + prefix_l, suffix, suffix_l);\\n    res[res_l] = 0;\\n  }\\n\\n  if (len != NULL)\\n    *len = res_l;\\n\\n  return res;\\n}\\n\\n/* Possbily free a string returned by munit_maybe_concat. */\\nstatic void\\nmunit_maybe_free_concat(char* s, const char* prefix, const char* suffix) {\\n  if (prefix != s && suffix != s)\\n    free(s);\\n}\\n\\n/* Cheap string hash function, just used to salt the PRNG. */\\nstatic munit_uint32_t\\nmunit_str_hash(const char* name) {\\n  const char *p;\\n  munit_uint32_t h = 5381U;\\n\\n  for (p = name; *p != '\\\\0'; p++)\\n    h = (h << 5) + h + *p;\\n\\n  return h;\\n}\\n\\nstatic void\\nmunit_splice(int from, int to) {\\n  munit_uint8_t buf[1024];\\n#if !defined(_WIN32)\\n  ssize_t len;\\n  ssize_t bytes_written;\\n  ssize_t write_res;\\n#else\\n  int len;\\n  int bytes_written;\\n  int write_res;\\n#endif\\n  do {\\n    len = read(from, buf, sizeof(buf));\\n    if (len > 0) {\\n      bytes_written = 0;\\n      do {\\n        write_res = write(to, buf + bytes_written, len - bytes_written);\\n        if (write_res < 0)\\n          break;\\n        bytes_written += write_res;\\n      } while (bytes_written < len);\\n    }\\n    else\\n      break;\\n  } while (1);\\n}\\n\\n/* This is the part that should be handled in the child process */\\nstatic MunitResult\\nmunit_test_runner_exec(MunitTestRunner* runner, const MunitTest* test, const MunitParameter params[], MunitReport* report) {\\n  unsigned int iterations = runner->iterations;\\n  MunitResult result = MUNIT_FAIL;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  struct PsnipClockTimespec wall_clock_begin = { 0, }, wall_clock_end = { 0, };\\n  struct PsnipClockTimespec cpu_clock_begin = { 0, }, cpu_clock_end = { 0, };\\n#endif\\n  unsigned int i = 0;\\n\\n  if ((test->options & MUNIT_TEST_OPTION_SINGLE_ITERATION) == MUNIT_TEST_OPTION_SINGLE_ITERATION)\\n    iterations = 1;\\n  else if (iterations == 0)\\n    iterations = runner->suite->iterations;\\n\\n  munit_rand_seed(runner->seed);\\n\\n  do {\\n    void* data = (test->setup == NULL) ? runner->user_data : test->setup(params, runner->user_data);\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wall_clock_begin);\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_CPU, &cpu_clock_begin);\\n#endif\\n\\n    result = test->test(params, data);\\n\\n#if defined(MUNIT_ENABLE_TIMING)\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_WALL, &wall_clock_end);\\n    psnip_clock_get_time(PSNIP_CLOCK_TYPE_CPU, &cpu_clock_end);\\n#endif\\n\\n    if (test->tear_down != NULL)\\n      test->tear_down(data);\\n\\n    if (MUNIT_LIKELY(result == MUNIT_OK)) {\\n      report->successful++;\\n#if defined(MUNIT_ENABLE_TIMING)\\n      report->wall_clock += munit_clock_get_elapsed(&wall_clock_begin, &wall_clock_end);\\n      report->cpu_clock += munit_clock_get_elapsed(&cpu_clock_begin, &cpu_clock_end);\\n#endif\\n    } else {\\n      switch ((int) result) {\\n        case MUNIT_SKIP:\\n          report->skipped++;\\n          break;\\n        case MUNIT_FAIL:\\n          report->failed++;\\n          break;\\n        case MUNIT_ERROR:\\n          report->errored++;\\n          break;\\n        default:\\n          break;\\n      }\\n      break;\\n    }\\n  } while (++i < iterations);\\n\\n  return result;\\n}\\n\\n#if defined(MUNIT_EMOTICON)\\n#  define MUNIT_RESULT_STRING_OK    \\\":)\\\"\\n#  define MUNIT_RESULT_STRING_SKIP  \\\":|\\\"\\n#  define MUNIT_RESULT_STRING_FAIL  \\\":(\\\"\\n#  define MUNIT_RESULT_STRING_ERROR \\\":o\\\"\\n#  define MUNIT_RESULT_STRING_TODO  \\\":/\\\"\\n#else\\n#  define MUNIT_RESULT_STRING_OK    \\\"OK   \\\"\\n#  define MUNIT_RESULT_STRING_SKIP  \\\"SKIP \\\"\\n#  define MUNIT_RESULT_STRING_FAIL  \\\"FAIL \\\"\\n#  define MUNIT_RESULT_STRING_ERROR \\\"ERROR\\\"\\n#  define MUNIT_RESULT_STRING_TODO  \\\"TODO \\\"\\n#endif\\n\\nstatic void\\nmunit_test_runner_print_color(const MunitTestRunner* runner, const char* string, char color) {\\n  if (runner->colorize)\\n    fprintf(MUNIT_OUTPUT_FILE, \\\"\\\\x1b[3%cm%s\\\\x1b[39m\\\", color, string);\\n  else\\n    fputs(string, MUNIT_OUTPUT_FILE);\\n}\\n\\n#if !defined(MUNIT_NO_BUFFER)\\nstatic int\\nmunit_replace_stderr(FILE* stderr_buf) {\\n  if (stderr_buf != NULL) {\\n    const int orig_stderr = dup(STDERR_FILENO);\\n\\n    int errfd = fileno(stderr_buf);\\n    if (MUNIT_UNLIKELY(errfd == -1)) {\\n      exit(EXIT_FAILURE);\\n    }\\n\\n    dup2(errfd, STDERR_FILENO);\\n\\n    return orig_stderr;\\n  }\\n\\n  return -1;\\n}\\n\\nstatic void\\nmunit_restore_stderr(int orig_stderr) {\\n  if (orig_stderr != -1) {\\n    dup2(orig_stderr, STDERR_FILENO);\\n    close(orig_stderr);\\n  }\\n}\\n#endif /* !defined(MUNIT_NO_BUFFER) */\\n\\n/* Run a test with the specified parameters. */\\nstatic void\\nmunit_test_runner_run_test_with_params(MunitTestRunner* runner, const MunitTest* test, const MunitParameter params[]) {\\n  MunitResult result = MUNIT_OK;\\n  MunitReport report = {\\n    0, 0, 0, 0,\\n#if defined(MUNIT_ENABLE_TIMING)\\n    0, 0\\n#endif\\n  };\\n  unsigned int output_l;\\n  munit_bool first;\\n  const MunitParameter* param;\\n  FILE* stderr_buf;\\n#if !defined(MUNIT_NO_FORK)\\n  int pipefd[2];\\n  pid_t fork_pid;\\n  int orig_stderr;\\n  ssize_t bytes_written = 0;\\n  ssize_t write_res;\\n  ssize_t bytes_read = 0;\\n  ssize_t read_res;\\n  int status = 0;\\n  pid_t changed_pid;\\n#endif\\n\\n  if (params != NULL) {\\n    output_l = 2;\\n    fputs(\\\"  \\\", MUNIT_OUTPUT_FILE);\\n    first = 1;\\n    for (param = params ; param != NULL && param->name != NULL ; param++) {\\n      if (!first) {\\n        fputs(\\\", \\\", MUNIT_OUTPUT_FILE);\\n        output_l += 2;\\n      } else {\\n        first = 0;\\n      }\\n\\n      output_l += fprintf(MUNIT_OUTPUT_FILE, \\\"%s=%s\\\", param->name, param->value);\\n    }\\n    while (output_l++ < MUNIT_TEST_NAME_LEN) {\\n      fputc(' ', MUNIT_OUTPUT_FILE);\\n    }\\n  }\\n\\n  fflush(MUNIT_OUTPUT_FILE);\\n\\n  stderr_buf = NULL;\\n#if !defined(_WIN32) || defined(__MINGW32__)\\n  stderr_buf = tmpfile();\\n#else\\n  tmpfile_s(&stderr_buf);\\n#endif\\n  if (stderr_buf == NULL) {\\n    munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to create buffer for stderr\\\");\\n    result = MUNIT_ERROR;\\n    goto print_result;\\n  }\\n\\n#if !defined(MUNIT_NO_FORK)\\n  if (runner->fork) {\\n    pipefd[0] = -1;\\n    pipefd[1] = -1;\\n    if (pipe(pipefd) != 0) {\\n      munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to create pipe\\\");\\n      result = MUNIT_ERROR;\\n      goto print_result;\\n    }\\n\\n    fork_pid = fork();\\n    if (fork_pid == 0) {\\n      close(pipefd[0]);\\n\\n      orig_stderr = munit_replace_stderr(stderr_buf);\\n      munit_test_runner_exec(runner, test, params, &report);\\n\\n      /* Note that we don't restore stderr.  This is so we can buffer\\n       * things written to stderr later on (such as by\\n       * asan/tsan/ubsan, valgrind, etc.) */\\n      close(orig_stderr);\\n\\n      do {\\n        write_res = write(pipefd[1], ((munit_uint8_t*) (&report)) + bytes_written, sizeof(report) - bytes_written);\\n        if (write_res < 0) {\\n          if (stderr_buf != NULL) {\\n            munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to write to pipe\\\");\\n          }\\n          exit(EXIT_FAILURE);\\n        }\\n        bytes_written += write_res;\\n      } while ((size_t) bytes_written < sizeof(report));\\n\\n      if (stderr_buf != NULL)\\n        fclose(stderr_buf);\\n      close(pipefd[1]);\\n\\n      exit(EXIT_SUCCESS);\\n    } else if (fork_pid == -1) {\\n      close(pipefd[0]);\\n      close(pipefd[1]);\\n      if (stderr_buf != NULL) {\\n        munit_log_errno(MUNIT_LOG_ERROR, stderr, \\\"unable to fork\\\");\\n      }\\n      report.errored++;\\n      result = MUNIT_ERROR;\\n    } else {\\n      close(pipefd[1]);\\n      do {\\n        read_res = read(pipefd[0], ((munit_uint8_t*) (&report)) + bytes_read, sizeof(report) - bytes_read);\\n        if (read_res < 1)\\n          break;\\n        bytes_read += read_res;\\n      } while (bytes_read < (ssize_t) sizeof(report));\\n\\n      changed_pid = waitpid(fork_pid, &status, 0);\\n\\n      if (MUNIT_LIKELY(changed_pid == fork_pid) && MUNIT_LIKELY(WIFEXITED(status))) {\\n        if (bytes_read != sizeof(report)) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child exited unexpectedly with status %d\\\", WEXITSTATUS(status));\\n          report.errored++;\\n        } else if (WEXITSTATUS(status) != EXIT_SUCCESS) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child exited with status %d\\\", WEXITSTATUS(status));\\n          report.errored++;\\n        }\\n      } else {\\n        if (WIFSIGNALED(status)) {\\n#if defined(_XOPEN_VERSION) && (_XOPEN_VERSION >= 700)\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child killed by signal %d (%s)\\\", WTERMSIG(status), strsignal(WTERMSIG(status)));\\n#else\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child killed by signal %d\\\", WTERMSIG(status));\\n#endif\\n        } else if (WIFSTOPPED(status)) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"child stopped by signal %d\\\", WSTOPSIG(status));\\n        }\\n        report.errored++;\\n      }\\n\\n      close(pipefd[0]);\\n      waitpid(fork_pid, NULL, 0);\\n    }\\n  } else\\n#endif\\n  {\\n#if !defined(MUNIT_NO_BUFFER)\\n    const volatile int orig_stderr = munit_replace_stderr(stderr_buf);\\n#endif\\n\\n#if defined(MUNIT_THREAD_LOCAL)\\n    if (MUNIT_UNLIKELY(setjmp(munit_error_jmp_buf) != 0)) {\\n      result = MUNIT_FAIL;\\n      report.failed++;\\n    } else {\\n      munit_error_jmp_buf_valid = 1;\\n      result = munit_test_runner_exec(runner, test, params, &report);\\n    }\\n#else\\n    result = munit_test_runner_exec(runner, test, params, &report);\\n#endif\\n\\n#if !defined(MUNIT_NO_BUFFER)\\n    munit_restore_stderr(orig_stderr);\\n#endif\\n\\n    /* Here just so that the label is used on Windows and we don't get\\n     * a warning */\\n    goto print_result;\\n  }\\n\\n print_result:\\n\\n  fputs(\\\"[ \\\", MUNIT_OUTPUT_FILE);\\n  if ((test->options & MUNIT_TEST_OPTION_TODO) == MUNIT_TEST_OPTION_TODO) {\\n    if (report.failed != 0 || report.errored != 0 || report.skipped != 0) {\\n      munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_TODO, '3');\\n      result = MUNIT_OK;\\n    } else {\\n      munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_ERROR, '1');\\n      if (MUNIT_LIKELY(stderr_buf != NULL))\\n        munit_log_internal(MUNIT_LOG_ERROR, stderr_buf, \\\"Test marked TODO, but was successful.\\\");\\n      runner->report.failed++;\\n      result = MUNIT_ERROR;\\n    }\\n  } else if (report.failed > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_FAIL, '1');\\n    runner->report.failed++;\\n    result = MUNIT_FAIL;\\n  } else if (report.errored > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_ERROR, '1');\\n    runner->report.errored++;\\n    result = MUNIT_ERROR;\\n  } else if (report.skipped > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_SKIP, '3');\\n    runner->report.skipped++;\\n    result = MUNIT_SKIP;\\n  } else if (report.successful > 1) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_OK, '2');\\n#if defined(MUNIT_ENABLE_TIMING)\\n    fputs(\\\" ] [ \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock / report.successful);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock / report.successful);\\n    fprintf(MUNIT_OUTPUT_FILE, \\\" CPU ]\\\\n  %-\\\" MUNIT_XSTRINGIFY(MUNIT_TEST_NAME_LEN) \\\"s Total: [ \\\", \\\"\\\");\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock);\\n    fputs(\\\" CPU\\\", MUNIT_OUTPUT_FILE);\\n#endif\\n    runner->report.successful++;\\n    result = MUNIT_OK;\\n  } else if (report.successful > 0) {\\n    munit_test_runner_print_color(runner, MUNIT_RESULT_STRING_OK, '2');\\n#if defined(MUNIT_ENABLE_TIMING)\\n    fputs(\\\" ] [ \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.wall_clock);\\n    fputs(\\\" / \\\", MUNIT_OUTPUT_FILE);\\n    munit_print_time(MUNIT_OUTPUT_FILE, report.cpu_clock);\\n    fputs(\\\" CPU\\\", MUNIT_OUTPUT_FILE);\\n#endif\\n    runner->report.successful++;\\n    result = MUNIT_OK;\\n  }\\n  fputs(\\\" ]\\\\n\\\", MUNIT_OUTPUT_FILE);\\n\\n  if (stderr_buf != NULL) {\\n    if (result == MUNIT_FAIL || result == MUNIT_ERROR || runner->show_stderr) {\\n      fflush(MUNIT_OUTPUT_FILE);\\n\\n      rewind(stderr_buf);\\n      munit_splice(fileno(stderr_buf), STDERR_FILENO);\\n\\n      fflush(stderr);\\n    }\\n\\n    fclose(stderr_buf);\\n  }\\n}\\n\\nstatic void\\nmunit_test_runner_run_test_wild(MunitTestRunner* runner,\\n                                const MunitTest* test,\\n                                const char* test_name,\\n                                MunitParameter* params,\\n                                MunitParameter* p) {\\n  const MunitParameterEnum* pe;\\n  char** values;\\n  MunitParameter* next;\\n\\n  for (pe = test->parameters ; pe != NULL && pe->name != NULL ; pe++) {\\n    if (p->name == pe->name)\\n      break;\\n  }\\n\\n  if (pe == NULL)\\n    return;\\n\\n  for (values = pe->values ; *values != NULL ; values++) {\\n    next = p + 1;\\n    p->value = *values;\\n    if (next->name == NULL) {\\n      munit_test_runner_run_test_with_params(runner, test, params);\\n    } else {\\n      munit_test_runner_run_test_wild(runner, test, test_name, params, next);\\n    }\\n    if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n      break;\\n  }\\n}\\n\\n/* Run a single test, with every combination of parameters\\n * requested. */\\nstatic void\\nmunit_test_runner_run_test(MunitTestRunner* runner,\\n                           const MunitTest* test,\\n                           const char* prefix) {\\n  char* test_name = munit_maybe_concat(NULL, (char*) prefix, (char*) test->name);\\n  /* The array of parameters to pass to\\n   * munit_test_runner_run_test_with_params */\\n  MunitParameter* params = NULL;\\n  size_t params_l = 0;\\n  /* Wildcard parameters are parameters which have possible values\\n   * specified in the test, but no specific value was passed to the\\n   * CLI.  That means we want to run the test once for every\\n   * possible combination of parameter values or, if --single was\\n   * passed to the CLI, a single time with a random set of\\n   * parameters. */\\n  MunitParameter* wild_params = NULL;\\n  size_t wild_params_l = 0;\\n  const MunitParameterEnum* pe;\\n  const MunitParameter* cli_p;\\n  munit_bool filled;\\n  unsigned int possible;\\n  char** vals;\\n  size_t first_wild;\\n  const MunitParameter* wp;\\n  int pidx;\\n\\n  munit_rand_seed(runner->seed);\\n\\n  fprintf(MUNIT_OUTPUT_FILE, \\\"%-\\\" MUNIT_XSTRINGIFY(MUNIT_TEST_NAME_LEN) \\\"s\\\", test_name);\\n\\n  if (test->parameters == NULL) {\\n    /* No parameters.  Simple, nice. */\\n    munit_test_runner_run_test_with_params(runner, test, NULL);\\n  } else {\\n    fputc('\\\\n', MUNIT_OUTPUT_FILE);\\n\\n    for (pe = test->parameters ; pe != NULL && pe->name != NULL ; pe++) {\\n      /* Did we received a value for this parameter from the CLI? */\\n      filled = 0;\\n      for (cli_p = runner->parameters ; cli_p != NULL && cli_p->name != NULL ; cli_p++) {\\n        if (strcmp(cli_p->name, pe->name) == 0) {\\n          if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, cli_p->value) != MUNIT_OK))\\n            goto cleanup;\\n          filled = 1;\\n          break;\\n        }\\n      }\\n      if (filled)\\n        continue;\\n\\n      /* Nothing from CLI, is the enum NULL/empty?  We're not a\\n       * fuzzer\\u2026 */\\n      if (pe->values == NULL || pe->values[0] == NULL)\\n        continue;\\n\\n      /* If --single was passed to the CLI, choose a value from the\\n       * list of possibilities randomly. */\\n      if (runner->single_parameter_mode) {\\n        possible = 0;\\n        for (vals = pe->values ; *vals != NULL ; vals++)\\n          possible++;\\n        /* We want the tests to be reproducible, even if you're only\\n         * running a single test, but we don't want every test with\\n         * the same number of parameters to choose the same parameter\\n         * number, so use the test name as a primitive salt. */\\n        pidx = munit_rand_at_most(munit_str_hash(test_name), possible - 1);\\n        if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, pe->values[pidx]) != MUNIT_OK))\\n          goto cleanup;\\n      } else {\\n        /* We want to try every permutation.  Put in a placeholder\\n         * entry, we'll iterate through them later. */\\n        if (MUNIT_UNLIKELY(munit_parameters_add(&wild_params_l, &wild_params, pe->name, NULL) != MUNIT_OK))\\n          goto cleanup;\\n      }\\n    }\\n\\n    if (wild_params_l != 0) {\\n      first_wild = params_l;\\n      for (wp = wild_params ; wp != NULL && wp->name != NULL ; wp++) {\\n        for (pe = test->parameters ; pe != NULL && pe->name != NULL && pe->values != NULL ; pe++) {\\n          if (strcmp(wp->name, pe->name) == 0) {\\n            if (MUNIT_UNLIKELY(munit_parameters_add(&params_l, &params, pe->name, pe->values[0]) != MUNIT_OK))\\n              goto cleanup;\\n          }\\n        }\\n      }\\n\\n      munit_test_runner_run_test_wild(runner, test, test_name, params, params + first_wild);\\n    } else {\\n      munit_test_runner_run_test_with_params(runner, test, params);\\n    }\\n\\n  cleanup:\\n    free(params);\\n    free(wild_params);\\n  }\\n\\n  munit_maybe_free_concat(test_name, prefix, test->name);\\n}\\n\\n/* Recurse through the suite and run all the tests.  If a list of\\n * tests to run was provied on the command line, run only those\\n * tests.  */\\nstatic void\\nmunit_test_runner_run_suite(MunitTestRunner* runner,\\n                            const MunitSuite* suite,\\n                            const char* prefix) {\\n  size_t pre_l;\\n  char* pre = munit_maybe_concat(&pre_l, (char*) prefix, (char*) suite->prefix);\\n  const MunitTest* test;\\n  const char** test_name;\\n  const MunitSuite* child_suite;\\n\\n  /* Run the tests. */\\n  for (test = suite->tests ; test != NULL && test->test != NULL ; test++) {\\n    if (runner->tests != NULL) { /* Specific tests were requested on the CLI */\\n      for (test_name = runner->tests ; test_name != NULL && *test_name != NULL ; test_name++) {\\n        if ((pre_l == 0 || strncmp(pre, *test_name, pre_l) == 0) &&\\n            strncmp(test->name, *test_name + pre_l, strlen(*test_name + pre_l)) == 0) {\\n          munit_test_runner_run_test(runner, test, pre);\\n          if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n            goto cleanup;\\n        }\\n      }\\n    } else { /* Run all tests */\\n      munit_test_runner_run_test(runner, test, pre);\\n    }\\n  }\\n\\n  if (runner->fatal_failures && (runner->report.failed != 0 || runner->report.errored != 0))\\n    goto cleanup;\\n\\n  /* Run any child suites. */\\n  for (child_suite = suite->suites ; child_suite != NULL && child_suite->prefix != NULL ; child_suite++) {\\n    munit_test_runner_run_suite(runner, child_suite, pre);\\n  }\\n\\n cleanup:\\n\\n  munit_maybe_free_concat(pre, prefix, suite->prefix);\\n}\\n\\nstatic void\\nmunit_test_runner_run(MunitTestRunner* runner) {\\n  munit_test_runner_run_suite(runner, runner->suite, NULL);\\n}\\n\\nstatic void\\nmunit_print_help(int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)], void* user_data, const MunitArgument arguments[]) {\\n  const MunitArgument* arg;\\n  (void) argc;\\n\\n  printf(\\\"USAGE: %s [OPTIONS...] [TEST...]\\\\n\\\\n\\\", argv[0]);\\n  puts(\\\" --seed SEED\\\\n\\\"\\n       \\\"           Value used to seed the PRNG.  Must be a 32-bit integer in decimal\\\\n\\\"\\n       \\\"           notation with no separators (commas, decimals, spaces, etc.), or\\\\n\\\"\\n       \\\"           hexidecimal prefixed by \\\\\\\"0x\\\\\\\".\\\\n\\\"\\n       \\\" --iterations N\\\\n\\\"\\n       \\\"           Run each test N times.  0 means the default number.\\\\n\\\"\\n       \\\" --param name value\\\\n\\\"\\n       \\\"           A parameter key/value pair which will be passed to any test with\\\\n\\\"\\n       \\\"           takes a parameter of that name.  If not provided, the test will be\\\\n\\\"\\n       \\\"           run once for each possible parameter value.\\\\n\\\"\\n       \\\" --list    Write a list of all available tests.\\\\n\\\"\\n       \\\" --list-params\\\\n\\\"\\n       \\\"           Write a list of all available tests and their possible parameters.\\\\n\\\"\\n       \\\" --single  Run each parameterized test in a single configuration instead of\\\\n\\\"\\n       \\\"           every possible combination\\\\n\\\"\\n       \\\" --log-visible debug|info|warning|error\\\\n\\\"\\n       \\\" --log-fatal debug|info|warning|error\\\\n\\\"\\n       \\\"           Set the level at which messages of different severities are visible,\\\\n\\\"\\n       \\\"           or cause the test to terminate.\\\\n\\\"\\n#if !defined(MUNIT_NO_FORK)\\n       \\\" --no-fork Do not execute tests in a child process.  If this option is supplied\\\\n\\\"\\n       \\\"           and a test crashes (including by failing an assertion), no further\\\\n\\\"\\n       \\\"           tests will be performed.\\\\n\\\"\\n#endif\\n       \\\" --fatal-failures\\\\n\\\"\\n       \\\"           Stop executing tests as soon as a failure is found.\\\\n\\\"\\n       \\\" --show-stderr\\\\n\\\"\\n       \\\"           Show data written to stderr by the tests, even if the test succeeds.\\\\n\\\"\\n       \\\" --color auto|always|never\\\\n\\\"\\n       \\\"           Colorize (or don't) the output.\\\\n\\\"\\n     /* 12345678901234567890123456789012345678901234567890123456789012345678901234567890 */\\n       \\\" --help    Print this help message and exit.\\\\n\\\");\\n#if defined(MUNIT_NL_LANGINFO)\\n  setlocale(LC_ALL, \\\"\\\");\\n  fputs((strcasecmp(\\\"UTF-8\\\", nl_langinfo(CODESET)) == 0) ? \\\"\\u00b5nit\\\" : \\\"munit\\\", stdout);\\n#else\\n  puts(\\\"munit\\\");\\n#endif\\n  printf(\\\" %d.%d.%d\\\\n\\\"\\n         \\\"Full documentation at: https://nemequ.github.io/munit/\\\\n\\\",\\n         (MUNIT_CURRENT_VERSION >> 16) & 0xff,\\n         (MUNIT_CURRENT_VERSION >> 8) & 0xff,\\n         (MUNIT_CURRENT_VERSION >> 0) & 0xff);\\n  for (arg = arguments ; arg != NULL && arg->name != NULL ; arg++)\\n    arg->write_help(arg, user_data);\\n}\\n\\nstatic const MunitArgument*\\nmunit_arguments_find(const MunitArgument arguments[], const char* name) {\\n  const MunitArgument* arg;\\n\\n  for (arg = arguments ; arg != NULL && arg->name != NULL ; arg++)\\n    if (strcmp(arg->name, name) == 0)\\n      return arg;\\n\\n  return NULL;\\n}\\n\\nstatic void\\nmunit_suite_list_tests(const MunitSuite* suite, munit_bool show_params, const char* prefix) {\\n  size_t pre_l;\\n  char* pre = munit_maybe_concat(&pre_l, (char*) prefix, (char*) suite->prefix);\\n  const MunitTest* test;\\n  const MunitParameterEnum* params;\\n  munit_bool first;\\n  char** val;\\n  const MunitSuite* child_suite;\\n\\n  for (test = suite->tests ;\\n       test != NULL && test->name != NULL ;\\n       test++) {\\n    if (pre != NULL)\\n      fputs(pre, stdout);\\n    puts(test->name);\\n\\n    if (show_params) {\\n      for (params = test->parameters ;\\n           params != NULL && params->name != NULL ;\\n           params++) {\\n        fprintf(stdout, \\\" - %s: \\\", params->name);\\n        if (params->values == NULL) {\\n          puts(\\\"Any\\\");\\n        } else {\\n          first = 1;\\n          for (val = params->values ;\\n               *val != NULL ;\\n               val++ ) {\\n            if(!first) {\\n              fputs(\\\", \\\", stdout);\\n            } else {\\n              first = 0;\\n            }\\n            fputs(*val, stdout);\\n          }\\n          putc('\\\\n', stdout);\\n        }\\n      }\\n    }\\n  }\\n\\n  for (child_suite = suite->suites ; child_suite != NULL && child_suite->prefix != NULL ; child_suite++) {\\n    munit_suite_list_tests(child_suite, show_params, pre);\\n  }\\n\\n  munit_maybe_free_concat(pre, prefix, suite->prefix);\\n}\\n\\nstatic munit_bool\\nmunit_stream_supports_ansi(FILE *stream) {\\n#if !defined(_WIN32)\\n  return isatty(fileno(stream));\\n#else\\n\\n#if !defined(__MINGW32__)\\n  size_t ansicon_size = 0;\\n#endif\\n\\n  if (isatty(fileno(stream))) {\\n#if !defined(__MINGW32__)\\n    getenv_s(&ansicon_size, NULL, 0, \\\"ANSICON\\\");\\n    return ansicon_size != 0;\\n#else\\n    return getenv(\\\"ANSICON\\\") != NULL;\\n#endif\\n  }\\n  return 0;\\n#endif\\n}\\n\\nint\\nmunit_suite_main_custom(const MunitSuite* suite, void* user_data,\\n                        int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)],\\n                        const MunitArgument arguments[]) {\\n  int result = EXIT_FAILURE;\\n  MunitTestRunner runner;\\n  size_t parameters_size = 0;\\n  size_t tests_size = 0;\\n  int arg;\\n\\n  char* envptr;\\n  unsigned long ts;\\n  char* endptr;\\n  unsigned long long iterations;\\n  MunitLogLevel level;\\n  const MunitArgument* argument;\\n  const char** runner_tests;\\n  unsigned int tests_run;\\n  unsigned int tests_total;\\n\\n  runner.prefix = NULL;\\n  runner.suite = NULL;\\n  runner.tests = NULL;\\n  runner.seed = 0;\\n  runner.iterations = 0;\\n  runner.parameters = NULL;\\n  runner.single_parameter_mode = 0;\\n  runner.user_data = NULL;\\n\\n  runner.report.successful = 0;\\n  runner.report.skipped = 0;\\n  runner.report.failed = 0;\\n  runner.report.errored = 0;\\n#if defined(MUNIT_ENABLE_TIMING)\\n  runner.report.cpu_clock = 0;\\n  runner.report.wall_clock = 0;\\n#endif\\n\\n  runner.colorize = 0;\\n#if !defined(_WIN32)\\n  runner.fork = 1;\\n#else\\n  runner.fork = 0;\\n#endif\\n  runner.show_stderr = 0;\\n  runner.fatal_failures = 0;\\n  runner.suite = suite;\\n  runner.user_data = user_data;\\n  runner.seed = munit_rand_generate_seed();\\n  runner.colorize = munit_stream_supports_ansi(MUNIT_OUTPUT_FILE);\\n\\n  for (arg = 1 ; arg < argc ; arg++) {\\n    if (strncmp(\\\"--\\\", argv[arg], 2) == 0) {\\n      if (strcmp(\\\"seed\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        envptr = argv[arg + 1];\\n        ts = strtoul(argv[arg + 1], &envptr, 0);\\n        if (*envptr != '\\\\0' || ts > (~((munit_uint32_t) 0U))) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n        runner.seed = (munit_uint32_t) ts;\\n\\n        arg++;\\n      } else if (strcmp(\\\"iterations\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        endptr = argv[arg + 1];\\n        iterations = strtoul(argv[arg + 1], &endptr, 0);\\n        if (*endptr != '\\\\0' || iterations > UINT_MAX) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        runner.iterations = (unsigned int) iterations;\\n\\n        arg++;\\n      } else if (strcmp(\\\"param\\\", argv[arg] + 2) == 0) {\\n        if (arg + 2 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires two arguments\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        runner.parameters = realloc(runner.parameters, sizeof(MunitParameter) * (parameters_size + 2));\\n        if (runner.parameters == NULL) {\\n          munit_log_internal(MUNIT_LOG_ERROR, stderr, \\\"failed to allocate memory\\\");\\n          goto cleanup;\\n        }\\n        runner.parameters[parameters_size].name = (char*) argv[arg + 1];\\n        runner.parameters[parameters_size].value = (char*) argv[arg + 2];\\n        parameters_size++;\\n        runner.parameters[parameters_size].name = NULL;\\n        runner.parameters[parameters_size].value = NULL;\\n        arg += 2;\\n      } else if (strcmp(\\\"color\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(argv[arg + 1], \\\"always\\\") == 0)\\n          runner.colorize = 1;\\n        else if (strcmp(argv[arg + 1], \\\"never\\\") == 0)\\n          runner.colorize = 0;\\n        else if (strcmp(argv[arg + 1], \\\"auto\\\") == 0)\\n          runner.colorize = munit_stream_supports_ansi(MUNIT_OUTPUT_FILE);\\n        else {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        arg++;\\n      } else if (strcmp(\\\"help\\\", argv[arg] + 2) == 0) {\\n        munit_print_help(argc, argv, user_data, arguments);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else if (strcmp(\\\"single\\\", argv[arg] + 2) == 0) {\\n        runner.single_parameter_mode = 1;\\n      } else if (strcmp(\\\"show-stderr\\\", argv[arg] + 2) == 0) {\\n        runner.show_stderr = 1;\\n#if !defined(_WIN32)\\n      } else if (strcmp(\\\"no-fork\\\", argv[arg] + 2) == 0) {\\n        runner.fork = 0;\\n#endif\\n      } else if (strcmp(\\\"fatal-failures\\\", argv[arg] + 2) == 0) {\\n        runner.fatal_failures = 1;\\n      } else if (strcmp(\\\"log-visible\\\", argv[arg] + 2) == 0 ||\\n                 strcmp(\\\"log-fatal\\\", argv[arg] + 2) == 0) {\\n        if (arg + 1 >= argc) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"%s requires an argument\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(argv[arg + 1], \\\"debug\\\") == 0)\\n          level = MUNIT_LOG_DEBUG;\\n        else if (strcmp(argv[arg + 1], \\\"info\\\") == 0)\\n          level = MUNIT_LOG_INFO;\\n        else if (strcmp(argv[arg + 1], \\\"warning\\\") == 0)\\n          level = MUNIT_LOG_WARNING;\\n        else if (strcmp(argv[arg + 1], \\\"error\\\") == 0)\\n          level = MUNIT_LOG_ERROR;\\n        else {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"invalid value ('%s') passed to %s\\\", argv[arg + 1], argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (strcmp(\\\"log-visible\\\", argv[arg] + 2) == 0)\\n          munit_log_level_visible = level;\\n        else\\n          munit_log_level_fatal = level;\\n\\n        arg++;\\n      } else if (strcmp(\\\"list\\\", argv[arg] + 2) == 0) {\\n        munit_suite_list_tests(suite, 0, NULL);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else if (strcmp(\\\"list-params\\\", argv[arg] + 2) == 0) {\\n        munit_suite_list_tests(suite, 1, NULL);\\n        result = EXIT_SUCCESS;\\n        goto cleanup;\\n      } else {\\n        argument = munit_arguments_find(arguments, argv[arg] + 2);\\n        if (argument == NULL) {\\n          munit_logf_internal(MUNIT_LOG_ERROR, stderr, \\\"unknown argument ('%s')\\\", argv[arg]);\\n          goto cleanup;\\n        }\\n\\n        if (!argument->parse_argument(suite, user_data, &arg, argc, argv))\\n          goto cleanup;\\n      }\\n    } else {\\n      runner_tests = realloc((void*) runner.tests, sizeof(char*) * (tests_size + 2));\\n      if (runner_tests == NULL) {\\n        munit_log_internal(MUNIT_LOG_ERROR, stderr, \\\"failed to allocate memory\\\");\\n        goto cleanup;\\n      }\\n      runner.tests = runner_tests;\\n      runner.tests[tests_size++] = argv[arg];\\n      runner.tests[tests_size] = NULL;\\n    }\\n  }\\n\\n  fflush(stderr);\\n  fprintf(MUNIT_OUTPUT_FILE, \\\"Running test suite with seed 0x%08\\\" PRIx32 \\\"...\\\\n\\\", runner.seed);\\n\\n  munit_test_runner_run(&runner);\\n\\n  tests_run = runner.report.successful + runner.report.failed + runner.report.errored;\\n  tests_total = tests_run + runner.report.skipped;\\n  if (tests_run == 0) {\\n    fprintf(stderr, \\\"No tests run, %d (100%%) skipped.\\\\n\\\", runner.report.skipped);\\n  } else {\\n    fprintf(MUNIT_OUTPUT_FILE, \\\"%d of %d (%0.0f%%) tests successful, %d (%0.0f%%) test skipped.\\\\n\\\",\\n            runner.report.successful, tests_run,\\n            (((double) runner.report.successful) / ((double) tests_run)) * 100.0,\\n            runner.report.skipped,\\n            (((double) runner.report.skipped) / ((double) tests_total)) * 100.0);\\n  }\\n\\n  if (runner.report.failed == 0 && runner.report.errored == 0) {\\n    result = EXIT_SUCCESS;\\n  }\\n\\n cleanup:\\n  free(runner.parameters);\\n  free((void*) runner.tests);\\n\\n  return result;\\n}\\n\\nint\\nmunit_suite_main(const MunitSuite* suite, void* user_data,\\n                 int argc, char* const argv[MUNIT_ARRAY_PARAM(argc + 1)]) {\\n  return munit_suite_main_custom(suite, user_data, argc, argv, NULL);\\n}\\n\", \"embeddings\": [0.022722851485013962, 0.04813908040523529, 0.02917221188545227, 0.051667336374521255, 0.3015539050102234, -0.2639046907424927, 0.004055820405483246, 0.21602711081504822, 0.025484643876552582, -0.1394357979297638, 0.00989491119980812, -0.0368671640753746, -0.07524299621582031, 0.06552627682685852, -0.027152448892593384, 0.021115075796842575, 0.05843771621584892, 0.061358191072940826, 0.17358963191509247, -0.19353505969047546, -0.06219921261072159, -0.010415405035018921, 0.19302907586097717, 0.11483938992023468, 0.20164671540260315, 0.016889913007616997, 0.2750653028488159, 0.15103621780872345, 0.15659667551517487, -0.13094717264175415, 0.013796165585517883, -0.0026985034346580505, 0.08529359102249146, -0.12290479242801666, 0.03793416917324066, 0.048973966389894485, 0.14027275145053864, 0.021420598030090332, 0.0019474280998110771, 0.10933635383844376, -0.19859574735164642, -0.09191787987947464, 0.14501312375068665, 0.15168803930282593, 0.012874606996774673, 0.04715171456336975, 0.056061770766973495, 0.1561373919248581, -0.0997801423072815, 0.018572382628917694, 0.08088354766368866, 0.02366624027490616, -0.08888658136129379, 0.06680586189031601, -0.17578883469104767, -0.03219268471002579, 0.07735948264598846, 0.3226720988750458, 0.013170633465051651, 0.012518689036369324, -0.04569215327501297, 0.027767930179834366, -0.08865400403738022, 0.032833848148584366, 0.09190015494823456, 0.057257577776908875, -0.15297017991542816, -0.11387535184621811, -0.07638624310493469, -0.06727702915668488, 0.04285859689116478, -0.03329748660326004, 0.11871017515659332, -0.21579883992671967, -0.07073991745710373, 0.039908818900585175, 0.12610392272472382, 0.612296462059021, -0.1755773425102234, 0.16453836858272552, 0.23402298986911774, -0.09742739796638489, -0.05540667101740837, 0.14002366364002228, 0.08108221739530563, 0.03186209127306938, -0.07678426057100296, -0.067174032330513, 0.11316338181495667, 0.14436638355255127, 0.035444557666778564, 0.12246660888195038, -0.0032153353095054626, 0.03839568421244621, -0.0011030323803424835, -0.03472050651907921, -0.0002600252628326416, -0.3084781765937805, 0.01935005933046341, 0.1991981416940689, -0.01962554082274437, -0.060915131121873856, -0.13693466782569885, 0.04048396646976471, 0.023188702762126923, 0.11241874098777771, 0.024991245940327644, -0.0341704860329628, 0.11336767673492432, -0.09446150809526443, -0.05224599316716194, 0.09671290963888168, 0.012112605385482311, 0.06938263773918152, 0.0332658626139164, -0.1183481439948082, 0.0251186341047287, -0.011412590742111206, 0.03196660429239273, 0.03448505327105522, 0.12243881076574326, 0.07398797571659088, -0.0462578609585762, -0.032226890325546265, -0.023307479918003082, 0.1213403195142746, 0.07102464139461517, -0.14941906929016113, 0.16382953524589539, 0.18481788039207458, 0.029734518378973007, -0.23863039910793304, 0.053427256643772125, -0.010985441505908966, 0.13098175823688507, 0.0326300710439682, 0.028394687920808792, -0.048810385167598724, -0.05579005926847458, 0.011555321514606476, -0.060869768261909485, 0.06785271316766739, 0.3667094111442566, 0.011414710432291031, 0.0992707833647728, -0.07613201439380646, 0.09719423949718475, 0.11729530990123749, -0.22780312597751617, -0.12205546349287033, 0.06990136206150055, -0.08767371624708176, 0.0847596526145935, -0.0352957621216774, -0.21339638531208038, 0.624718964099884, 0.1277865171432495, -0.1172613874077797, -0.03763526678085327, 0.010675802826881409, 0.10358346998691559, -0.23577487468719482, 0.008990548551082611, 0.09317313134670258, 0.04055634140968323, 0.15552417933940887, 0.05623369663953781, 0.11714482307434082, 0.011143486946821213, 0.012017875909805298, 0.0697445422410965, -0.0750628113746643, -0.041082125157117844, 0.15791745483875275, 0.025602124631404877, -0.10388574749231339, -0.2179456651210785, 0.03320407122373581, 0.02587483450770378, 0.0552414134144783, -0.07247184216976166, -0.006714478135108948, -0.11430779099464417, -0.024137161672115326, 0.06940361857414246, 0.1120757907629013, 0.10228672623634338, -0.08631636947393417, 0.18882077932357788, 0.0903729498386383, -0.09903369843959808, 0.12990278005599976, 0.0855579674243927, 0.005588866770267487, -0.031498685479164124, 0.10537395626306534, -0.1099439188838005, -0.050950489938259125, 0.11872725188732147, -0.0439721941947937, -0.1105312928557396, -0.0369231179356575, 0.05310947448015213, -0.12496834993362427, 0.07273848354816437, 0.0908336415886879, -0.02908090315759182, -0.05688893049955368, 0.05042252689599991, -0.08826202154159546, 0.010258588939905167, 0.1870662271976471, 0.06694546341896057, -0.015752527862787247, -0.10082748532295227, -0.09064064174890518, -0.007179964333772659, -0.07276137173175812, -0.006358388811349869, -0.22395585477352142, 0.16472584009170532, 0.25131067633628845, -0.10554254800081253, -0.0828193724155426, -0.011206857860088348, 0.21686136722564697, 0.21695365011692047, -0.09886914491653442, 0.007335752248764038, 0.04927142709493637, 0.18745732307434082, 0.1402970254421234, -0.10820002853870392, 0.10055910050868988, 0.07250555604696274, -0.11319591104984283, -0.09975151717662811, 0.04987075924873352, 0.028318088501691818, -0.02077615261077881, -0.01045004278421402, 0.06363416463136673, 0.08735589683055878, 0.3104950189590454, 0.07910069823265076, 0.10063435137271881, -0.1523541957139969, -0.14811496436595917, -0.16604091227054596, -0.02438315749168396, -0.09549815952777863, -0.116863913834095, 0.1113145723938942, -0.020392540842294693, -0.11443737149238586, -0.06977242231369019, -0.059119366109371185, 0.05789731442928314, 0.04095432162284851, 0.05228095501661301, -0.08144121617078781, -0.026526233181357384, 0.06291121244430542, 0.008776605129241943, -0.019871791824698448, -0.30060985684394836, -0.006323039531707764, 0.062354251742362976, -0.03206503391265869, -0.0015160832554101944, 0.07967165112495422, -0.062450431287288666, 0.24478012323379517, 0.1148504987359047, 0.06626445800065994, -0.05988308787345886, 0.024942513555288315, 0.025951694697141647, -0.009169746190309525, -0.004148699343204498, 0.02177787944674492, 0.13071602582931519, -0.13997730612754822, 0.0708557516336441, -0.025890957564115524, 0.005905669182538986, -0.12025143206119537, -0.024753356352448463, 0.0375349223613739, 0.006403706967830658, 0.015607666224241257, 0.1123160570859909, 0.015325376763939857, 0.11491100490093231, -0.00538397952914238, 0.12909170985221863, 0.11434099078178406, -0.027494795620441437, 0.0916476920247078, -0.18480616807937622, -0.03701794147491455, -0.12199326604604721, -0.020233074203133583, -0.15341821312904358, 0.3367895781993866, -0.05426769331097603, 0.06684394180774689, 0.03300590068101883, 0.2288547307252884, -0.032521698623895645, 0.03234865516424179, 0.07543869316577911, -0.02626803331077099, 0.12215780466794968, -0.07727889716625214, 0.022281555458903313, 0.020888609811663628, -0.09523548185825348, -0.0008211433887481689, -0.022407881915569305, 0.009223103523254395, 0.07743021100759506, 0.009250182658433914, 0.08899887651205063, 0.06660826504230499, 0.15050667524337769, 0.1191580593585968, 0.00013769976794719696, -0.1305811107158661, 0.6866287589073181, -0.6025047302246094, 0.11555871367454529, -0.1888113021850586, 0.25817185640335083, 0.06506988406181335, 0.2114410400390625, 0.015010911971330643, 0.1018347293138504, 0.11476930230855942, 0.07876098901033401, -0.0958089530467987, -0.045566853135824203, -0.02665811777114868, 0.23023448884487152, 0.03985358029603958, 0.1414344608783722, 0.17373235523700714, -0.08201916515827179, 0.0923716127872467, -0.1296830028295517, -0.13301604986190796, 0.1255721002817154, 0.014186397194862366, -0.18274208903312683, 0.03558581322431564, 0.2982785701751709, -0.028610050678253174, -0.06905497610569, 0.004461364820599556, 0.1840144544839859, 0.04852646589279175, -0.006348632276058197, 0.11099019646644592, -0.08444409817457199, 0.2335420548915863, -0.29854616522789, -0.3131922483444214, 0.07209464907646179, -0.04748063161969185, 0.11322154104709625, 0.08980020135641098, 0.2556842863559723, 0.07268671691417694, -0.13864031434059143, 0.030843371525406837, -0.02450849488377571, -0.06923309713602066, 0.054465316236019135, 0.025494512170553207, 0.1131797805428505, 0.026620231568813324, 0.15333768725395203, -0.010082177817821503, 0.008949793875217438, 0.05452615022659302, -0.11787831038236618, 0.27428165078163147, 0.14998897910118103, 0.07022113353013992, -0.02873856946825981, 0.10447070747613907, -0.051118165254592896, 0.029176140204072, 0.040566831827163696, -0.0026327744126319885, -0.016910772770643234, -0.11720120161771774, 0.054522328078746796, -0.1454428732395172, -0.07865916192531586, 0.06088325381278992, 0.06499399244785309, -0.02107921615242958, 0.061368294060230255, 0.10934917628765106, 0.1507723480463028, -0.09394387155771255, -0.1041572242975235, -0.09066955745220184, -0.12716196477413177, -0.0212712362408638, 0.03841947019100189, 0.004737354815006256, -0.0030658170580863953, 0.06810597330331802, -0.0849263072013855, 0.044083122164011, -0.2572769820690155, -0.004384595900774002, 0.06647340208292007, 0.044318780303001404, 0.14219902455806732, -0.019984357059001923, -0.03690483421087265, 0.015060236677527428, -0.006625898648053408, -0.08270935714244843, -0.08435598015785217, 0.16880124807357788, -0.1054755300283432, 0.07620838284492493, 0.3099844753742218, 0.10715558379888535, 0.1474914252758026, 0.07296591997146606, -0.06858112663030624, -0.05251045152544975, -0.05363384261727333, 0.00195951946079731, 0.12489811331033707, -0.04360752925276756, -0.05344591289758682, 0.057340409606695175, 0.07865608483552933, -0.04966985806822777, -0.09402211755514145, 0.28017565608024597, 0.12187939882278442, -0.07152445614337921, 0.10736945271492004, -0.17769485712051392, 0.027631916105747223, -0.07919271290302277, -0.5712265968322754, 0.11088612675666809, 0.16339997947216034, 0.10244898498058319, 0.07564044743776321, 0.13826148211956024, 0.005418956279754639, 0.00859513133764267, 0.169729545712471, 0.05463355779647827, -0.11051017791032791, 0.024502098560333252, 0.0900270938873291, 0.21583569049835205, 0.04265076294541359, 0.08701799809932709, 0.12578848004341125, 0.023532770574092865, 0.09754212200641632, -0.07676396518945694, -0.12183275818824768, 0.016990402713418007, 0.01780681312084198, -0.05959613248705864, -0.11232806742191315, 0.0318501815199852, -0.18905991315841675, -0.04005487635731697, 0.07419586926698685, 0.23809579014778137, -0.0054518356919288635, 0.031204428523778915, -0.12018731981515884, 0.1934317648410797, 0.1850937008857727, -0.12695087492465973, -0.036050889641046524, 0.0024732728488743305, -0.007359495386481285, -0.03926074877381325, 0.1536053717136383, 0.27171826362609863, 0.08089783787727356, 0.17659682035446167, 0.12021976709365845, 0.14522865414619446, -0.07392676174640656, -0.026368625462055206, 0.10426183044910431, 0.07934537529945374, -0.061014484614133835, -0.11712281405925751, -0.07071065902709961, 0.07659348845481873, 0.18067161738872528, 0.028893277049064636, -0.12712079286575317, -0.03227302432060242, -0.057481713593006134, 0.14077669382095337, 0.00022855401039123535, 0.030044637620449066, -0.00964876264333725, 0.06647443026304245, 0.09211453795433044, 0.06843826919794083, 0.18600685894489288, -0.1383548378944397, -0.14264905452728271, -0.036012690514326096, 0.045485615730285645, -0.06558981537818909, 0.055949047207832336, 0.10850118100643158, -0.10719441622495651, 0.08212592452764511, 0.05555351823568344, 0.05336548015475273, 0.014974764548242092, 0.010816540569067001, 0.06087447330355644, -0.03287403658032417, 0.09206877648830414, 0.028184864670038223, -0.05581986904144287, 0.06532219052314758, -0.0011072837514802814, -0.14948426187038422, -0.07201199978590012, 0.16294458508491516, -0.1263767033815384, 0.048485416918992996, -0.03505592793226242, 0.22788792848587036, 0.0005651041865348816, 0.02306145802140236, -0.04129683971405029, -0.09030747413635254, -0.8213586211204529, 0.03466258943080902, 0.12952007353305817, 0.018259761855006218, 0.04155460372567177, 0.0875294953584671, 0.09918085485696793, 0.020856909453868866, 0.12287100404500961, 0.04610705375671387, -0.08084290474653244, 0.1553540676832199, 0.1533491611480713, -0.08305659890174866, -0.028775949031114578, 0.028172656893730164, 0.04260774329304695, -0.12619377672672272, 0.06864432990550995, -0.14063116908073425, -0.02522353082895279, -0.007771827280521393, 0.18239472806453705, -0.09855432063341141, 0.0655289888381958, 0.25450125336647034, 0.105758436024189, 0.1678057312965393, -0.04413171112537384, 0.12715542316436768, 0.19032204151153564, 0.04654413089156151, -0.19458378851413727, 0.11294247955083847, 0.10441789776086807, 0.19375364482402802, 0.2044576108455658, 13.599023818969727, -0.12347007542848587, 0.12029212713241577, 0.024051710963249207, -0.06479064375162125, -0.046283647418022156, -0.11145157366991043, 0.10662051290273666, -0.0033788681030273438, 0.025348491966724396, 0.10208494961261749, -0.08565031737089157, 0.02312616817653179, 0.10996152460575104, 0.030137110501527786, 0.01034276932477951, -0.05807754397392273, -0.035070016980171204, 0.11891710013151169, 0.04567825794219971, -0.044891417026519775, -0.05346682667732239, -0.0002654045820236206, -0.19611144065856934, -0.019921639934182167, 0.04518713802099228, 0.128249391913414, 0.10715256631374359, 0.08183819055557251, 0.07988230139017105, 0.11175753176212311, 0.15373215079307556, 0.0767098143696785, 0.008930511772632599, -0.029104270040988922, -0.20939116179943085, -0.4291834235191345, -0.07434992492198944, 0.052232615649700165, -0.05347111076116562, 0.009068965911865234, -0.04369961470365524, 0.17346560955047607, 0.03999386727809906, 0.04561426118016243, -0.021309278905391693, -0.10149222612380981, 0.17577910423278809, 0.03411015123128891, -0.11731003224849701, 0.12097586691379547, 0.07749930024147034, 0.287675142288208, -0.01024545356631279, -0.15226587653160095, -0.17707034945487976, 0.1922784149646759, 0.008079413324594498, 0.003897041082382202, 0.16510559618473053, -0.0021157152950763702, -0.031287357211112976, -0.06659772992134094, -0.08039514720439911, -0.10668592900037766, 0.05066848173737526, 0.16305036842823029, 0.086860291659832, 0.12611033022403717, 0.0752025693655014, 0.08105511218309402, -0.017731977626681328, 0.06364767253398895, 0.05632204934954643, -0.07011935859918594, 0.1297629475593567, -0.1949205994606018, -0.010869897902011871, 0.06252146512269974, -0.13004416227340698, 0.02739788591861725, 0.009075216948986053, -0.12666639685630798, -0.04907678812742233, -0.13851532340049744, 0.17306867241859436, -0.16082468628883362, 0.23839271068572998, 0.1666501760482788, 0.003914086148142815, -0.04362587258219719, -0.04705466702580452, -0.06357824802398682, -0.04829078167676926, 0.2298320233821869, -0.10840892046689987, 0.06487012654542923, -0.16665823757648468, 0.050967223942279816, 0.05243013799190521, -0.11062667518854141, -0.11694975197315216, -0.004281230270862579, 0.09728403389453888, -0.12096013128757477, 0.004161234945058823, 0.017505785450339317, -0.016373082995414734, -0.017224252223968506, 0.08165797591209412, 0.10038796067237854, 0.18404005467891693, 0.07175415754318237, -0.2111184448003769, -0.11810033023357391, -0.018532127141952515, 0.027398839592933655, -0.0028740353882312775, 0.201408252120018, 0.055903851985931396, 0.06934578716754913, 0.01906472072005272, -0.07298153638839722, -0.07858705520629883, 0.07044258713722229, -0.05519064515829086, 0.04899706691503525, 0.26449599862098694, 0.08533643186092377, 0.019788451492786407, 0.12720748782157898, -0.0822008028626442, 0.2804899513721466, 0.15205758810043335, -0.03021354228258133, 0.061744410544633865, 0.003891274333000183, 0.03337213769555092, 0.13182736933231354, 0.1282394379377365, 0.07489044964313507, 0.03427807241678238, 0.26708728075027466, -0.091941237449646, -0.0789741650223732, 0.14067736268043518, 0.2340185046195984, -0.0475001335144043, -0.10915835201740265, 0.0652998834848404, 0.17174062132835388, 0.2118663489818573, -0.042222581803798676, -0.16623353958129883, -0.14014093577861786, -0.15412214398384094, -0.08776135742664337, 0.07836984843015671, 0.03078891523182392, -0.026134014129638672, 0.18917939066886902, -0.43164873123168945, 0.014708926901221275, -0.2508198618888855, -0.16796152293682098, 0.05140625685453415, 0.11711207777261734, -3.463774919509888e-05, 0.07685603946447372, -0.09900159388780594, 0.21133317053318024, -0.0071616340428590775, -0.19586578011512756, -0.010882455855607986, -0.04432046413421631, -0.006744801998138428, 0.10497017949819565, -0.24567976593971252, -0.12096397578716278, -0.00017504394054412842]}"
